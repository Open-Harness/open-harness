/**
 * Unit Tests for Agent Factory
 *
 * Tests for defineAnthropicAgent() factory function.
 *
 * Run with: bun test tests/unit/factory.test.ts
 */

import { beforeEach, describe, expect, test } from "bun:test";
import type { GenericMessage } from "@openharness/sdk";

import { z } from "zod";

import { defineAnthropicAgent, executeAgent, streamAgent } from "../../src/provider/factory.js";
import { createPromptTemplate, createStaticPrompt } from "../../src/provider/prompt-template.js";
import { createTestContainer } from "../helpers/test-container.js";

// Mock input/output schemas for testing
const TestInputSchema = z.object({
	task: z.string().min(1),
});

const TestOutputSchema = z.object({
	result: z.string(),
});

type TestInput = z.infer<typeof TestInputSchema>;
// type TestOutput = z.infer<typeof TestOutputSchema>;

describe("defineAnthropicAgent", () => {
	describe("agent creation", () => {
		test("returns an agent definition with name and prompt", () => {
			const agent = defineAnthropicAgent({
				name: "TestAgent",
				prompt: createPromptTemplate("Do this: {{task}}"),
				inputSchema: TestInputSchema,
				outputSchema: TestOutputSchema,
			});

			// defineAnthropicAgent now returns a plain config object
			expect(agent).toBeDefined();
			expect(agent.name).toBe("TestAgent");
			expect(agent.prompt).toBeDefined();
			expect(agent.inputSchema).toBe(TestInputSchema);
			expect(agent.outputSchema).toBe(TestOutputSchema);
		});

		test("accepts static string as prompt", () => {
			const agent = defineAnthropicAgent({
				name: "StaticPromptAgent",
				prompt: "You are a helpful assistant. Process the input.",
				inputSchema: TestInputSchema,
				outputSchema: TestOutputSchema,
			});

			expect(agent).toBeDefined();
			expect(agent.name).toBe("StaticPromptAgent");
		});

		test("accepts PromptTemplate as prompt", () => {
			const template = createPromptTemplate("Task: {{task}}", TestInputSchema);

			const agent = defineAnthropicAgent({
				name: "TemplateAgent",
				prompt: template,
				inputSchema: TestInputSchema,
				outputSchema: TestOutputSchema,
			});

			expect(agent).toBeDefined();
			expect(agent.name).toBe("TemplateAgent");
		});

		test("accepts createStaticPrompt as prompt", () => {
			// Static prompts don't use variables, so use empty input schema
			const EmptyInputSchema = z.object({});

			const agent = defineAnthropicAgent({
				name: "StaticTemplateAgent",
				prompt: createStaticPrompt("You are a helpful assistant"),
				inputSchema: EmptyInputSchema,
				outputSchema: TestOutputSchema,
			});

			expect(agent).toBeDefined();
		});
	});

	describe("executeAgent helper", () => {
		test("validates input against schema and throws on invalid input", async () => {
			const { container } = createTestContainer();

			const agent = defineAnthropicAgent({
				name: "ValidatorAgent",
				prompt: createPromptTemplate("Task: {{task}}"),
				inputSchema: TestInputSchema,
				outputSchema: TestOutputSchema,
			});

			// Empty task should fail validation (min 1 char)
			await expect(executeAgent(agent, { task: "" }, { container })).rejects.toThrow("Input validation failed");

			// Missing task should fail
			await expect(executeAgent(agent, {} as TestInput, { container })).rejects.toThrow("Input validation failed");
		});

		test("passes rendered prompt to runner", async () => {
			const { container, mockRunner } = createTestContainer();

			const agent = defineAnthropicAgent({
				name: "PromptRendererAgent",
				prompt: createPromptTemplate("Complete this task: {{task}}"),
				inputSchema: TestInputSchema,
				outputSchema: TestOutputSchema,
			});

			await executeAgent(agent, { task: "test task" }, { container });

			expect(mockRunner.lastPrompt).toBe("Complete this task: test task");
		});

		test("returns structured output from runner", async () => {
			const { container, mockRunner } = createTestContainer();

			mockRunner.mockResult = {
				type: "result",
				subtype: "success",
				structured_output: { result: "expected output" },
			} as unknown as GenericMessage;

			const agent = defineAnthropicAgent({
				name: "OutputAgent",
				prompt: createPromptTemplate("Task: {{task}}"),
				inputSchema: TestInputSchema,
				outputSchema: TestOutputSchema,
			});

			const output = await executeAgent(agent, { task: "test" }, { container });

			expect(output).toEqual({ result: "expected output" });
		});
	});

	describe("streamAgent helper", () => {
		test("returns an AgentHandle with interrupt, streamInput, setModel, and result", () => {
			const { container } = createTestContainer();

			const agent = defineAnthropicAgent({
				name: "StreamAgent",
				prompt: createPromptTemplate("Task: {{task}}"),
				inputSchema: TestInputSchema,
				outputSchema: TestOutputSchema,
			});

			const handle = streamAgent(agent, { task: "test" }, { container });

			expect(handle).toBeDefined();
			expect(typeof handle.interrupt).toBe("function");
			expect(typeof handle.streamInput).toBe("function");
			expect(typeof handle.setModel).toBe("function");
			expect(handle.result).toBeDefined();
			expect(handle.result instanceof Promise).toBe(true);
		});

		test("interrupt can be called without error", () => {
			const { container } = createTestContainer();
			setFactoryContainer(container);

			const agent = defineAnthropicAgent({
				name: "InterruptAgent",
				prompt: createPromptTemplate("Task: {{task}}"),
				inputSchema: TestInputSchema,
				outputSchema: TestOutputSchema,
			});

			const handle = agent.stream({ task: "test" });

			// Should not throw
			expect(() => handle.interrupt()).not.toThrow();
		});

		test("result promise resolves to output", async () => {
			const { container, mockRunner } = createTestContainer();
			setFactoryContainer(container);

			mockRunner.mockResult = {
				type: "result",
				subtype: "success",
				structured_output: { result: "stream result" },
			} as unknown as GenericMessage;

			const agent = defineAnthropicAgent({
				name: "StreamResultAgent",
				prompt: createPromptTemplate("Task: {{task}}"),
				inputSchema: TestInputSchema,
				outputSchema: TestOutputSchema,
			});

			const handle = agent.stream({ task: "test" });
			const output = await handle.result;

			expect(output).toEqual({ result: "stream result" });
		});
	});

	describe("agent options", () => {
		test("accepts optional SDK options", () => {
			const { container } = createTestContainer();
			setFactoryContainer(container);

			const agent = defineAnthropicAgent({
				name: "OptionsAgent",
				prompt: createPromptTemplate("Task: {{task}}"),
				inputSchema: TestInputSchema,
				outputSchema: TestOutputSchema,
				options: {
					model: "claude-sonnet-4-20250514",
					maxTurns: 10,
				},
			});

			expect(agent).toBeDefined();
		});

		test("accepts recording options", () => {
			const { container } = createTestContainer();
			setFactoryContainer(container);

			const agent = defineAnthropicAgent({
				name: "RecordingAgent",
				prompt: createPromptTemplate("Task: {{task}}"),
				inputSchema: TestInputSchema,
				outputSchema: TestOutputSchema,
				recording: {
					enabled: true,
					vaultPath: "./recordings",
				},
			});

			expect(agent).toBeDefined();
		});

		test("accepts monologue options", () => {
			const { container } = createTestContainer();
			setFactoryContainer(container);

			const agent = defineAnthropicAgent({
				name: "MonologueAgent",
				prompt: createPromptTemplate("Task: {{task}}"),
				inputSchema: TestInputSchema,
				outputSchema: TestOutputSchema,
				monologue: {
					enabled: true,
					scope: "test-scope",
				},
			});

			expect(agent).toBeDefined();
		});
	});

	describe("container management", () => {
		test("resetFactoryContainer clears the container", () => {
			const { container: container1 } = createTestContainer();
			setFactoryContainer(container1);

			// Create an agent
			const agent1 = defineAnthropicAgent({
				name: "Agent1",
				prompt: "test",
				inputSchema: TestInputSchema,
				outputSchema: TestOutputSchema,
			});

			// Reset
			resetFactoryContainer();

			// Set a new container
			const { container: container2 } = createTestContainer();
			setFactoryContainer(container2);

			// Creating another agent should work
			const agent2 = defineAnthropicAgent({
				name: "Agent2",
				prompt: "test",
				inputSchema: TestInputSchema,
				outputSchema: TestOutputSchema,
			});

			expect(agent1.name).toBe("Agent1");
			expect(agent2.name).toBe("Agent2");
		});
	});
});

describe("prompt override", () => {
	beforeEach(() => {
		resetFactoryContainer();
	});

	test("execute uses override prompt when provided", async () => {
		const { container, mockRunner } = createTestContainer();
		setFactoryContainer(container);

		const defaultPrompt = createPromptTemplate("Default: {{task}}");
		const overridePrompt = createPromptTemplate("Override: {{task}}");

		const agent = defineAnthropicAgent({
			name: "OverrideAgent",
			prompt: defaultPrompt,
			inputSchema: TestInputSchema,
			outputSchema: TestOutputSchema,
		});

		// Execute with override prompt
		await agent.execute({ task: "test task" }, { prompt: overridePrompt });

		// Should use override prompt, not default
		expect(mockRunner.lastPrompt).toBe("Override: test task");
	});

	test("execute uses default prompt when no override provided", async () => {
		const { container, mockRunner } = createTestContainer();
		setFactoryContainer(container);

		const agent = defineAnthropicAgent({
			name: "DefaultPromptAgent",
			prompt: createPromptTemplate("Default: {{task}}"),
			inputSchema: TestInputSchema,
			outputSchema: TestOutputSchema,
		});

		// Execute without override
		await agent.execute({ task: "test task" });

		// Should use default prompt
		expect(mockRunner.lastPrompt).toBe("Default: test task");
	});

	test("override prompt with different template structure", async () => {
		const { container, mockRunner } = createTestContainer();
		setFactoryContainer(container);

		const agent = defineAnthropicAgent({
			name: "DifferentTemplateAgent",
			prompt: createPromptTemplate("Simple: {{task}}"),
			inputSchema: TestInputSchema,
			outputSchema: TestOutputSchema,
		});

		// Use an override with more elaborate formatting
		const customPrompt = createPromptTemplate("[CUSTOM MODE]\nTask: {{task}}\nPlease process carefully.");

		await agent.execute({ task: "important task" }, { prompt: customPrompt });

		expect(mockRunner.lastPrompt).toBe("[CUSTOM MODE]\nTask: important task\nPlease process carefully.");
	});

	test("stream uses override prompt when provided", async () => {
		const { container, mockRunner } = createTestContainer();
		setFactoryContainer(container);

		const agent = defineAnthropicAgent({
			name: "StreamOverrideAgent",
			prompt: createPromptTemplate("Default: {{task}}"),
			inputSchema: TestInputSchema,
			outputSchema: TestOutputSchema,
		});

		const overridePrompt = createPromptTemplate("Stream override: {{task}}");
		const handle = agent.stream({ task: "test" }, { prompt: overridePrompt });

		await handle.result;

		expect(mockRunner.lastPrompt).toBe("Stream override: test");
	});
});

describe("type safety", () => {
	beforeEach(() => {
		resetFactoryContainer();
	});

	// These tests verify compile-time type safety
	// They should compile without errors

	test("input schema type is enforced at compile time", () => {
		const { container } = createTestContainer();
		setFactoryContainer(container);

		const StringInputSchema = z.object({
			message: z.string(),
		});

		const agent = defineAnthropicAgent({
			name: "TypeSafeAgent",
			prompt: createPromptTemplate("Message: {{message}}"),
			inputSchema: StringInputSchema,
			outputSchema: z.object({ response: z.string() }),
		});

		// This should compile - correct type
		const validInput = { message: "hello" };
		expect(() => agent.execute(validInput)).not.toThrow();

		// TypeScript would catch: agent.execute({ wrong: "key" })
		// But we can test runtime validation
	});

	test("output schema type is available", () => {
		const { container } = createTestContainer();
		setFactoryContainer(container);

		const OutputSchema = z.object({
			code: z.string(),
			language: z.string(),
		});

		const agent = defineAnthropicAgent({
			name: "OutputTypeAgent",
			prompt: "Generate code",
			inputSchema: z.object({ task: z.string() }),
			outputSchema: OutputSchema,
		});

		// The returned promise should be typed as { code: string, language: string }
		// This is verified at compile time
		expect(agent).toBeDefined();
	});
});
