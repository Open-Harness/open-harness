/**
 * Test provider helper using ProviderRecorder playback.
 *
 * Replaces mock-provider.ts with real ProviderRecorder infrastructure.
 * Pre-seeds a LibSQL :memory: recorder with fixture recordings, then uses
 * playback mode so the runtime replays them deterministically.
 *
 * NO MOCKS. This uses the real ProviderRecorder service backed by
 * LibSQL :memory: (real SQLite with real migrations).
 */

import { Context, Effect, Layer, Scope } from "effect"
import type { ZodType } from "zod"

import type { StoreError } from "../../src/Domain/Errors.js"
import { hashProviderRequest } from "../../src/Domain/Hash.js"
import type { AgentProvider, AgentRunResult, AgentStreamEvent } from "../../src/Domain/Provider.js"
import { EventStoreLive, ProviderRecorderLive } from "../../src/Layers/LibSQL.js"
import { EventBus, EventBusLive } from "../../src/Services/EventBus.js"
import { ProviderModeContext } from "../../src/Services/ProviderMode.js"
import { ProviderRecorder, type RecordingEntry } from "../../src/Services/ProviderRecorder.js"

// ─────────────────────────────────────────────────────────────────
// Fixture Recording Types
// ─────────────────────────────────────────────────────────────────

/**
 * A fixture recording to pre-seed into the recorder.
 *
 * Specifies the prompt, output schema, and expected response.
 * The hash is computed automatically from prompt + schema + providerOptions.
 */
export interface FixtureRecording {
  /** The prompt string that will be sent to the provider */
  readonly prompt: string
  /** The output Zod schema (used for hash computation) */
  readonly outputSchema?: ZodType<unknown>
  /** Provider options including model (used for hash computation) */
  readonly providerOptions?: Record<string, unknown>
  /** The stream events to replay */
  readonly streamData: ReadonlyArray<AgentStreamEvent>
  /** The final result */
  readonly result: AgentRunResult
}

/**
 * Simplified fixture: just specify prompt substring match and output.
 *
 * Automatically generates TextDelta/TextComplete/ThinkingDelta/ThinkingComplete/Result
 * stream events, similar to what the old createMockProvider did.
 */
export interface SimpleFixture {
  /** The exact prompt that will be generated by the agent */
  readonly prompt: string
  /** The output object */
  readonly output: unknown
  /** Optional text content */
  readonly text?: string
  /** Optional thinking content */
  readonly thinking?: string
  /** Stop reason (defaults to "end_turn") */
  readonly stopReason?: "end_turn" | "tool_use" | "max_tokens"
  /** Output schema for hash computation */
  readonly outputSchema?: ZodType<unknown>
  /** Provider options for hash computation (must include model) */
  readonly providerOptions?: Record<string, unknown>
}

/**
 * Build stream events from a simple fixture (same logic as old createMockProvider).
 */
function buildStreamEvents(fixture: SimpleFixture): ReadonlyArray<AgentStreamEvent> {
  const events: Array<AgentStreamEvent> = []

  if (fixture.text) {
    events.push({ _tag: "TextDelta", delta: fixture.text })
    events.push({ _tag: "TextComplete", text: fixture.text })
  }

  if (fixture.thinking) {
    events.push({ _tag: "ThinkingDelta", delta: fixture.thinking })
    events.push({ _tag: "ThinkingComplete", thinking: fixture.thinking })
  }

  events.push({
    _tag: "Result",
    output: fixture.output,
    stopReason: fixture.stopReason ?? "end_turn",
    ...(fixture.text ? { text: fixture.text } : {}),
    ...(fixture.thinking ? { thinking: fixture.thinking } : {})
  })

  return events
}

/**
 * Build an AgentRunResult from a simple fixture.
 */
function buildResult(fixture: SimpleFixture): AgentRunResult {
  return {
    output: fixture.output,
    stopReason: fixture.stopReason ?? "end_turn",
    ...(fixture.text ? { text: fixture.text } : {}),
    ...(fixture.thinking ? { thinking: fixture.thinking } : {})
  }
}

/**
 * Compute the hash for a fixture using the same algorithm as the runtime.
 */
function computeFixtureHash(fixture: SimpleFixture): string {
  return hashProviderRequest({
    prompt: fixture.prompt,
    ...(fixture.outputSchema !== undefined ? { outputSchema: fixture.outputSchema } : {}),
    ...(fixture.providerOptions !== undefined ? { providerOptions: fixture.providerOptions } : {})
  })
}

// ─────────────────────────────────────────────────────────────────
// Recording Entry Builder
// ─────────────────────────────────────────────────────────────────

/**
 * Build a RecordingEntry from a SimpleFixture.
 */
function buildRecordingEntry(fixture: SimpleFixture): Omit<RecordingEntry, "recordedAt"> {
  return {
    hash: computeFixtureHash(fixture),
    prompt: fixture.prompt,
    provider: "test-fixture",
    streamData: buildStreamEvents(fixture),
    result: buildResult(fixture)
  }
}

// ─────────────────────────────────────────────────────────────────
// Seeded Recorder Service (for direct RuntimeConfig injection)
// ─────────────────────────────────────────────────────────────────

/**
 * Create a seeded ProviderRecorderService using real LibSQL :memory:.
 *
 * This is an Effect that builds the service and seeds fixtures.
 * Use in test setup with Effect.runPromise or wrap in beforeAll.
 *
 * @param fixtures - Array of simple fixtures to pre-seed
 * @returns Effect that yields a seeded ProviderRecorderService
 */
export const makeSeededRecorder = (
  fixtures: ReadonlyArray<SimpleFixture>
): Effect.Effect<ProviderRecorder["Type"], StoreError, Scope.Scope> =>
  Effect.gen(function*() {
    // Build the real LibSQL layer (runs migrations)
    const baseLayer = ProviderRecorderLive({ url: ":memory:" })
    const context = yield* Layer.build(baseLayer)
    const service = Context.get(context, ProviderRecorder)

    // Seed all fixtures using incremental API
    for (const fixture of fixtures) {
      const entry = buildRecordingEntry(fixture)
      const recordingId = yield* service.startRecording(entry.hash, {
        prompt: entry.prompt,
        provider: entry.provider
      })
      for (const event of entry.streamData) {
        yield* service.appendEvent(recordingId, event)
      }
      yield* service.finalizeRecording(recordingId, entry.result)
    }

    return service
  })

/**
 * Create a seeded ProviderRecorderService.
 *
 * Returns a Promise that resolves to the seeded service.
 * Use in test setup with `beforeAll` or `beforeEach`.
 *
 * Note: The Scope is NOT finalized - the LibSQL client stays open for the
 * process lifetime. For tests running in isolation this is acceptable since:
 * 1. Each test file runs in its own isolate
 * 2. LibSQL :memory: databases are ephemeral anyway
 * 3. Process cleanup handles any resources when the test completes
 *
 * @example
 * ```typescript
 * let recorder: ProviderRecorderService
 *
 * beforeAll(async () => {
 *   recorder = await seedRecorder(fixtures)
 * })
 *
 * it("uses the recorder", async () => {
 *   const result = await run(workflow, { runtime: { recorder } })
 * })
 * ```
 *
 * @param fixtures - Array of simple fixtures to pre-seed
 * @returns Promise resolving to a ProviderRecorderService pre-populated with recordings
 */
export async function seedRecorder(fixtures: ReadonlyArray<SimpleFixture>): Promise<ProviderRecorder["Type"]> {
  // Create a scope that won't be finalized until process exit.
  // This keeps the LibSQL client open for the entire test duration.
  // For test isolation this is fine - each test file runs separately.
  const scope = Effect.runSync(Scope.make())

  return Effect.runPromise(
    makeSeededRecorder(fixtures).pipe(
      Effect.provideService(Scope.Scope, scope)
    )
  )
}

// ─────────────────────────────────────────────────────────────────
// Layer-Based Test Recorder (Real LibSQL :memory:)
// ─────────────────────────────────────────────────────────────────

/**
 * Create a ProviderRecorder layer with pre-seeded fixtures.
 *
 * Uses Layer.unwrapEffect to:
 * 1. Build the real LibSQL layer (runs migrations)
 * 2. Seed all fixtures into the database
 * 3. Return a layer with the seeded service
 *
 * This ensures migrations run BEFORE fixtures are seeded.
 *
 * @param fixtures - Array of simple fixtures to pre-seed
 * @returns A Layer providing ProviderRecorder with seeded fixtures
 */
export const makeTestRecorderLayer = (
  fixtures: ReadonlyArray<SimpleFixture>
): Layer.Layer<ProviderRecorder, StoreError, never> =>
  Layer.unwrapScoped(
    Effect.gen(function*() {
      // Build the real LibSQL layer (runs migrations)
      const baseLayer = ProviderRecorderLive({ url: ":memory:" })
      const context = yield* Layer.build(baseLayer)
      const service = Context.get(context, ProviderRecorder)

      // Seed all fixtures using incremental API
      for (const fixture of fixtures) {
        const entry = buildRecordingEntry(fixture)
        const recordingId = yield* service.startRecording(entry.hash, {
          prompt: entry.prompt,
          provider: entry.provider
        })
        for (const event of entry.streamData) {
          yield* service.appendEvent(recordingId, event)
        }
        yield* service.finalizeRecording(recordingId, entry.result)
      }

      // Return layer with seeded service
      return Layer.succeed(ProviderRecorder, service)
    })
  )

// ─────────────────────────────────────────────────────────────────
// Test Runtime Layer (Playback Mode)
// ─────────────────────────────────────────────────────────────────

/**
 * Options for creating a test runtime layer with playback.
 */
export interface TestRuntimeOptions {
  /** Fixtures to pre-seed into the recorder */
  readonly fixtures: ReadonlyArray<SimpleFixture>
  /** Model name to register a dummy provider under (defaults to "claude-sonnet-4-5") */
  readonly modelName?: string
  /** Additional model names to register */
  readonly additionalModels?: ReadonlyArray<string>
}

// Note: playbackDummyProvider removed per ADR-010 - no longer needed
// since agents own their providers directly

/**
 * Create a test provider for use in agent definitions.
 * Per ADR-010: Agents own their provider directly.
 *
 * This provider is designed for playback mode - it should not be called
 * because recordings are replayed instead.
 *
 * @param modelName - The model name for hash computation (default: "claude-sonnet-4-5")
 * @returns An AgentProvider instance for test use
 */
export function createTestProvider(modelName: string = "claude-sonnet-4-5"): AgentProvider {
  return {
    name: "test-provider",
    model: modelName,
    stream: () => {
      throw new Error(
        "Test provider stream() was called. " +
          "In playback mode, recordings should be used instead. " +
          "Check that fixtures are seeded correctly."
      )
    }
  }
}

/** Default test provider for most tests (claude-sonnet-4-5) */
export const testProvider = createTestProvider()

/**
 * Create a complete test runtime layer using ProviderRecorder playback.
 *
 * This provides all the services needed to run workflows in tests:
 * - ProviderModeContext set to "playback"
 * - ProviderRecorder pre-seeded with fixtures (LibSQL :memory:)
 * - EventStore (LibSQL :memory:)
 * - EventBus (real PubSub)
 *
 * Per CLAUDE.md: Uses real implementations with :memory: databases - no mocks.
 * Note: Per ADR-010, ProviderRegistry is no longer needed - agents own their providers directly.
 */
export const createTestRuntimeLayer = (options: TestRuntimeOptions) => {
  const { fixtures } = options

  const ProviderModeLayer = Layer.succeed(ProviderModeContext, { mode: "playback" as const })

  // Real LibSQL :memory: with pre-seeded fixtures
  const RecorderLayer = makeTestRecorderLayer(fixtures)

  // Real LibSQL :memory: event store
  const EventStoreLayer = EventStoreLive({ url: ":memory:" })

  // Real PubSub-backed event bus
  const EventBusLayer = Layer.effect(EventBus, EventBusLive)

  return Layer.mergeAll(
    ProviderModeLayer,
    RecorderLayer,
    EventStoreLayer,
    EventBusLayer
  )
}

/**
 * Run an Effect with test runtime services using ProviderRecorder playback.
 *
 * Convenience wrapper for tests that need to run Effects with recorded fixtures.
 */
export const runWithTestRuntime = <A>(
  effect: Effect.Effect<A, any, any>,
  options: TestRuntimeOptions
): Promise<A> => {
  const layer = createTestRuntimeLayer(options)
  const provided = effect.pipe(Effect.provide(layer))
  return Effect.runPromise(provided as Effect.Effect<A, never, never>)
}
