/**
 * Test provider helper using ProviderRecorder playback.
 *
 * Replaces mock-provider.ts with real ProviderRecorder infrastructure.
 * Pre-seeds an in-memory recorder with fixture recordings, then uses
 * playback mode so the runtime replays them deterministically.
 *
 * NO MOCKS. This uses the real ProviderRecorder service backed by
 * in-memory storage (makeInMemoryProviderRecorder).
 */

import { Effect, Layer } from "effect"
import type { ZodType } from "zod"

import { hashProviderRequest } from "../../src/Domain/Hash.js"
import type { AgentProvider, AgentRunResult, AgentStreamEvent } from "../../src/Domain/Provider.js"
import { InMemoryEventBus, InMemoryEventStore, makeInMemoryProviderRecorder } from "../../src/Layers/InMemory.js"
import { makeInMemoryProviderRegistry, ProviderRegistry } from "../../src/Engine/provider.js"
import { ProviderModeContext } from "../../src/Services/ProviderMode.js"
import {
  ProviderRecorder,
  type ProviderRecorderService,
  type RecordingEntry
} from "../../src/Services/ProviderRecorder.js"

// ─────────────────────────────────────────────────────────────────
// Fixture Recording Types
// ─────────────────────────────────────────────────────────────────

/**
 * A fixture recording to pre-seed into the recorder.
 *
 * Specifies the prompt, output schema, and expected response.
 * The hash is computed automatically from prompt + schema + providerOptions.
 */
export interface FixtureRecording {
  /** The prompt string that will be sent to the provider */
  readonly prompt: string
  /** The output Zod schema (used for hash computation) */
  readonly outputSchema?: ZodType<unknown>
  /** Provider options including model (used for hash computation) */
  readonly providerOptions?: Record<string, unknown>
  /** The stream events to replay */
  readonly streamData: ReadonlyArray<AgentStreamEvent>
  /** The final result */
  readonly result: AgentRunResult
}

/**
 * Simplified fixture: just specify prompt substring match and output.
 *
 * Automatically generates TextDelta/TextComplete/ThinkingDelta/ThinkingComplete/Result
 * stream events, similar to what the old createMockProvider did.
 */
export interface SimpleFixture {
  /** The exact prompt that will be generated by the agent */
  readonly prompt: string
  /** The output object */
  readonly output: unknown
  /** Optional text content */
  readonly text?: string
  /** Optional thinking content */
  readonly thinking?: string
  /** Stop reason (defaults to "end_turn") */
  readonly stopReason?: "end_turn" | "tool_use" | "max_tokens"
  /** Output schema for hash computation */
  readonly outputSchema?: ZodType<unknown>
  /** Provider options for hash computation (must include model) */
  readonly providerOptions?: Record<string, unknown>
}

/**
 * Build stream events from a simple fixture (same logic as old createMockProvider).
 */
function buildStreamEvents(fixture: SimpleFixture): ReadonlyArray<AgentStreamEvent> {
  const events: Array<AgentStreamEvent> = []

  if (fixture.text) {
    events.push({ _tag: "TextDelta", delta: fixture.text })
    events.push({ _tag: "TextComplete", text: fixture.text })
  }

  if (fixture.thinking) {
    events.push({ _tag: "ThinkingDelta", delta: fixture.thinking })
    events.push({ _tag: "ThinkingComplete", thinking: fixture.thinking })
  }

  events.push({
    _tag: "Result",
    output: fixture.output,
    stopReason: fixture.stopReason ?? "end_turn",
    ...(fixture.text ? { text: fixture.text } : {}),
    ...(fixture.thinking ? { thinking: fixture.thinking } : {})
  })

  return events
}

/**
 * Build an AgentRunResult from a simple fixture.
 */
function buildResult(fixture: SimpleFixture): AgentRunResult {
  return {
    output: fixture.output,
    stopReason: fixture.stopReason ?? "end_turn",
    ...(fixture.text ? { text: fixture.text } : {}),
    ...(fixture.thinking ? { thinking: fixture.thinking } : {})
  }
}

/**
 * Compute the hash for a fixture using the same algorithm as the runtime.
 */
function computeFixtureHash(fixture: SimpleFixture): string {
  return hashProviderRequest({
    prompt: fixture.prompt,
    ...(fixture.outputSchema !== undefined ? { outputSchema: fixture.outputSchema } : {}),
    ...(fixture.providerOptions !== undefined ? { providerOptions: fixture.providerOptions } : {})
  })
}

// ─────────────────────────────────────────────────────────────────
// Recorder Seeding
// ─────────────────────────────────────────────────────────────────

/**
 * Create and seed an in-memory ProviderRecorderService with fixture recordings.
 *
 * @param fixtures - Array of simple fixtures to pre-seed
 * @returns A ProviderRecorderService pre-populated with recordings
 */
export function seedRecorder(fixtures: ReadonlyArray<SimpleFixture>): ProviderRecorderService {
  const recorder = makeInMemoryProviderRecorder()

  // Pre-seed all fixtures synchronously via Effect.runSync
  for (const fixture of fixtures) {
    const hash = computeFixtureHash(fixture)
    const entry: Omit<RecordingEntry, "recordedAt"> = {
      hash,
      prompt: fixture.prompt,
      provider: "test-fixture",
      streamData: buildStreamEvents(fixture),
      result: buildResult(fixture)
    }
    Effect.runSync(recorder.save(entry))
  }

  return recorder
}

// ─────────────────────────────────────────────────────────────────
// Test Runtime Layer (Playback Mode)
// ─────────────────────────────────────────────────────────────────

/**
 * Options for creating a test runtime layer with playback.
 */
export interface TestRuntimeOptions {
  /** Fixtures to pre-seed into the recorder */
  readonly fixtures: ReadonlyArray<SimpleFixture>
  /** Model name to register a dummy provider under (defaults to "claude-sonnet-4-5") */
  readonly modelName?: string
  /** Additional model names to register */
  readonly additionalModels?: ReadonlyArray<string>
}

/**
 * A dummy provider that should never be called in playback mode.
 * If it IS called, it means the recording lookup failed.
 */
const playbackDummyProvider: AgentProvider = {
  name: "playback-dummy",
  stream: () => {
    throw new Error(
      "playbackDummyProvider.stream() was called. " +
        "This means a recording was not found for a request. " +
        "Ensure all fixtures are seeded with correct prompts and schemas."
    )
  }
}

/**
 * Create a complete test runtime layer using ProviderRecorder playback.
 *
 * This provides all the services needed to run workflows in tests:
 * - ProviderRegistry with a dummy provider (never called in playback)
 * - ProviderModeContext set to "playback"
 * - ProviderRecorder pre-seeded with fixtures
 * - EventStore (in-memory)
 * - EventBus (in-memory)
 */
export const createTestRuntimeLayer = (options: TestRuntimeOptions) => {
  const { additionalModels = [], fixtures, modelName = "claude-sonnet-4-5" } = options

  // Seed the recorder with fixtures
  const recorder = seedRecorder(fixtures)

  // Build registry with dummy provider for all models
  const registryService = makeInMemoryProviderRegistry()
  const allModels = [modelName, ...additionalModels]

  const ProviderRegistryLayer = Layer.effect(
    ProviderRegistry,
    Effect.gen(function*() {
      for (const model of allModels) {
        yield* registryService.registerProvider(model, playbackDummyProvider)
      }
      return registryService
    })
  )

  const ProviderModeLayer = Layer.succeed(ProviderModeContext, { mode: "playback" as const })

  const ProviderRecorderLayer = Layer.succeed(ProviderRecorder, recorder)

  const EventStoreLayer = InMemoryEventStore

  const EventBusLayer = InMemoryEventBus

  return Layer.mergeAll(
    ProviderRegistryLayer,
    ProviderModeLayer,
    ProviderRecorderLayer,
    EventStoreLayer,
    EventBusLayer
  )
}

/**
 * Run an Effect with test runtime services using ProviderRecorder playback.
 *
 * Convenience wrapper for tests that need to run Effects with recorded fixtures.
 */
export const runWithTestRuntime = <A>(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  effect: Effect.Effect<A, any, any>,
  options: TestRuntimeOptions
): Promise<A> => {
  const layer = createTestRuntimeLayer(options)
  const provided = effect.pipe(Effect.provide(layer))
  return Effect.runPromise(provided as Effect.Effect<A, never, never>)
}
