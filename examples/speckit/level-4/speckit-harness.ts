import { createWorkflow, ClaudeHarness, MemorySignalStore } from "@open-harness/core";
import type { Task } from "./spec-agent";
import type { ValidationResult } from "./coding-agent";

/**
 * SpecKit Harness - Level 4
 *
 * Coordinates Spec Agent and Coding Agent in a reactive workflow:
 * 1. Spec Agent: PRD → tasks (activates on harness:start)
 * 2. Coding Agent: tasks → code (activates on spec:complete)
 *
 * This level demonstrates:
 * - Multi-agent coordination via signal chaining
 * - Shared state accessible to all agents
 * - activateOn/emits for control flow (replaces edges)
 *
 * v0.3.0 Reactive Pattern:
 * - Old: edges: [{ from: "spec", to: "coder" }]
 * - New: spec emits: ["spec:complete"], coder activateOn: ["spec:complete"]
 */

// =============================================================================
// 1. State Types
// =============================================================================

export interface CoderOutput {
	taskId: string;
	code: string;
	selfValidation: ValidationResult;
	status: "complete" | "needs_revision" | "blocked";
}

export interface SpecKitState {
	/** Input PRD prompt */
	prompt: string;
	/** Tasks generated by spec agent */
	tasks: Task[];
	/** Current task being processed */
	currentTaskIndex: number;
	/** Iteration tracking */
	currentAttempts: number;
	maxAttempts: number;
	/** Spec agent output (raw) */
	specOutput: string | null;
	/** Coder output (raw) */
	coderOutput: string | null;
	/** Metrics */
	metrics: {
		tasksCompleted: number;
		tasksFailed: number;
		totalAttempts: number;
	};
}

export const initialState: SpecKitState = {
	prompt: "",
	tasks: [],
	currentTaskIndex: 0,
	currentAttempts: 0,
	maxAttempts: 3,
	specOutput: null,
	coderOutput: null,
	metrics: {
		tasksCompleted: 0,
		tasksFailed: 0,
		totalAttempts: 0,
	},
};

// =============================================================================
// 2. Create Typed Harness Factory
// =============================================================================

const { agent, runReactive } = createWorkflow<SpecKitState>();

// =============================================================================
// 3. Define Reactive Agents
// =============================================================================

/**
 * Spec Agent - Breaks down PRD into tasks
 * Activates on harness:start, emits spec:complete
 */
export const specAgent = agent({
	prompt: `You are a specification agent that analyzes PRDs (Product Requirements Documents).

Your job is to break down a PRD into clear, actionable implementation tasks.

PRD:
{{ state.prompt }}

For each task, provide:
1. A unique ID (TASK-001, TASK-002, etc.)
2. A concise title
3. A detailed description of what needs to be done
4. Priority (1-5, where 1 is highest)
5. Complexity estimate (simple, medium, complex)
6. Clear acceptance criteria (what must be true when done)

Your response MUST follow this format:

## TASKS

### TASK-001: [Title]
**Priority:** [1-5]
**Complexity:** [simple|medium|complex]
**Description:** [What needs to be done]
**Acceptance Criteria:**
- [Criterion 1]
- [Criterion 2]

### TASK-002: [Title]
...

## SUMMARY
Total tasks: [N]
By priority: [breakdown]
By complexity: [breakdown]

## STATUS
COMPLETE or NEEDS_MORE_CONTEXT

Important guidelines:
- Each task should be independently implementable
- Order tasks by dependency (prerequisites first)
- Be specific - vague tasks are useless
- Don't create too many tiny tasks - group related work`,

	activateOn: ["workflow:start"],
	emits: ["spec:complete"],
	updates: "specOutput",
});

/**
 * Coding Agent - Implements tasks with self-validation
 * Activates on spec:complete, emits code:complete
 */
export const codingAgent = agent({
	prompt: `You are a coding agent that implements tasks from a specification.

The spec agent produced this output:
{{ state.specOutput }}

Your job is to:
1. Implement the first task from the spec
2. Validate your implementation against all acceptance criteria
3. Be honest about any issues

Your response MUST include these sections:

## TASK_ID
[The ID of the task you're implementing]

## CODE
\`\`\`
[Your implementation here]
\`\`\`

## VALIDATION
Check each acceptance criterion:
- [Criterion]: PASS or FAIL - [explanation]

## ISSUES (if any)
- [List specific problems]
- [Suggest fixes]

## STATUS
One of:
- COMPLETE: All acceptance criteria met
- NEEDS_REVISION: Some criteria not met, can fix with another attempt
- BLOCKED: Cannot complete (e.g., missing information)

Be thorough in your validation. Missing a criterion is worse than admitting a failure.`,

	activateOn: ["spec:complete"],
	emits: ["code:complete"],
	updates: "coderOutput",
});

// =============================================================================
// 4. Runner Function
// =============================================================================

const harness = new ClaudeHarness({
	model: "claude-sonnet-4-20250514",
});

export type RecordingMode = "record" | "replay";

export interface RunOptions {
	fixture?: string;
	mode?: RecordingMode;
	store?: MemorySignalStore;
}

/**
 * Run the SpecKit harness with a PRD prompt.
 */
export async function runSpecKit(prompt: string, options: RunOptions = {}) {
	const result = await runReactive({
		agents: { spec: specAgent, coder: codingAgent },
		state: {
			...initialState,
			prompt,
		},
		harness,
		recording: options.fixture
			? {
					mode: options.mode ?? "replay",
					store: options.store,
					name: options.fixture,
				}
			: undefined,
		endWhen: (state) => state.coderOutput !== null,
	});

	// Extract text outputs
	const specOutputRaw = result.state.specOutput as { content?: string } | string | null;
	const coderOutputRaw = result.state.coderOutput as { content?: string } | string | null;

	const specOutput = typeof specOutputRaw === "string" ? specOutputRaw : specOutputRaw?.content ?? "";
	const coderOutput = typeof coderOutputRaw === "string" ? coderOutputRaw : coderOutputRaw?.content ?? "";

	return {
		output: coderOutput, // Final output is from coder
		specOutput,
		coderOutput,
		state: result.state,
		metrics: {
			latencyMs: result.metrics.durationMs,
			activations: result.metrics.activations,
		},
		signals: result.signals,
	};
}
