import { createHarness, ClaudeProvider, MemorySignalStore } from "@open-harness/core";
import type { Task } from "./spec-agent";
import type { ValidationResult } from "./coding-agent";
import type { ReviewIssue, CriterionResult } from "./reviewer-agent";

/**
 * SpecKit Harness - Level 5 (Full 3-Agent System)
 *
 * Complete workflow with signal-based coordination:
 * 1. Spec Agent: PRD → tasks (activates on harness:start)
 * 2. Coding Agent: tasks → code (activates on spec:complete)
 * 3. Reviewer Agent: code → approval (activates on code:complete)
 *
 * This level demonstrates:
 * - Three-agent coordination via signal chaining
 * - Shared state accessible to all agents
 * - activateOn/emits for control flow (replaces edges)
 *
 * v0.3.0 Reactive Pattern:
 * - Old: edges: [{ from: "spec", to: "coder" }, { from: "coder", to: "reviewer" }]
 * - New: Signal chaining with activateOn/emits
 */

// =============================================================================
// 1. State Types
// =============================================================================

export interface CoderOutput {
	taskId: string;
	code: string;
	selfValidation: ValidationResult;
	status: "complete" | "needs_revision" | "blocked";
}

export interface ReviewerOutput {
	taskId: string;
	approved: boolean;
	criteriaResults: CriterionResult[];
	issues: ReviewIssue[];
}

export interface SpecKitState {
	/** Input PRD prompt */
	prompt: string;
	/** Tasks generated by spec agent */
	tasks: Task[];
	/** Current task being processed */
	currentTaskIndex: number;
	/** Spec agent output (raw) */
	specOutput: string | null;
	/** Coder output (raw) */
	coderOutput: string | null;
	/** Reviewer output (raw) */
	reviewerOutput: string | null;
	/** Metrics */
	metrics: {
		tasksCompleted: number;
		tasksFailed: number;
		reviewsCompleted: number;
		totalAttempts: number;
	};
}

export const initialState: SpecKitState = {
	prompt: "",
	tasks: [],
	currentTaskIndex: 0,
	specOutput: null,
	coderOutput: null,
	reviewerOutput: null,
	metrics: {
		tasksCompleted: 0,
		tasksFailed: 0,
		reviewsCompleted: 0,
		totalAttempts: 0,
	},
};

// =============================================================================
// 2. Create Typed Harness Factory
// =============================================================================

const { agent, runReactive } = createHarness<SpecKitState>();

// =============================================================================
// 3. Define Reactive Agents
// =============================================================================

/**
 * Spec Agent - Breaks down PRD into tasks
 * Activates on harness:start, emits spec:complete
 */
export const specAgent = agent({
	prompt: `You are a specification agent that analyzes PRDs (Product Requirements Documents).

Your job is to break down a PRD into clear, actionable implementation tasks.

PRD:
{{ state.prompt }}

For each task, provide:
1. A unique ID (TASK-001, TASK-002, etc.)
2. A concise title
3. A detailed description of what needs to be done
4. Priority (1-5, where 1 is highest)
5. Complexity estimate (simple, medium, complex)
6. Clear acceptance criteria (what must be true when done)

Your response MUST follow this format:

## TASKS

### TASK-001: [Title]
**Priority:** [1-5]
**Complexity:** [simple|medium|complex]
**Description:** [What needs to be done]
**Acceptance Criteria:**
- [Criterion 1]
- [Criterion 2]

### TASK-002: [Title]
...

## SUMMARY
Total tasks: [N]
By priority: [breakdown]
By complexity: [breakdown]

## STATUS
COMPLETE or NEEDS_MORE_CONTEXT

Important guidelines:
- Each task should be independently implementable
- Order tasks by dependency (prerequisites first)
- Be specific - vague tasks are useless
- Don't create too many tiny tasks - group related work`,

	activateOn: ["harness:start"],
	emits: ["spec:complete"],
	updates: "specOutput",
});

/**
 * Coding Agent - Implements tasks with self-validation
 * Activates on spec:complete, emits code:complete
 */
export const codingAgent = agent({
	prompt: `You are a coding agent that implements tasks from a specification.

The spec agent produced this output:
{{ state.specOutput }}

Your job is to:
1. Implement the first task from the spec
2. Validate your implementation against all acceptance criteria
3. Be honest about any issues

Your response MUST include these sections:

## TASK_ID
[The ID of the task you're implementing]

## CODE
\`\`\`
[Your implementation here]
\`\`\`

## VALIDATION
Check each acceptance criterion:
- [Criterion]: PASS or FAIL - [explanation]

## ISSUES (if any)
- [List specific problems]
- [Suggest fixes]

## STATUS
One of:
- COMPLETE: All acceptance criteria met
- NEEDS_REVISION: Some criteria not met, can fix with another attempt
- BLOCKED: Cannot complete (e.g., missing information)

Be thorough in your validation. Missing a criterion is worse than admitting a failure.`,

	activateOn: ["spec:complete"],
	emits: ["code:complete"],
	updates: "coderOutput",
});

/**
 * Reviewer Agent - Validates code against specifications
 * Activates on code:complete, emits review:complete
 */
export const reviewerAgent = agent({
	prompt: `You are a code reviewer agent that validates implementations against specifications.

The spec agent produced this task list:
{{ state.specOutput }}

The coding agent produced this implementation:
{{ state.coderOutput }}

Your job is to:
1. Check each acceptance criterion - is it truly met by the code?
2. Look for common issues (TODOs, incomplete sections, bugs)
3. Verify code quality and best practices
4. Provide constructive feedback

Your response MUST include these sections:

## TASK_ID
[The ID of the task being reviewed]

## CRITERIA VERIFICATION
For each acceptance criterion:
- [Criterion text]: MET or NOT_MET - [explanation]

## ISSUES
List any problems found:
- **[blocker|major|minor]**: [Description] → [Suggestion]

Issue severity guide:
- blocker: Completely broken, must fix before approval
- major: Significant problem, should fix
- minor: Small improvement, nice to have

## SUMMARY
[1-2 sentences summarizing the review]

## VERDICT
One of:
- APPROVED: All criteria met, no blockers
- REJECTED: Has blockers or multiple unmet criteria

Be thorough but fair. Don't reject for minor issues if core functionality works.`,

	activateOn: ["code:complete"],
	emits: ["review:complete"],
	updates: "reviewerOutput",
});

// =============================================================================
// 4. Runner Function
// =============================================================================

const provider = new ClaudeProvider({
	model: "claude-sonnet-4-20250514",
});

export type RecordingMode = "record" | "replay";

export interface RunOptions {
	fixture?: string;
	mode?: RecordingMode;
	store?: MemorySignalStore;
}

/**
 * Run the full SpecKit harness with a PRD prompt.
 * Executes: spec → coder → reviewer workflow via signal chaining.
 */
export async function runSpecKit(prompt: string, options: RunOptions = {}) {
	const result = await runReactive({
		agents: { spec: specAgent, coder: codingAgent, reviewer: reviewerAgent },
		state: {
			...initialState,
			prompt,
		},
		provider,
		recording: options.fixture
			? {
					mode: options.mode ?? "replay",
					store: options.store,
					name: options.fixture,
				}
			: undefined,
		endWhen: (state) => state.reviewerOutput !== null,
	});

	// Extract text outputs
	const extractText = (raw: { content?: string } | string | null): string => {
		if (typeof raw === "string") return raw;
		return raw?.content ?? "";
	};

	const specOutput = extractText(result.state.specOutput as { content?: string } | string | null);
	const coderOutput = extractText(result.state.coderOutput as { content?: string } | string | null);
	const reviewerOutput = extractText(result.state.reviewerOutput as { content?: string } | string | null);

	return {
		output: reviewerOutput, // Final output is from reviewer
		specOutput,
		coderOutput,
		reviewerOutput,
		state: result.state,
		metrics: {
			latencyMs: result.metrics.durationMs,
			activations: result.metrics.activations,
		},
		signals: result.signals,
	};
}

// Re-export types for consumers
export type { Task, ValidationResult, ReviewIssue, CriterionResult };
