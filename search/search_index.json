{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Open Harness","text":"<p>Build AI workflows you can test like software.</p> <p>Open Harness is a TypeScript framework for building, testing, and debugging agentic AI workflows. Define agents with typed outputs, compose them into phases, and run deterministic tests without making API calls.</p> <ul> <li> <p> Get Started in 5 Minutes</p> <p>Install Open Harness and run your first AI workflow with typed outputs and full observability.</p> <p> Getting Started</p> </li> <li> <p> Core Concepts</p> <p>Learn about events, agents, phases, and workflows\u2014the building blocks of every Open Harness application.</p> <p> Concepts</p> </li> <li> <p> API Reference</p> <p>Detailed documentation for all packages: core, server, client, and testing.</p> <p> API Reference</p> </li> <li> <p> React Integration</p> <p>18 hooks for building real-time AI interfaces with streaming, state management, and human-in-the-loop.</p> <p> React Guide</p> </li> </ul>"},{"location":"#why-open-harness","title":"Why Open Harness?","text":"<p>AI workflows are notoriously hard to test. Every run is different. Costs add up during development. CI pipelines can't rely on non-deterministic API calls. When something breaks in production, you can't reproduce it.</p> <p>Open Harness solves this with VCR-style recording:</p> Mode What Happens Live Real API calls are made and responses are recorded Playback Recorded responses are replayed exactly\u2014no API calls, no costs <p>This means you can develop against real APIs, then run tests in CI with perfect reproducibility.</p>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>bun add @open-harness/core @open-harness/server\n</code></pre>"},{"location":"#define-your-first-workflow","title":"Define Your First Workflow","text":"<pre><code>import { agent, workflow, phase, run } from \"@open-harness/core\"\nimport { AnthropicProvider } from \"@open-harness/server\"\nimport { z } from \"zod\"\n\n// 1. Define an agent with typed output\nconst researcher = agent({\n  name: \"researcher\",\n  provider: AnthropicProvider({ model: \"claude-sonnet-4-5\" }),\n  output: z.object({ findings: z.array(z.string()) }),\n  prompt: (state) =&gt; `Research: ${state.topic}`,\n  update: (output, draft) =&gt; { draft.findings = output.findings }\n})\n\n// 2. Compose into a workflow\nconst researchFlow = workflow({\n  name: \"research-flow\",\n  initialState: { topic: \"\", findings: [] as string[] },\n  start: (input: string, draft) =&gt; { draft.topic = input },\n  phases: {\n    research: { run: researcher, next: \"done\" },\n    done: phase.terminal()\n  }\n})\n\n// 3. Run with full observability\nconst execution = await run(researchFlow, {\n  input: \"quantum computing\",\n  mode: \"live\"\n})\n\nexecution.subscribe({\n  onStateChanged: (state) =&gt; console.log(\"State:\", state),\n  onTextDelta: ({ delta }) =&gt; process.stdout.write(delta),\n  onAgentCompleted: ({ agent, durationMs }) =&gt; {\n    console.log(`${agent} finished in ${durationMs}ms`)\n  }\n})\n</code></pre>"},{"location":"#features","title":"Features","text":""},{"location":"#deterministic-testing","title":"Deterministic Testing","text":"<p>Record API responses once, replay them forever. Your tests run in milliseconds, cost nothing, and produce identical results every time.</p> <pre><code>// In tests, switch to playback mode\nconst execution = await run(researchFlow, {\n  input: \"quantum computing\",\n  mode: \"playback\"  // No API calls, uses recorded responses\n})\n</code></pre>"},{"location":"#event-sourced-state","title":"Event-Sourced State","text":"<p>Every action is recorded as an immutable event. Time-travel through your workflow, fork sessions, and debug with complete history.</p>"},{"location":"#human-in-the-loop","title":"Human-in-the-Loop","text":"<p>Pause workflows for human approval, inject corrections, and resume execution\u2014all with full type safety.</p>"},{"location":"#react-ready","title":"React Ready","text":"<p>18 purpose-built hooks for streaming responses, state synchronization, and building real-time AI interfaces.</p>"},{"location":"#packages","title":"Packages","text":"Package Description <code>@open-harness/core</code> Agents, phases, workflows, and execution runtime <code>@open-harness/server</code> HTTP/SSE server, AI providers (Anthropic, OpenAI) <code>@open-harness/client</code> HTTP client + React hooks <code>@open-harness/testing</code> Shared recordings database for deterministic tests"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li> <p> Run Your First Workflow</p> <p>Follow our step-by-step guide to build and run a complete AI workflow.</p> <p> Getting Started</p> </li> <li> <p> Understand the Architecture</p> <p>Learn how events, agents, phases, and workflows work together.</p> <p> Concepts</p> </li> </ul> <p>Open Harness is open source under the MIT License.</p> <p> View on GitHub</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Run your first AI workflow in 5 minutes.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure you have:</p> <ul> <li>Node.js 20+ or Bun 1.2+</li> <li>bun package manager (recommended) or npm/yarn</li> <li>An Anthropic API key (get one at console.anthropic.com)</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Install the core packages:</p> <pre><code>bun add @open-harness/core @open-harness/server zod\n</code></pre> <p>Why Zod?</p> <p>Open Harness uses Zod for runtime schema validation. Every agent must define its output schema with Zod to ensure type-safe, validated responses from AI models.</p>"},{"location":"getting-started/#your-first-workflow","title":"Your First Workflow","text":"<p>Let's build a simple workflow that takes a topic and generates a haiku about it. We'll go step by step.</p>"},{"location":"getting-started/#step-1-define-an-agent","title":"Step 1: Define an Agent","text":"<p>An agent is a single AI call with a specific job. Create a file called <code>haiku.ts</code>:</p> <pre><code>// haiku.ts\nimport { agent, workflow, phase, run } from \"@open-harness/core\"\nimport { AnthropicProvider } from \"@open-harness/server\"\nimport { z } from \"zod\"\n\n// Define the agent\nconst poet = agent({\n  name: \"poet\",\n\n  // The AI model to use\n  provider: AnthropicProvider({ model: \"claude-sonnet-4-5\" }),\n\n  // The expected output structure (validated by Zod)\n  output: z.object({\n    haiku: z.string().describe(\"A haiku poem (5-7-5 syllables)\")\n  }),\n\n  // Generate the prompt from current state\n  prompt: (state) =&gt; `Write a haiku about: ${state.topic}`,\n\n  // Update state with the agent's output\n  update: (output, draft) =&gt; {\n    draft.haiku = output.haiku\n  }\n})\n</code></pre> <p>What's happening here:</p> <ul> <li><code>name</code> \u2014 Unique identifier for debugging and logging</li> <li><code>provider</code> \u2014 The AI provider configuration (Anthropic Claude in this case)</li> <li><code>output</code> \u2014 Zod schema defining the expected structured output</li> <li><code>prompt</code> \u2014 Function that reads state and returns the prompt string</li> <li><code>update</code> \u2014 Function that writes the agent's output to state (uses Immer drafts, so you can mutate directly)</li> </ul>"},{"location":"getting-started/#step-2-define-the-workflow","title":"Step 2: Define the Workflow","text":"<p>Add a workflow that uses your agent:</p> <pre><code>// Continue in haiku.ts\n\n// Define the workflow\nconst haikuWorkflow = workflow({\n  name: \"haiku-generator\",\n\n  // Initial state shape and defaults\n  initialState: {\n    topic: \"\",\n    haiku: \"\"\n  },\n\n  // How to apply input to initial state\n  start: (input: string, draft) =&gt; {\n    draft.topic = input\n  },\n\n  // The execution phases\n  phases: {\n    // \"compose\" phase runs the poet agent, then goes to \"done\"\n    compose: { run: poet, next: \"done\" },\n\n    // \"done\" is a terminal phase - workflow is complete\n    done: phase.terminal()\n  }\n})\n</code></pre> <p>What's happening here:</p> <ul> <li><code>initialState</code> \u2014 The starting shape of your workflow's state</li> <li><code>start</code> \u2014 A function that takes input and mutates the initial state</li> <li><code>phases</code> \u2014 An explicit state machine defining execution order</li> </ul>"},{"location":"getting-started/#step-3-run-the-workflow","title":"Step 3: Run the Workflow","text":"<p>Add the execution code:</p> <pre><code>// Continue in haiku.ts\n\n// Set your API key\nprocess.env.ANTHROPIC_API_KEY = \"your-api-key-here\"\n\n// Run the workflow\nconst execution = await run(haikuWorkflow, {\n  input: \"morning coffee\",\n  mode: \"live\"\n})\n\n// Subscribe to events\nexecution.subscribe({\n  // Called as tokens stream in\n  onTextDelta: ({ delta }) =&gt; {\n    process.stdout.write(delta)\n  },\n\n  // Called when the workflow completes\n  onCompleted: ({ state }) =&gt; {\n    console.log(\"\\n\\n\u2713 Haiku generated!\")\n    console.log(`Topic: ${state.topic}`)\n    console.log(`Haiku: ${state.haiku}`)\n  }\n})\n</code></pre>"},{"location":"getting-started/#step-4-run-it","title":"Step 4: Run It","text":"<p>Execute your workflow:</p> <pre><code>bun run haiku.ts\n</code></pre> <p>You should see the AI thinking token-by-token, followed by the final haiku:</p> <pre><code>Steam rises slowly...\nDark brew awakens the soul...\nFirst sip, day begins\n\n\u2713 Haiku generated!\nTopic: morning coffee\nHaiku: Steam rises slowly / Dark brew awakens the soul / First sip, day begins\n</code></pre>"},{"location":"getting-started/#complete-example","title":"Complete Example","text":"<p>Here's the full working code in one file:</p> <pre><code>// haiku.ts\nimport { agent, workflow, phase, run } from \"@open-harness/core\"\nimport { AnthropicProvider } from \"@open-harness/server\"\nimport { z } from \"zod\"\n\n// 1. Define the agent\nconst poet = agent({\n  name: \"poet\",\n  provider: AnthropicProvider({ model: \"claude-sonnet-4-5\" }),\n  output: z.object({\n    haiku: z.string().describe(\"A haiku poem (5-7-5 syllables)\")\n  }),\n  prompt: (state) =&gt; `Write a haiku about: ${state.topic}`,\n  update: (output, draft) =&gt; {\n    draft.haiku = output.haiku\n  }\n})\n\n// 2. Define the workflow\nconst haikuWorkflow = workflow({\n  name: \"haiku-generator\",\n  initialState: { topic: \"\", haiku: \"\" },\n  start: (input: string, draft) =&gt; { draft.topic = input },\n  phases: {\n    compose: { run: poet, next: \"done\" },\n    done: phase.terminal()\n  }\n})\n\n// 3. Run it\nconst execution = await run(haikuWorkflow, {\n  input: \"morning coffee\",\n  mode: \"live\"\n})\n\nexecution.subscribe({\n  onTextDelta: ({ delta }) =&gt; process.stdout.write(delta),\n  onCompleted: ({ state }) =&gt; {\n    console.log(\"\\n\\n\u2713 Done!\")\n    console.log(\"Haiku:\", state.haiku)\n  }\n})\n</code></pre>"},{"location":"getting-started/#add-react-optional","title":"Add React (Optional)","text":"<p>Want to build a UI? Install the client package:</p> <pre><code>bun add @open-harness/client\n</code></pre> <p>Then create a React component:</p> <pre><code>// App.tsx\nimport {\n  WorkflowClientProvider,\n  useWorkflow\n} from \"@open-harness/client\"\n\nfunction App() {\n  return (\n    &lt;WorkflowClientProvider url=\"http://localhost:42069\"&gt;\n      &lt;HaikuGenerator /&gt;\n    &lt;/WorkflowClientProvider&gt;\n  )\n}\n\nfunction HaikuGenerator() {\n  const {\n    state,           // Current workflow state\n    status,          // 'idle' | 'running' | 'completed' | 'error'\n    textStream,      // Streaming text from the AI\n    actions          // { start, pause, resume, fork }\n  } = useWorkflow&lt;{ topic: string; haiku: string }&gt;()\n\n  return (\n    &lt;div&gt;\n      &lt;button\n        onClick={() =&gt; actions.start(\"autumn leaves\")}\n        disabled={status === 'running'}\n      &gt;\n        Generate Haiku\n      &lt;/button&gt;\n\n      {/* Show streaming output */}\n      {textStream &amp;&amp; &lt;pre&gt;{textStream}&lt;/pre&gt;}\n\n      {/* Show final result */}\n      {state?.haiku &amp;&amp; (\n        &lt;blockquote&gt;{state.haiku}&lt;/blockquote&gt;\n      )}\n    &lt;/div&gt;\n  )\n}\n</code></pre> <p>Server Required</p> <p>The React client connects to a running Open Harness server. You'll need to set up the server package to expose your workflow via HTTP/SSE. See the React Integration Guide for the full setup.</p>"},{"location":"getting-started/#what-just-happened","title":"What Just Happened?","text":"<p>Let's trace through the execution:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  1. INPUT RECEIVED                                           \u2502\n\u2502     \"morning coffee\" \u2192 start() \u2192 state.topic = \"morning...\"  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  2. PHASE: compose                                           \u2502\n\u2502     poet agent activated                                     \u2502\n\u2502     prompt: \"Write a haiku about: morning coffee\"           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  3. AI CALL (streaming)                                      \u2502\n\u2502     Claude generates haiku token-by-token                    \u2502\n\u2502     Output validated against Zod schema                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  4. STATE UPDATE                                             \u2502\n\u2502     update(output, draft) \u2192 draft.haiku = \"Steam rises...\"  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  5. PHASE TRANSITION                                         \u2502\n\u2502     compose \u2192 done (terminal)                               \u2502\n\u2502     Workflow complete!                                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Key concepts demonstrated:</p> Concept What You Saw Agent <code>poet</code> \u2014 a single AI call with typed output Workflow <code>haikuWorkflow</code> \u2014 combines state, input handling, and phases Phase <code>compose</code> \u2192 <code>done</code> \u2014 explicit execution order Streaming <code>onTextDelta</code> \u2014 real-time token output State Immutable updates via Immer drafts"},{"location":"getting-started/#modes-live-vs-playback","title":"Modes: Live vs Playback","text":"<p>Open Harness has two execution modes:</p> Mode Behavior Use Case <code>live</code> Makes real API calls, records responses Development, production <code>playback</code> Replays recorded responses, no API calls Testing, CI <pre><code>// Live mode (default) - calls the real API\nawait run(workflow, { input: \"...\", mode: \"live\" })\n\n// Playback mode - uses recorded responses\nawait run(workflow, { input: \"...\", mode: \"playback\" })\n</code></pre> <p>This enables deterministic testing of AI workflows. Record once during development, replay forever in CI. No flaky tests, no API costs.</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you've run your first workflow, explore further:</p> <ul> <li> <p> Understand the Concepts</p> <p>Learn about events, agents, phases, and workflows\u2014the core building blocks.</p> <p> Core Concepts</p> </li> <li> <p> Build Complex Workflows</p> <p>Multi-phase workflows, loops, branches, and human-in-the-loop patterns.</p> <p> Building Workflows</p> </li> <li> <p> Add a React UI</p> <p>18 hooks for streaming, state management, and real-time AI interfaces.</p> <p> React Integration</p> </li> <li> <p> Write Tests</p> </li> </ul>"},{"location":"getting-started/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/#api-key-not-found","title":"API Key Not Found","text":"<pre><code>Error: ANTHROPIC_API_KEY environment variable is required\n</code></pre> <p>Solution: Set your API key:</p> <pre><code>export ANTHROPIC_API_KEY=\"sk-ant-...\"\n</code></pre> <p>Or in your code (not recommended for production):</p> <pre><code>process.env.ANTHROPIC_API_KEY = \"sk-ant-...\"\n</code></pre>"},{"location":"getting-started/#schema-validation-failed","title":"Schema Validation Failed","text":"<pre><code>Error: Output validation failed: expected string, received undefined\n</code></pre> <p>Solution: The AI didn't return the expected structure. This usually means your output schema is too strict or your prompt isn't clear enough. Add <code>.describe()</code> hints to your Zod schema fields:</p> <pre><code>output: z.object({\n  haiku: z.string().describe(\"A haiku poem with 5-7-5 syllable structure\")\n})\n</code></pre>"},{"location":"getting-started/#module-not-found","title":"Module Not Found","text":"<pre><code>Cannot find module '@open-harness/core'\n</code></pre> <p>Solution: Make sure you've installed all packages:</p> <pre><code>bun add @open-harness/core @open-harness/server zod\n</code></pre> <p>Ready to build something real?</p> <p> Core Concepts</p>"},{"location":"api/reference/","title":"API Reference","text":"<p>Complete reference for Open Harness packages.</p>"},{"location":"api/reference/#packages-overview","title":"Packages Overview","text":"Package Description <code>@open-harness/core</code> Core primitives: workflow, agent, phase, run <code>@open-harness/server</code> Server runtime and providers <code>@open-harness/client</code> React hooks for workflow integration <code>@open-harness/testing</code> Testing utilities and playback mode"},{"location":"api/reference/#open-harnesscore","title":"@open-harness/core","text":"<p>Core primitives for defining and running AI workflows.</p> <pre><code>import { agent, workflow, phase, run } from \"@open-harness/core\"\n</code></pre>"},{"location":"api/reference/#agent","title":"agent","text":"<p>Create an agent definition with validation.</p> <pre><code>function agent&lt;S, O, Ctx = void&gt;(def: AgentDef&lt;S, O, Ctx&gt;): AgentDef&lt;S, O, Ctx&gt;\n</code></pre> <p>Parameters:</p> Name Type Description <code>def.name</code> <code>string</code> Unique identifier for the agent <code>def.provider</code> <code>AgentProvider</code> Provider instance (e.g., <code>AnthropicProvider()</code>) <code>def.output</code> <code>z.ZodType&lt;O&gt;</code> Zod schema for structured output <code>def.prompt</code> <code>(state: S, ctx?: Ctx) =&gt; string</code> Function to generate prompt from state <code>def.update</code> <code>(output: O, draft: Draft&lt;S&gt;, ctx?: Ctx) =&gt; void</code> Immer-style state mutation <code>def.options?</code> <code>Record&lt;string, unknown&gt;</code> Provider-specific overrides <p>Example:</p> <pre><code>import { agent } from \"@open-harness/core\"\nimport { AnthropicProvider } from \"@open-harness/server\"\nimport { z } from \"zod\"\n\nconst planner = agent({\n  name: \"planner\",\n  provider: AnthropicProvider({ model: \"claude-sonnet-4-5\" }),\n  output: z.object({\n    tasks: z.array(z.string()),\n    priority: z.enum([\"low\", \"medium\", \"high\"])\n  }),\n  prompt: (state) =&gt; `Create tasks for: ${state.goal}`,\n  update: (output, draft) =&gt; {\n    draft.tasks = output.tasks\n    draft.priority = output.priority\n  }\n})\n</code></pre>"},{"location":"api/reference/#workflow","title":"workflow","text":"<p>Create a workflow definition. Supports two shapes: simple (single agent) or phased (state machine).</p> <pre><code>// Simple workflow (single agent)\nfunction workflow&lt;S, Input = string&gt;(\n  def: SimpleWorkflowDef&lt;S, Input&gt;\n): SimpleWorkflowDef&lt;S, Input&gt;\n\n// Phase workflow (state machine)\nfunction workflow&lt;S, Input = string, Phases extends string = string&gt;(\n  def: PhaseWorkflowDef&lt;S, Input, Phases&gt;\n): PhaseWorkflowDef&lt;S, Input, Phases&gt;\n</code></pre>"},{"location":"api/reference/#simpleworkflowdef","title":"SimpleWorkflowDef","text":"Name Type Description <code>name</code> <code>string</code> Unique workflow identifier <code>initialState</code> <code>S</code> Initial state object <code>start</code> <code>(input: Input, draft: Draft&lt;S&gt;) =&gt; void</code> Transform input into state <code>agent</code> <code>AgentDef&lt;S, any, void&gt;</code> Agent to run repeatedly <code>until?</code> <code>(state: S) =&gt; boolean</code> Exit condition (returns true to stop)"},{"location":"api/reference/#phaseworkflowdef","title":"PhaseWorkflowDef","text":"Name Type Description <code>name</code> <code>string</code> Unique workflow identifier <code>initialState</code> <code>S</code> Initial state object <code>start</code> <code>(input: Input, draft: Draft&lt;S&gt;) =&gt; void</code> Transform input into state <code>phases</code> <code>Record&lt;Phases, PhaseDef&lt;S, Phases&gt;&gt;</code> Phase definitions <code>startPhase?</code> <code>Phases</code> Override starting phase (default: first) <p>Example (Phase Workflow):</p> <pre><code>const researchWorkflow = workflow({\n  name: \"research\",\n  initialState: {\n    topic: \"\",\n    findings: [] as string[],\n    summary: \"\"\n  },\n  start: (input, draft) =&gt; {\n    draft.topic = input\n  },\n  phases: {\n    research: { run: researcher, next: \"summarize\" },\n    summarize: { run: summarizer, next: \"done\" },\n    done: phase.terminal()\n  }\n})\n</code></pre>"},{"location":"api/reference/#phase","title":"phase","text":"<p>Create a phase definition for state machine workflows.</p> <pre><code>function phase&lt;S, Phases extends string, Ctx = void&gt;(\n  def: PhaseDef&lt;S, Phases, Ctx&gt;\n): PhaseDef&lt;S, Phases, Ctx&gt;\n\n// Shorthand for terminal phases\nphase.terminal&lt;S, Phases&gt;(): PhaseDef&lt;S, Phases, void&gt;\n</code></pre>"},{"location":"api/reference/#phasedef","title":"PhaseDef","text":"Name Type Description <code>run?</code> <code>AgentDef&lt;S, any, Ctx&gt;</code> Agent to execute in this phase <code>human?</code> <code>HumanConfig&lt;S&gt;</code> Human input configuration <code>onResponse?</code> <code>(response: string, draft: Draft&lt;S&gt;) =&gt; void</code> Handle human response <code>parallel?</code> <code>number</code> Max concurrent executions (requires <code>forEach</code>) <code>forEach?</code> <code>(state: S) =&gt; ReadonlyArray&lt;Ctx&gt;</code> Generate contexts for parallel execution <code>until?</code> <code>(state: S, output?: unknown) =&gt; boolean</code> Exit condition (true to exit) <code>next?</code> <code>Phases \\| ((state: S) =&gt; Phases)</code> Next phase transition <code>terminal?</code> <code>boolean</code> Mark as terminal phase (workflow ends) <p>Example (Parallel Execution):</p> <pre><code>const working = phase&lt;State, Phases, { task: Task }&gt;({\n  run: workerAgent,\n  parallel: 5,\n  forEach: (state) =&gt; state.tasks.map(task =&gt; ({ task })),\n  until: (state) =&gt; state.tasks.every(t =&gt; t.done),\n  next: \"review\"\n})\n</code></pre>"},{"location":"api/reference/#run","title":"run","text":"<p>Execute a workflow and return a controllable execution handle.</p> <pre><code>function run&lt;S, Input, Phases extends string = never&gt;(\n  workflow: WorkflowDef&lt;S, Input, Phases&gt;,\n  options: RunOptions&lt;S, Input&gt;\n): WorkflowExecution&lt;S&gt;\n</code></pre>"},{"location":"api/reference/#runoptions","title":"RunOptions","text":"Name Type Description <code>input</code> <code>Input</code> Input for the workflow's <code>start()</code> function <code>runtime</code> <code>RuntimeConfig</code> Runtime configuration with providers and mode <code>sessionId?</code> <code>string</code> Session ID (generates UUID if not provided) <code>signal?</code> <code>AbortSignal</code> Abort signal for cancellation <code>observer?</code> <code>WorkflowObserver&lt;S&gt;</code> Lifecycle event callbacks <code>humanInput?</code> <code>HumanInputHandler</code> Handler for HITL interactions"},{"location":"api/reference/#workflowexecution","title":"WorkflowExecution","text":"<p>The returned handle implements <code>PromiseLike&lt;RunResult&lt;S&gt;&gt;</code> and provides control methods:</p> Property/Method Type Description <code>sessionId</code> <code>string</code> Session identifier <code>isPaused</code> <code>boolean</code> Whether execution is paused <code>pause()</code> <code>void</code> Pause at next yield point <code>resume()</code> <code>void</code> Resume paused execution <code>abort()</code> <code>void</code> Cancel execution <code>then()</code> <code>PromiseLike</code> Await the result"},{"location":"api/reference/#runresult","title":"RunResult","text":"Name Type Description <code>state</code> <code>S</code> Final workflow state <code>sessionId</code> <code>string</code> Session identifier <code>durationMs</code> <code>number</code> Total execution time in milliseconds <p>Example:</p> <pre><code>import { run, cliPrompt } from \"@open-harness/core\"\n\n// Simple await\nconst result = await run(myWorkflow, {\n  input: \"Build an API\",\n  runtime: { mode: \"live\" }\n})\nconsole.log(\"Final state:\", result.state)\n\n// With observer callbacks\nconst execution = run(myWorkflow, {\n  input: \"Hello\",\n  runtime: { mode: \"live\" },\n  observer: {\n    onTextDelta: ({ delta }) =&gt; process.stdout.write(delta),\n    onStateChanged: (state) =&gt; console.log(\"State:\", state),\n    onPhaseChanged: (phase) =&gt; console.log(\"Phase:\", phase)\n  },\n  humanInput: cliPrompt()\n})\n\n// Control execution\nexecution.pause()\nexecution.resume()\nconst result = await execution\n</code></pre>"},{"location":"api/reference/#hitl-helpers","title":"HITL Helpers","text":"<p>Built-in handlers for human-in-the-loop interactions.</p> <pre><code>import { cliPrompt, autoApprove } from \"@open-harness/core\"\n</code></pre>"},{"location":"api/reference/#cliprompt","title":"cliPrompt","text":"<p>Interactive terminal prompts for human input.</p> <pre><code>function cliPrompt(): HumanInputHandler\n</code></pre>"},{"location":"api/reference/#autoapprove","title":"autoApprove","text":"<p>Automatically approve all requests (for testing).</p> <pre><code>function autoApprove(response?: string): HumanInputHandler\n</code></pre>"},{"location":"api/reference/#types","title":"Types","text":"<p>Key types exported from <code>@open-harness/core</code>:</p> <pre><code>// State drafts (Immer)\ntype Draft&lt;T&gt; = /* Immer Draft type */\ntype ImmerDraft&lt;T&gt; = /* Immer Draft type */\n\n// IDs\ntype SessionId = string &amp; { readonly _brand: \"SessionId\" }\ntype WorkflowId = string &amp; { readonly _brand: \"WorkflowId\" }\ntype AgentId = string &amp; { readonly _brand: \"AgentId\" }\ntype EventId = string &amp; { readonly _brand: \"EventId\" }\n\n// Event types\ntype AnyEvent = WorkflowStartedEvent | WorkflowCompletedEvent | AgentStartedEvent | ...\n\n// Observer callbacks\ninterface WorkflowObserver&lt;S&gt; {\n  onWorkflowStarted?: (event: WorkflowStartedPayload) =&gt; void\n  onWorkflowCompleted?: (event: WorkflowCompletedPayload&lt;S&gt;) =&gt; void\n  onPhaseEntered?: (event: PhaseEnteredPayload) =&gt; void\n  onPhaseExited?: (event: PhaseExitedPayload) =&gt; void\n  onAgentStarted?: (event: AgentStartedPayload) =&gt; void\n  onAgentCompleted?: (event: AgentCompletedPayload) =&gt; void\n  onTextDelta?: (event: TextDeltaPayload) =&gt; void\n  onThinkingDelta?: (event: ThinkingDeltaPayload) =&gt; void\n  onToolCalled?: (event: ToolCalledPayload) =&gt; void\n  onToolResult?: (event: ToolResultPayload) =&gt; void\n  onInputRequested?: (event: InputRequestedPayload) =&gt; void\n  onInputReceived?: (event: InputReceivedPayload) =&gt; void\n  onStateChanged?: (state: S) =&gt; void\n}\n</code></pre>"},{"location":"api/reference/#errors","title":"Errors","text":"<p>Error classes for workflow failures:</p> <pre><code>import {\n  WorkflowAbortedError,\n  WorkflowAgentError,\n  WorkflowPhaseError,\n  WorkflowProviderError,\n  WorkflowStoreError,\n  WorkflowTimeoutError,\n  WorkflowValidationError,\n  ProviderError,\n  SessionNotFound,\n  RecordingNotFound\n} from \"@open-harness/core\"\n</code></pre>"},{"location":"api/reference/#open-harnessserver","title":"@open-harness/server","text":"<p>HTTP server runtime and AI providers.</p> <pre><code>import { OpenScaffold, AnthropicProvider } from \"@open-harness/server\"\n</code></pre>"},{"location":"api/reference/#openscaffold","title":"OpenScaffold","text":"<p>Main server class for running workflows over HTTP.</p> <pre><code>class OpenScaffold {\n  static create(config: OpenScaffoldConfig): OpenScaffold\n\n  readonly mode: ProviderMode\n  readonly database: string\n\n  createServer&lt;S&gt;(options: ServerOptions&lt;S&gt;): OpenScaffoldServer\n  listSessions(): Promise&lt;SessionInfo[]&gt;\n  getProviderRecorder(): Promise&lt;ProviderRecorderService&gt;\n  dispose(): Promise&lt;void&gt;\n}\n</code></pre>"},{"location":"api/reference/#openscaffoldconfig","title":"OpenScaffoldConfig","text":"Name Type Description <code>database</code> <code>string</code> Path to SQLite database file <code>mode</code> <code>\"live\" \\| \"playback\"</code> Provider mode (required)"},{"location":"api/reference/#serveroptions","title":"ServerOptions","text":"Name Type Description <code>workflow</code> <code>WorkflowDef&lt;S, string, string&gt;</code> Workflow to serve <code>host?</code> <code>string</code> Server host (default: <code>\"0.0.0.0\"</code>) <code>port?</code> <code>number</code> Server port (default: <code>42069</code>)"},{"location":"api/reference/#openscaffoldserver","title":"OpenScaffoldServer","text":"Method Type Description <code>port</code> <code>number</code> Server port <code>start()</code> <code>Promise&lt;void&gt;</code> Start the server <code>stop()</code> <code>Promise&lt;void&gt;</code> Stop gracefully <code>address()</code> <code>Promise&lt;{ host: string; port: number }&gt;</code> Get address <p>Example:</p> <pre><code>import { OpenScaffold } from \"@open-harness/server\"\nimport { myWorkflow } from \"./workflows\"\n\nconst scaffold = OpenScaffold.create({\n  database: \"./data/app.db\",\n  mode: \"live\"\n})\n\nconst server = scaffold.createServer({\n  workflow: myWorkflow,\n  port: 42069\n})\n\nawait server.start()\nconsole.log(`Server running on port ${server.port}`)\n\n// Cleanup\nawait scaffold.dispose()\n</code></pre>"},{"location":"api/reference/#anthropicprovider","title":"AnthropicProvider","text":"<p>Create an Anthropic Claude provider for agents.</p> <pre><code>function AnthropicProvider(config?: AnthropicProviderConfig): AgentProvider\n</code></pre>"},{"location":"api/reference/#anthropicproviderconfig","title":"AnthropicProviderConfig","text":"Name Type Default Description <code>model?</code> <code>AnthropicModel</code> <code>\"claude-haiku-4-5\"</code> Model to use <code>apiKey?</code> <code>string</code> <code>process.env.ANTHROPIC_API_KEY</code> API key override <code>extendedThinking?</code> <code>boolean</code> <code>false</code> Enable extended thinking <code>maxTokens?</code> <code>number</code> <code>4096</code> Max response tokens"},{"location":"api/reference/#anthropicmodel","title":"AnthropicModel","text":"<pre><code>type AnthropicModel =\n  | \"claude-haiku-4-5\"\n  | \"claude-sonnet-4-5\"\n  | \"claude-opus-4-5\"\n  | \"claude-haiku-4-5-20251001\"\n  | \"claude-sonnet-4-5-20250929\"\n  | \"claude-opus-4-5-20251101\"\n  | (string &amp; {})  // Custom models\n</code></pre> <p>Example:</p> <pre><code>import { AnthropicProvider } from \"@open-harness/server\"\nimport { agent } from \"@open-harness/core\"\n\nconst provider = AnthropicProvider({\n  model: \"claude-sonnet-4-5\",\n  extendedThinking: true,\n  maxTokens: 8192\n})\n\nconst myAgent = agent({\n  name: \"analyst\",\n  provider,\n  output: z.object({ analysis: z.string() }),\n  prompt: (state) =&gt; `Analyze: ${state.data}`,\n  update: (output, draft) =&gt; { draft.analysis = output.analysis }\n})\n</code></pre>"},{"location":"api/reference/#constants","title":"Constants","text":"<pre><code>import { DEFAULT_HOST, DEFAULT_PORT } from \"@open-harness/server\"\n\nDEFAULT_HOST  // \"0.0.0.0\"\nDEFAULT_PORT  // 42069\n</code></pre>"},{"location":"api/reference/#open-harnessclient","title":"@open-harness/client","text":"<p>React hooks for connecting to Open Harness workflows.</p> <pre><code>import {\n  WorkflowClientProvider,\n  useWorkflow,\n  useWorkflowData,\n  useWorkflowActions,\n  useWorkflowVCR,\n  useWorkflowHITL,\n  HttpClient\n} from \"@open-harness/client\"\n</code></pre>"},{"location":"api/reference/#workflowclientprovider","title":"WorkflowClientProvider","text":"<p>Context provider for workflow client connection.</p> <pre><code>function WorkflowClientProvider(props: WorkflowClientProviderProps): JSX.Element\n</code></pre>"},{"location":"api/reference/#workflowclientproviderprops","title":"WorkflowClientProviderProps","text":"Name Type Description <code>url</code> <code>string</code> Server URL <code>children</code> <code>ReactNode</code> Child components <p>Example:</p> <pre><code>import { WorkflowClientProvider } from \"@open-harness/client\"\n\nfunction App() {\n  return (\n    &lt;WorkflowClientProvider url=\"http://localhost:42069\"&gt;\n      &lt;MyWorkflowUI /&gt;\n    &lt;/WorkflowClientProvider&gt;\n  )\n}\n</code></pre>"},{"location":"api/reference/#useworkflow","title":"useWorkflow","text":"<p>Unified hook for all workflow operations (Tier 2 - recommended).</p> <pre><code>function useWorkflow&lt;S&gt;(sessionId: string | null): WorkflowResult&lt;S&gt;\n</code></pre>"},{"location":"api/reference/#workflowresult","title":"WorkflowResult","text":"Property Type Description <code>status</code> <code>WorkflowDataStatus</code> Connection status <code>isConnected</code> <code>boolean</code> Whether connected to session <code>events</code> <code>ReadonlyArray&lt;SerializedEvent&gt;</code> All session events <code>state</code> <code>S \\| undefined</code> Current derived state <code>position</code> <code>number</code> Current event position <code>isRunning</code> <code>boolean</code> Workflow is executing <code>isPaused</code> <code>boolean</code> Workflow is paused <code>isCompleted</code> <code>boolean</code> Workflow finished <code>pendingInteractions</code> <code>ReadonlyArray&lt;PendingInteraction&gt;</code> HITL requests <code>send</code> <code>(event: SerializedEvent) =&gt; Promise&lt;void&gt;</code> Send event <code>pause</code> <code>() =&gt; Promise&lt;PauseResult&gt;</code> Pause execution <code>resume</code> <code>() =&gt; Promise&lt;ResumeResult&gt;</code> Resume execution <code>fork</code> <code>() =&gt; Promise&lt;ForkResult&gt;</code> Fork session <code>respond</code> <code>(id: string, response: string) =&gt; Promise&lt;void&gt;</code> Respond to HITL <code>isLoading</code> <code>boolean</code> Data loading <code>isSending</code> <code>boolean</code> Sending in progress <code>isPausing</code> <code>boolean</code> Pause in progress <code>isResuming</code> <code>boolean</code> Resume in progress <code>isForking</code> <code>boolean</code> Fork in progress <code>isResponding</code> <code>boolean</code> HITL response in progress <code>error</code> <code>Error \\| null</code> Current error <p>Example:</p> <pre><code>function WorkflowView({ sessionId }: { sessionId: string }) {\n  const {\n    state,\n    events,\n    isRunning,\n    isPaused,\n    isCompleted,\n    pendingInteractions,\n    pause,\n    resume,\n    fork,\n    respond,\n    error\n  } = useWorkflow&lt;MyState&gt;(sessionId)\n\n  if (error) return &lt;ErrorDisplay error={error} /&gt;\n\n  return (\n    &lt;div&gt;\n      &lt;StateView state={state} /&gt;\n      &lt;EventLog events={events} /&gt;\n\n      {pendingInteractions.map(interaction =&gt; (\n        &lt;HITLPrompt\n          key={interaction.id}\n          interaction={interaction}\n          onRespond={(value) =&gt; respond(interaction.id, value)}\n        /&gt;\n      ))}\n\n      &lt;VCRControls\n        isPaused={isPaused}\n        onPause={pause}\n        onResume={resume}\n        onFork={fork}\n      /&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre>"},{"location":"api/reference/#useworkflowdata","title":"useWorkflowData","text":"<p>Read-only data access (Tier 1).</p> <pre><code>function useWorkflowData&lt;S&gt;(sessionId: string | null): WorkflowDataResult&lt;S&gt;\n</code></pre>"},{"location":"api/reference/#workflowdataresult","title":"WorkflowDataResult","text":"Property Type Description <code>status</code> <code>\"disconnected\" \\| \"connecting\" \\| \"connected\" \\| \"error\"</code> Status <code>events</code> <code>ReadonlyArray&lt;SerializedEvent&gt;</code> Events <code>state</code> <code>S \\| undefined</code> Derived state <code>position</code> <code>number</code> Event position <code>isLoading</code> <code>boolean</code> Loading state <code>error</code> <code>Error \\| null</code> Error if any"},{"location":"api/reference/#useworkflowactions","title":"useWorkflowActions","text":"<p>Workflow control actions (Tier 1).</p> <pre><code>function useWorkflowActions(): WorkflowActionsResult\n</code></pre>"},{"location":"api/reference/#workflowactionsresult","title":"WorkflowActionsResult","text":"Property Type Description <code>send</code> <code>(event: SerializedEvent) =&gt; Promise&lt;void&gt;</code> Send event <code>isSending</code> <code>boolean</code> Send in progress"},{"location":"api/reference/#useworkflowvcr","title":"useWorkflowVCR","text":"<p>VCR-style playback controls (Tier 1).</p> <pre><code>function useWorkflowVCR(): WorkflowVCRResult\n</code></pre>"},{"location":"api/reference/#workflowvcrresult","title":"WorkflowVCRResult","text":"Property Type Description <code>pause</code> <code>() =&gt; Promise&lt;PauseResult&gt;</code> Pause execution <code>resume</code> <code>() =&gt; Promise&lt;ResumeResult&gt;</code> Resume execution <code>fork</code> <code>() =&gt; Promise&lt;ForkResult&gt;</code> Fork session <code>isPausing</code> <code>boolean</code> Pause in progress <code>isResuming</code> <code>boolean</code> Resume in progress <code>isForking</code> <code>boolean</code> Fork in progress"},{"location":"api/reference/#useworkflowhitl","title":"useWorkflowHITL","text":"<p>Human-in-the-loop interactions (Tier 1).</p> <pre><code>function useWorkflowHITL(sessionId: string | null): WorkflowHITLResult\n</code></pre>"},{"location":"api/reference/#workflowhitlresult","title":"WorkflowHITLResult","text":"Property Type Description <code>pending</code> <code>ReadonlyArray&lt;PendingInteraction&gt;</code> Pending requests <code>respond</code> <code>(id: EventId, response: string) =&gt; Promise&lt;void&gt;</code> Send response <code>isResponding</code> <code>boolean</code> Response in progress"},{"location":"api/reference/#pendinginteraction","title":"PendingInteraction","text":"Property Type Description <code>id</code> <code>string</code> Interaction ID <code>prompt</code> <code>string</code> Display prompt <code>type</code> <code>\"approval\" \\| \"choice\"</code> Input type <code>options?</code> <code>ReadonlyArray&lt;string&gt;</code> Choice options"},{"location":"api/reference/#httpclient","title":"HttpClient","text":"<p>Low-level HTTP client for server communication.</p> <pre><code>class HttpClient implements WorkflowClient {\n  constructor(config: ClientConfig)\n\n  createSession(input: string): Promise&lt;string&gt;\n  connect(sessionId: string): Promise&lt;void&gt;\n  events(): AsyncIterable&lt;SerializedEvent&gt;\n  getState&lt;S&gt;(): Promise&lt;S&gt;\n  getStateAt&lt;S&gt;(position: number): Promise&lt;StateAtResult&lt;S&gt;&gt;\n  sendInput(event: SerializedEvent): Promise&lt;void&gt;\n  disconnect(): Promise&lt;void&gt;\n  getSession(): Promise&lt;SessionInfo&gt;\n  pause(): Promise&lt;PauseResult&gt;\n  resume(): Promise&lt;ResumeResult&gt;\n  fork(): Promise&lt;ForkResult&gt;\n  readonly status: ConnectionStatus\n}\n</code></pre>"},{"location":"api/reference/#clientconfig","title":"ClientConfig","text":"Name Type Description <code>url</code> <code>string</code> Server URL <code>sessionId?</code> <code>string</code> Initial session ID <code>headers?</code> <code>Record&lt;string, string&gt;</code> Custom headers"},{"location":"api/reference/#types_1","title":"Types","text":"<pre><code>// Connection status\ntype ConnectionStatus = \"disconnected\" | \"connecting\" | \"connected\" | \"reconnecting\" | \"error\"\n\n// Operation results\ninterface PauseResult { ok: boolean; wasPaused: boolean }\ninterface ResumeResult { ok: boolean; wasResumed: boolean }\ninterface ForkResult { sessionId: string; originalSessionId: string; eventsCopied: number }\ninterface StateAtResult&lt;S&gt; { state: S; position: number; eventsReplayed: number }\n\n// Client error\nclass ClientError extends Error {\n  readonly operation: \"connect\" | \"disconnect\" | \"send\" | \"receive\"\n  readonly cause: unknown\n}\n</code></pre>"},{"location":"api/reference/#open-harnesstesting","title":"@open-harness/testing","text":"<p>Testing utilities for deterministic workflow testing.</p> <pre><code>import { recordingsDbPath, recordingsDbUrl, getRandomPort } from \"@open-harness/testing\"\n</code></pre>"},{"location":"api/reference/#recordingsdbpath","title":"recordingsDbPath","text":"<p>Absolute path to the shared recordings database for playback testing.</p> <pre><code>const recordingsDbPath: string\n</code></pre>"},{"location":"api/reference/#recordingsdburl","title":"recordingsDbUrl","text":"<p>SQLite URL for the recordings database.</p> <pre><code>const recordingsDbUrl: string  // \"file:/path/to/recordings/test.db\"\n</code></pre>"},{"location":"api/reference/#getrandomport","title":"getRandomPort","text":"<p>Get a random high port for test servers.</p> <pre><code>function getRandomPort(): number  // 30000-40000 range\n</code></pre> <p>Example:</p> <pre><code>import { OpenScaffold } from \"@open-harness/server\"\nimport { recordingsDbUrl, getRandomPort } from \"@open-harness/testing\"\n\n// Use recordings for deterministic tests\nconst scaffold = OpenScaffold.create({\n  database: recordingsDbUrl,\n  mode: \"playback\"\n})\n\nconst server = scaffold.createServer({\n  workflow: myWorkflow,\n  port: getRandomPort()\n})\n\nawait server.start()\n// Tests run with recorded responses - no API calls\n</code></pre>"},{"location":"api/reference/#quick-links","title":"Quick Links","text":"<ul> <li>Getting Started \u2014 Install and run your first workflow</li> <li>Building Workflows \u2014 Practical workflow patterns</li> <li>React Integration \u2014 React hooks guide</li> <li>Concepts \u2014 Core concepts explained</li> </ul>"},{"location":"concepts/","title":"Core Concepts","text":"<p>The mental models that power Open Harness.</p> <p>Open Harness is built on four foundational concepts. Understanding these will help you design better workflows and debug faster when things go wrong.</p>"},{"location":"concepts/#the-big-picture","title":"The Big Picture","text":"<p>Open Harness is a state-first workflow runtime for AI agents. Instead of treating AI as a black box, it makes every step explicit and testable:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  WORKFLOW                                               \u2502\n\u2502                                                         \u2502\n\u2502  Events \u2192 State \u2192 Agent \u2192 Output \u2192 Events \u2192 State...   \u2502\n\u2502                                                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Everything that happens is recorded as an event. State is derived by replaying events. This simple insight unlocks powerful capabilities: time-travel debugging, deterministic testing, and session forking.</p>"},{"location":"concepts/#the-four-concepts","title":"The Four Concepts","text":"<ul> <li> <p> Events</p> <p>Immutable facts about what happened. State is derived from events\u2014never stored directly.</p> <p> Learn about Events</p> </li> <li> <p> Agents</p> <p>Pure functions that take state, call an LLM, and return structured output.</p> <p> Learn about Agents</p> </li> <li> <p> Phases</p> <p>Named stages that control workflow progression with explicit transitions.</p> <p> Learn about Phases</p> </li> <li> <p> Workflows</p> <p>Compositions that bring together state, phases, and agents into a runnable unit.</p> <p> Learn about Workflows</p> </li> </ul>"},{"location":"concepts/#how-they-fit-together","title":"How They Fit Together","text":"<pre><code>flowchart LR\n    subgraph Workflow\n        State --&gt; Agent\n        Agent --&gt; Output\n        Output --&gt; Events\n        Events --&gt; State\n    end\n\n    Phase1[Phase: planning] --&gt; Phase2[Phase: execution]\n    Phase2 --&gt; Phase3[Phase: review]\n    Phase3 --&gt; Terminal[Phase: done]</code></pre> <ol> <li>Workflows define the overall structure: initial state, phases, and how input is processed</li> <li>Phases are stages in the workflow, each running an agent and specifying what comes next</li> <li>Agents are the AI actors\u2014they read state, call the LLM, and produce structured output</li> <li>Events record everything that happens, making state reproducible and debuggable</li> </ol>"},{"location":"concepts/#recommended-reading-order","title":"Recommended Reading Order","text":"Order Concept Why First 1 Events Understand the foundation\u2014state is derived from events 2 Agents Learn how AI actors work as pure functions 3 Phases See how stages control workflow progression 4 Workflows Put it all together into runnable compositions"},{"location":"concepts/#quick-reference","title":"Quick Reference","text":"Concept Mental Model Key Insight Events VCR tape State is just \"where we are on the tape\" Agents Pure function <code>State \u2192 LLM \u2192 Structured Output</code> Phases State machine Explicit transitions, no hidden logic Workflows Composition Single source of truth for everything <p>Start with Events</p> <p>If you only read one page, read Events. The event-sourced architecture is the key insight that enables deterministic testing and time-travel debugging.</p>"},{"location":"concepts/agents/","title":"Agents","text":"<p>Pure functions that transform state through AI.</p> <p>Agents are the AI actors in Open Harness. Each agent is a single LLM call with typed input and output\u2014a pure function that reads state, calls a model, and returns structured data.</p>"},{"location":"concepts/agents/#agents-are-functions","title":"Agents Are Functions","text":"<p>Think of an agent as a pure function:</p> <pre><code>Input (state) \u2192 LLM \u2192 Structured Output \u2192 State Update\n</code></pre> <p>Agents have no memory between invocations. They don't maintain conversation history or accumulated context. Each call is independent, receiving the current state and producing output.</p> <pre><code>import { agent } from \"@open-harness/core\"\nimport { z } from \"zod\"\n\nconst planner = agent({\n  name: \"planner\",\n  model: \"claude-sonnet-4-5\",\n\n  // Schema for structured output (required)\n  output: z.object({\n    tasks: z.array(z.string()),\n    priority: z.enum([\"low\", \"medium\", \"high\"])\n  }),\n\n  // Generate prompt from current state\n  prompt: (state) =&gt; `Create a plan for: ${state.goal}`,\n\n  // Update state with agent output\n  update: (output, draft) =&gt; {\n    draft.tasks = output.tasks\n    draft.priority = output.priority\n  }\n})\n</code></pre>"},{"location":"concepts/agents/#the-agent-lifecycle","title":"The Agent Lifecycle","text":"<p>When an agent runs, it follows a predictable sequence:</p> <pre><code>flowchart TD\n    A[Phase activates agent] --&gt; B[Build prompt from state]\n    B --&gt; C[Call LLM with streaming]\n    C --&gt; D[Parse response with output schema]\n    D --&gt; E[Call update with output and draft]\n    E --&gt; F[Emit state:updated event]\n    F --&gt; G[Advance to next phase]</code></pre> <p>Each step is observable through events, making debugging straightforward.</p>"},{"location":"concepts/agents/#structured-output-is-required","title":"Structured Output Is Required","text":"<p>Every agent must have an <code>output</code> schema. This isn't optional\u2014it's fundamental to how Open Harness works.</p> <pre><code>// Define exactly what the agent returns\noutput: z.object({\n  analysis: z.string(),\n  confidence: z.number().min(0).max(1),\n  recommendations: z.array(z.object({\n    action: z.string(),\n    reason: z.string()\n  }))\n})\n</code></pre> <p>Why require structured output?</p> Benefit Explanation Reliability LLM output is validated against the schema Type Safety <code>update</code> receives typed data, not raw strings Determinism Output maps cleanly to state updates Testability Known shapes make assertions straightforward <p>No free-text parsing, no regex extraction, no hoping the model followed instructions. The LLM returns structured data matching your schema, or the call fails with a validation error.</p>"},{"location":"concepts/agents/#the-update-function","title":"The Update Function","text":"<p>The <code>update</code> function receives the validated output and a draft of the current state. It uses Immer semantics\u2014mutate the draft directly:</p> <pre><code>update: (output, draft) =&gt; {\n  // Direct mutation is fine\u2014Immer handles immutability\n  draft.analysis = output.analysis\n  draft.recommendations.push(...output.recommendations)\n  draft.lastUpdated = Date.now()\n}\n</code></pre> <p>The runtime:</p> <ol> <li>Creates an Immer draft from current state</li> <li>Calls your update function</li> <li>Produces an immutable update</li> <li>Emits a <code>state:updated</code> event with patches</li> </ol>"},{"location":"concepts/agents/#provider-agnostic","title":"Provider Agnostic","text":"<p>Agents work with any AI provider. You specify the model, and the runtime handles provider-specific details:</p> <pre><code>// Works with Anthropic\nconst agent1 = agent({\n  model: \"claude-sonnet-4-5\",\n  // ...\n})\n\n// Works with OpenAI\nconst agent2 = agent({\n  model: \"gpt-4o\",\n  // ...\n})\n\n// Works with any provider you configure\nconst agent3 = agent({\n  model: \"custom-model\",\n  // ...\n})\n</code></pre> <p>Provider configuration happens at runtime, not in agent definitions. This keeps agents portable and testable.</p>"},{"location":"concepts/agents/#prompt-engineering","title":"Prompt Engineering","text":"<p>The <code>prompt</code> function receives the current state and returns a string or messages array:</p> <pre><code>// Simple string prompt\nprompt: (state) =&gt; `Analyze this data: ${JSON.stringify(state.data)}`\n\n// Complex prompt with system message\nprompt: (state) =&gt; [\n  { role: \"system\", content: \"You are a data analyst.\" },\n  { role: \"user\", content: `Analyze: ${state.data}` }\n]\n</code></pre> <p>Best practices:</p> <ul> <li>Extract only what the agent needs from state</li> <li>Include examples for complex output schemas</li> <li>Be explicit about output format expectations</li> </ul>"},{"location":"concepts/agents/#agent-options","title":"Agent Options","text":"<p>Agents support additional configuration:</p> <pre><code>const researcher = agent({\n  name: \"researcher\",\n  model: \"claude-sonnet-4-5\",\n  output: researchSchema,\n  prompt: (state) =&gt; `Research: ${state.topic}`,\n  update: (output, draft) =&gt; { draft.findings = output.findings },\n\n  // Optional configuration\n  temperature: 0.7,           // Creativity (0-1)\n  maxTokens: 4096,           // Response limit\n  tools: [searchTool],       // Available tools\n  thinking: true,            // Enable extended thinking\n})\n</code></pre>"},{"location":"concepts/agents/#tools","title":"Tools","text":"<p>Agents can use tools for external capabilities:</p> <pre><code>import { tool } from \"@open-harness/core\"\n\nconst searchTool = tool({\n  name: \"search\",\n  description: \"Search the web for information\",\n  parameters: z.object({\n    query: z.string()\n  }),\n  execute: async ({ query }) =&gt; {\n    // Perform search, return results\n    return await searchWeb(query)\n  }\n})\n\nconst researcher = agent({\n  name: \"researcher\",\n  model: \"claude-sonnet-4-5\",\n  output: z.object({ summary: z.string() }),\n  prompt: (state) =&gt; `Research: ${state.topic}`,\n  update: (output, draft) =&gt; { draft.summary = output.summary },\n  tools: [searchTool]\n})\n</code></pre> <p>Tool calls are recorded as events, making them reproducible in playback mode.</p>"},{"location":"concepts/agents/#example-multi-step-agent","title":"Example: Multi-Step Agent","text":"<p>Here's a complete example of an agent that analyzes code:</p> <pre><code>const codeAnalyzer = agent({\n  name: \"code-analyzer\",\n  model: \"claude-sonnet-4-5\",\n\n  output: z.object({\n    language: z.string(),\n    complexity: z.enum([\"simple\", \"moderate\", \"complex\"]),\n    issues: z.array(z.object({\n      line: z.number(),\n      severity: z.enum([\"info\", \"warning\", \"error\"]),\n      message: z.string()\n    })),\n    suggestions: z.array(z.string())\n  }),\n\n  prompt: (state) =&gt; `\n    Analyze this code for issues and suggestions:\n\n    \\`\\`\\`${state.language}\n    ${state.code}\n    \\`\\`\\`\n\n    Focus on:\n    - Code quality issues\n    - Potential bugs\n    - Performance improvements\n  `,\n\n  update: (output, draft) =&gt; {\n    draft.analysis = {\n      language: output.language,\n      complexity: output.complexity,\n      issues: output.issues,\n      suggestions: output.suggestions,\n      analyzedAt: Date.now()\n    }\n  }\n})\n</code></pre>"},{"location":"concepts/agents/#summary","title":"Summary","text":"Aspect Description Pure Function No memory between calls, predictable behavior Structured Output Schema validation ensures type safety Immer Updates Mutate drafts directly, get immutable results Provider Agnostic Works with any AI provider Observable Every step emits events for debugging <p>Design Principle</p> <p>Keep agents focused on a single task. Complex behavior emerges from composing simple agents through phases, not from making individual agents more complex.</p>"},{"location":"concepts/agents/#next","title":"Next","text":"<p>Learn how Phases orchestrate agents into multi-step workflows.</p>"},{"location":"concepts/events/","title":"Events","text":"<p>Immutable facts that power time-travel debugging.</p> <p>Events are the foundation of Open Harness. Every action, state change, and AI response is recorded as an immutable event. This simple choice unlocks powerful capabilities.</p>"},{"location":"concepts/events/#the-vcr-tape-analogy","title":"The VCR Tape Analogy","text":"<p>Think of your workflow as a VCR tape. Events are recorded as they happen. State is just \"where we are on the tape.\"</p> <pre><code>TAPE (Events)\n\u250c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2510\n\u2502 E1 \u2502 E2 \u2502 E3 \u2502 E4 \u2502 E5 \u2502 E6 \u2502 E7 \u2502 E8 \u2502  \u2190 Events (immutable)\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2518\n                          \u25b2\n                     current position\n                          \u2502\n                     STATE (derived)\n</code></pre> <p>State is derived from events. You never store state directly. Instead, you replay events to reconstruct any point in history.</p>"},{"location":"concepts/events/#event-types","title":"Event Types","text":"<p>Events use past tense because they're facts about what happened, not commands:</p> <pre><code>// Workflow lifecycle\n\"workflow:started\"     // Workflow execution began\n\"workflow:completed\"   // Workflow finished successfully\n\"workflow:errored\"     // Workflow failed with error\n\n// Phase transitions\n\"phase:entered\"        // Entered a new phase\n\"phase:exited\"         // Left a phase\n\n// Agent lifecycle\n\"agent:started\"        // Agent began execution\n\"agent:completed\"      // Agent finished successfully\n\"agent:errored\"        // Agent failed\n\n// State changes\n\"state:updated\"        // State was modified\n\n// Streaming\n\"text:delta\"           // Incremental text from LLM\n\"thinking:delta\"       // Reasoning trace from LLM\n\n// Human-in-the-loop\n\"input:requested\"      // Waiting for human input\n\"input:received\"       // Human provided input\n</code></pre>"},{"location":"concepts/events/#why-events","title":"Why Events?","text":""},{"location":"concepts/events/#1-replay","title":"1. Replay","text":"<p>Reconstruct any past state by replaying events from the beginning:</p> <pre><code>// Get state at any point in history\nfunction replayTo(events: Event[], targetIndex: number): State {\n  let state = initialState\n  for (let i = 0; i &lt;= targetIndex; i++) {\n    state = applyEvent(state, events[i])\n  }\n  return state\n}\n</code></pre> <p>Lost your state? Replay the tape to rebuild it.</p>"},{"location":"concepts/events/#2-debug","title":"2. Debug","text":"<p>See exactly what happened, step by step. No guessing, no logs that miss context:</p> <pre><code>execution.subscribe({\n  onEvent: (event) =&gt; {\n    console.log(`[${event.type}]`, event.payload)\n  }\n})\n</code></pre> <p>Every event carries its full context, so you can trace the exact sequence of operations.</p>"},{"location":"concepts/events/#3-fork","title":"3. Fork","text":"<p>Branch from any point for \"what if\" scenarios:</p> <pre><code>flowchart LR\n    E1[Event 1] --&gt; E2[Event 2] --&gt; E3[Event 3]\n    E3 --&gt; E4[Event 4: Original path]\n    E3 --&gt; E4b[Event 4b: Fork]\n    E4b --&gt; E5b[Event 5b]</code></pre> <p>This enables:</p> <ul> <li>A/B testing different agent responses</li> <li>Debugging by replaying up to a failure, then trying alternatives</li> <li>Human-in-the-loop corrections that branch from any point</li> </ul>"},{"location":"concepts/events/#4-audit","title":"4. Audit","text":"<p>Complete, immutable history of everything that happened:</p> <pre><code>// Every event has a timestamp and context\n{\n  type: \"agent:completed\",\n  timestamp: 1706547200000,\n  payload: {\n    agent: \"researcher\",\n    output: { findings: [\"...\"] },\n    durationMs: 1234\n  }\n}\n</code></pre> <p>For compliance, debugging production issues, or understanding user behavior\u2014the event log tells the full story.</p>"},{"location":"concepts/events/#state-derivation","title":"State Derivation","text":"<p>State is never stored directly. It's computed by applying events in order:</p> <pre><code>// Events record what happened\nconst events = [\n  { type: \"workflow:started\", payload: { input: \"research AI\" } },\n  { type: \"state:updated\", payload: { topic: \"research AI\" } },\n  { type: \"agent:completed\", payload: { output: { findings: [\"...\"] } } },\n  { type: \"state:updated\", payload: { findings: [\"...\"] } }\n]\n\n// State is derived from events\nfunction deriveState(events: Event[]): State {\n  return events.reduce((state, event) =&gt; {\n    if (event.type === \"state:updated\") {\n      return { ...state, ...event.payload }\n    }\n    return state\n  }, initialState)\n}\n</code></pre> <p>This is event sourcing\u2014a pattern used in banking, gaming, and any system where history matters.</p>"},{"location":"concepts/events/#practical-implications","title":"Practical Implications","text":""},{"location":"concepts/events/#testing-becomes-deterministic","title":"Testing Becomes Deterministic","text":"<p>Record events once, replay forever:</p> <pre><code>// Live mode: real API calls, events recorded\nconst liveExecution = await run(workflow, {\n  input: \"research quantum computing\",\n  mode: \"live\"\n})\n\n// Playback mode: same events, no API calls\nconst testExecution = await run(workflow, {\n  input: \"research quantum computing\",\n  mode: \"playback\"  // Uses recorded events\n})\n</code></pre> <p>Your tests run in milliseconds, cost nothing, and produce identical results every time.</p>"},{"location":"concepts/events/#debugging-is-time-travel","title":"Debugging Is Time Travel","text":"<p>Jump to any point in history:</p> <pre><code>// Get the state right before the error\nconst stateBeforeError = replayTo(events, errorIndex - 1)\n\n// See exactly what the agent received\nconsole.log(\"Agent saw:\", stateBeforeError)\n</code></pre> <p>No more \"it worked on my machine\" or irreproducible bugs.</p>"},{"location":"concepts/events/#sessions-are-forkable","title":"Sessions Are Forkable","text":"<p>Create branches for experimentation:</p> <pre><code>// Fork from a specific point\nconst fork = await execution.forkFrom(eventIndex)\n\n// Try a different approach\nawait fork.inject({ type: \"input:received\", payload: { response: \"alternative\" } })\nawait fork.resume()\n</code></pre>"},{"location":"concepts/events/#summary","title":"Summary","text":"Capability How Events Enable It Replay Reconstruct any state by replaying events Debug Step-by-step history of everything Fork Branch from any point Audit Immutable, timestamped log Test Record once, replay forever <p>Key Insight</p> <p>Events are the source of truth. State is derived. This simple inversion enables everything else in Open Harness.</p>"},{"location":"concepts/events/#next","title":"Next","text":"<p>Now that you understand events, learn how Agents use state to produce structured output.</p>"},{"location":"concepts/phases/","title":"Phases","text":"<p>Named stages that control workflow progression.</p> <p>Phases are the stages of your workflow. Each phase runs an agent and specifies where to go next. This explicit control flow makes workflows predictable, debuggable, and easy to reason about.</p>"},{"location":"concepts/phases/#phases-are-named-stages","title":"Phases Are Named Stages","text":"<p>Every phase has a unique name and defines what happens when the workflow enters it:</p> <pre><code>import { workflow, phase } from \"@open-harness/core\"\n\nconst myWorkflow = workflow({\n  name: \"research-flow\",\n  initialState: { topic: \"\", findings: [], summary: \"\" },\n  start: (input, draft) =&gt; { draft.topic = input },\n\n  phases: {\n    research: { run: researchAgent, next: \"summarize\" },\n    summarize: { run: summaryAgent, next: \"done\" },\n    done: phase.terminal()\n  }\n})\n</code></pre> <p>This creates a clear execution path:</p> <pre><code>flowchart LR\n    research --&gt; summarize --&gt; done</code></pre>"},{"location":"concepts/phases/#phase-anatomy","title":"Phase Anatomy","text":"<p>Each phase has up to three parts:</p> <pre><code>{\n  // Required: the agent to run\n  run: myAgent,\n\n  // Required: where to go next (static or dynamic)\n  next: \"next-phase\",\n\n  // Optional: condition for entering this phase\n  when: (state) =&gt; state.needsWork\n}\n</code></pre>"},{"location":"concepts/phases/#the-run-property","title":"The <code>run</code> Property","text":"<p>Specifies which agent executes in this phase:</p> <pre><code>phases: {\n  planning: { run: plannerAgent, next: \"execution\" },\n  execution: { run: workerAgent, next: \"review\" }\n}\n</code></pre> <p>Each phase runs exactly one agent. If you need multiple agents, use multiple phases.</p>"},{"location":"concepts/phases/#the-next-property","title":"The <code>next</code> Property","text":"<p>Specifies the next phase. Can be static or dynamic:</p> <pre><code>// Static: always go to the same phase\n{ run: agent, next: \"review\" }\n\n// Dynamic: choose based on output or state\n{\n  run: agent,\n  next: (output, state) =&gt; output.needsRevision ? \"revise\" : \"done\"\n}\n</code></pre>"},{"location":"concepts/phases/#the-when-property","title":"The <code>when</code> Property","text":"<p>Optional condition for phase entry:</p> <pre><code>phases: {\n  optional: {\n    run: optionalAgent,\n    next: \"done\",\n    when: (state) =&gt; state.needsOptionalStep\n  }\n}\n</code></pre> <p>If <code>when</code> returns <code>false</code>, the phase is skipped and the workflow moves to <code>next</code>.</p>"},{"location":"concepts/phases/#phase-patterns","title":"Phase Patterns","text":""},{"location":"concepts/phases/#sequential","title":"Sequential","text":"<p>The simplest pattern\u2014phases run in order:</p> <pre><code>phases: {\n  step1: { run: agent1, next: \"step2\" },\n  step2: { run: agent2, next: \"step3\" },\n  step3: { run: agent3, next: \"done\" },\n  done: phase.terminal()\n}\n</code></pre> <pre><code>flowchart LR\n    step1 --&gt; step2 --&gt; step3 --&gt; done</code></pre>"},{"location":"concepts/phases/#loop","title":"Loop","text":"<p>Repeat until a condition is met:</p> <pre><code>phases: {\n  work: {\n    run: workerAgent,\n    next: \"review\"\n  },\n  review: {\n    run: reviewerAgent,\n    next: (output) =&gt; output.approved ? \"done\" : \"work\"\n  },\n  done: phase.terminal()\n}\n</code></pre> <pre><code>flowchart LR\n    work --&gt; review\n    review --&gt;|approved| done\n    review --&gt;|needs work| work</code></pre> <p>Prevent Infinite Loops</p> <p>Add a maximum iteration count in your state to prevent runaway loops: <pre><code>next: (output, state) =&gt; {\n  if (state.iterations &gt;= 5) return \"done\"\n  return output.approved ? \"done\" : \"work\"\n}\n</code></pre></p>"},{"location":"concepts/phases/#branch","title":"Branch","text":"<p>Different paths based on conditions:</p> <pre><code>phases: {\n  triage: {\n    run: triageAgent,\n    next: (output) =&gt; output.urgent ? \"fast\" : \"normal\"\n  },\n  fast: { run: fastAgent, next: \"done\" },\n  normal: { run: normalAgent, next: \"done\" },\n  done: phase.terminal()\n}\n</code></pre> <pre><code>flowchart LR\n    triage --&gt;|urgent| fast --&gt; done\n    triage --&gt;|normal| normal --&gt; done</code></pre>"},{"location":"concepts/phases/#parallel-merge","title":"Parallel Merge","text":"<p>Multiple paths that converge:</p> <pre><code>phases: {\n  start: { run: startAgent, next: \"pathA\" },\n\n  pathA: { run: agentA, next: \"merge\" },\n  pathB: { run: agentB, next: \"merge\" },\n\n  merge: {\n    run: mergeAgent,\n    next: \"done\",\n    when: (state) =&gt; state.pathADone &amp;&amp; state.pathBDone\n  },\n  done: phase.terminal()\n}\n</code></pre>"},{"location":"concepts/phases/#terminal-phases","title":"Terminal Phases","text":"<p>Every workflow needs at least one terminal phase\u2014a phase that ends execution:</p> <pre><code>import { phase } from \"@open-harness/core\"\n\nphases: {\n  // ... other phases ...\n  done: phase.terminal(),\n  failed: phase.terminal()  // Multiple terminals are fine\n}\n</code></pre> <p>Terminal phases:</p> <ul> <li>Run no agent</li> <li>Emit a <code>workflow:completed</code> event</li> <li>Return the final state</li> </ul>"},{"location":"concepts/phases/#dynamic-next-functions","title":"Dynamic Next Functions","text":"<p>The <code>next</code> function receives the agent output and current state:</p> <pre><code>{\n  run: reviewAgent,\n  next: (output, state) =&gt; {\n    // Access agent output\n    if (output.score &lt; 0.5) return \"revise\"\n\n    // Access current state\n    if (state.iterations &gt;= 3) return \"done\"\n\n    // Default path\n    return \"finalize\"\n  }\n}\n</code></pre> <p>This enables complex routing logic without hidden state machines.</p>"},{"location":"concepts/phases/#phase-events","title":"Phase Events","text":"<p>Phases emit events for observability:</p> <pre><code>execution.subscribe({\n  onPhaseChanged: (phase, previousPhase) =&gt; {\n    console.log(`${previousPhase} \u2192 ${phase}`)\n  }\n})\n</code></pre> <p>Events include:</p> <ul> <li><code>phase:entered</code> \u2014 Entered a new phase</li> <li><code>phase:exited</code> \u2014 Left a phase</li> </ul>"},{"location":"concepts/phases/#phase-rules","title":"Phase Rules","text":"<ol> <li>Unique names \u2014 Each phase has a distinct identifier</li> <li>One agent per phase \u2014 Each non-terminal phase runs exactly one agent</li> <li>Explicit next \u2014 Every phase specifies where to go (or is terminal)</li> <li>No orphans \u2014 Every phase must be reachable from the start phase</li> </ol>"},{"location":"concepts/phases/#example-review-loop","title":"Example: Review Loop","text":"<p>A common pattern\u2014iterate until quality is acceptable:</p> <pre><code>const reviewWorkflow = workflow({\n  name: \"review-loop\",\n  initialState: {\n    draft: \"\",\n    feedback: \"\",\n    approved: false,\n    iterations: 0\n  },\n  start: (input, draft) =&gt; { draft.draft = input },\n\n  phases: {\n    write: {\n      run: writerAgent,\n      next: \"review\"\n    },\n    review: {\n      run: reviewerAgent,\n      next: (output, state) =&gt; {\n        if (output.approved) return \"done\"\n        if (state.iterations &gt;= 3) return \"done\"  // Max iterations\n        return \"revise\"\n      }\n    },\n    revise: {\n      run: revisionAgent,\n      next: \"review\"\n    },\n    done: phase.terminal()\n  }\n})\n</code></pre>"},{"location":"concepts/phases/#summary","title":"Summary","text":"Pattern Use Case Example Sequential Linear pipelines <code>planning \u2192 execution \u2192 review</code> Loop Retry until satisfied <code>work \u2194 review \u2192 done</code> Branch Conditional paths <code>triage \u2192 fast OR normal</code> Terminal End execution <code>phase.terminal()</code> <p>Design Principle</p> <p>Phases make control flow explicit. There's no hidden state machine\u2014you can trace exactly how the workflow progresses by reading the phase definitions.</p>"},{"location":"concepts/phases/#next","title":"Next","text":"<p>See how Workflows bring together state, phases, and agents into a single runnable unit.</p>"},{"location":"concepts/workflows/","title":"Workflows","text":"<p>The composition that brings everything together.</p> <p>A workflow is the top-level construct in Open Harness. It combines initial state, a start function, and phases into a single, runnable unit\u2014the single source of truth for your AI application.</p>"},{"location":"concepts/workflows/#workflow-anatomy","title":"Workflow Anatomy","text":"<pre><code>import { workflow, phase } from \"@open-harness/core\"\n\nconst taskPlanner = workflow({\n  // Identity\n  name: \"task-planner\",\n\n  // Initial state shape and defaults\n  initialState: {\n    goal: \"\",\n    tasks: [] as string[],\n    currentTask: 0,\n    result: null as string | null\n  },\n\n  // Transform input into initial state\n  start: (input: string, draft) =&gt; {\n    draft.goal = input\n  },\n\n  // The execution graph\n  phases: {\n    planning: { run: plannerAgent, next: \"execution\" },\n    execution: { run: workerAgent, next: \"review\" },\n    review: { run: reviewerAgent, next: \"done\" },\n    done: phase.terminal()\n  }\n})\n</code></pre> <p>Every workflow has four parts:</p> Part Purpose <code>name</code> Unique identifier for the workflow <code>initialState</code> Shape and default values of state <code>start</code> Function that transforms input into state <code>phases</code> The execution graph of agents and transitions"},{"location":"concepts/workflows/#state-the-shape-of-your-data","title":"State: The Shape of Your Data","text":"<p>The <code>initialState</code> defines what data your workflow tracks:</p> <pre><code>initialState: {\n  // Input data\n  topic: \"\",\n  context: \"\",\n\n  // Working data\n  findings: [] as Finding[],\n  drafts: [] as string[],\n\n  // Output data\n  summary: null as string | null,\n  confidence: 0,\n\n  // Metadata\n  iterations: 0,\n  startedAt: 0\n}\n</code></pre> <p>Best practices:</p> <ul> <li>Type everything explicitly (use <code>as</code> for arrays and unions)</li> <li>Initialize with sensible defaults</li> <li>Include metadata for debugging (timestamps, iteration counts)</li> <li>Keep state flat when possible</li> </ul>"},{"location":"concepts/workflows/#start-input-state","title":"Start: Input \u2192 State","text":"<p>The <code>start</code> function transforms external input into workflow state:</p> <pre><code>start: (input: { topic: string; depth: \"shallow\" | \"deep\" }, draft) =&gt; {\n  draft.topic = input.topic\n  draft.maxIterations = input.depth === \"deep\" ? 5 : 2\n  draft.startedAt = Date.now()\n}\n</code></pre> <p>This is where you:</p> <ul> <li>Validate and normalize input</li> <li>Set initial values based on input</li> <li>Configure workflow behavior</li> </ul> <p>The <code>draft</code> uses Immer semantics\u2014mutate it directly.</p>"},{"location":"concepts/workflows/#phases-the-execution-graph","title":"Phases: The Execution Graph","text":"<p>Phases define how the workflow progresses:</p> <pre><code>phases: {\n  // First phase (determined by workflow execution)\n  research: {\n    run: researchAgent,\n    next: \"analyze\"\n  },\n\n  // Middle phases\n  analyze: {\n    run: analysisAgent,\n    next: (output) =&gt; output.needsMore ? \"research\" : \"summarize\"\n  },\n\n  // Conditional phase\n  summarize: {\n    run: summaryAgent,\n    next: \"done\",\n    when: (state) =&gt; state.findings.length &gt; 0\n  },\n\n  // Terminal phase\n  done: phase.terminal()\n}\n</code></pre> <p>The first phase listed is where execution begins. Phases run their agent, then transition to <code>next</code>.</p>"},{"location":"concepts/workflows/#running-a-workflow","title":"Running a Workflow","text":"<p>Execute with the <code>run</code> function:</p> <pre><code>import { run } from \"@open-harness/core\"\nimport { AnthropicProvider } from \"@open-harness/server\"\n\nconst execution = await run(taskPlanner, {\n  // The input passed to start()\n  input: \"Build a REST API\",\n\n  // Execution mode\n  mode: \"live\",  // or \"playback\" for recorded responses\n})\n</code></pre>"},{"location":"concepts/workflows/#observing-execution","title":"Observing Execution","text":"<p>Subscribe to events for real-time updates:</p> <pre><code>execution.subscribe({\n  // Lifecycle\n  onStarted: (sessionId) =&gt; console.log(\"Started:\", sessionId),\n  onCompleted: ({ state }) =&gt; console.log(\"Done:\", state),\n  onErrored: (error) =&gt; console.error(\"Failed:\", error),\n\n  // State changes\n  onStateChanged: (state, patches) =&gt; updateUI(state),\n  onPhaseChanged: (phase, from) =&gt; console.log(`${from} \u2192 ${phase}`),\n\n  // Agent events\n  onAgentStarted: ({ agent }) =&gt; console.log(\"Agent:\", agent),\n  onAgentCompleted: ({ agent, output, durationMs }) =&gt; {\n    console.log(`${agent} done in ${durationMs}ms`)\n  },\n\n  // Streaming\n  onTextDelta: ({ delta }) =&gt; process.stdout.write(delta),\n\n  // Human-in-the-loop\n  onInputRequested: async (request) =&gt; {\n    return await getUserInput(request.prompt)\n  }\n})\n</code></pre>"},{"location":"concepts/workflows/#getting-results","title":"Getting Results","text":"<p>Wait for completion:</p> <pre><code>const result = await execution.result()\n\nconsole.log(result.state)       // Final state\nconsole.log(result.events)      // All events\nconsole.log(result.sessionId)   // Session identifier\n</code></pre>"},{"location":"concepts/workflows/#execution-modes","title":"Execution Modes","text":"<p>Workflows run in two modes:</p> Mode Behavior Use Case <code>live</code> Real API calls, responses recorded Development, production <code>playback</code> Recorded responses replayed Testing, CI <pre><code>// Development: real API calls\nconst result = await run(workflow, {\n  input: \"...\",\n  mode: \"live\"\n})\n\n// Testing: recorded responses\nconst result = await run(workflow, {\n  input: \"...\",\n  mode: \"playback\"\n})\n</code></pre> <p>This enables deterministic testing without mocks.</p>"},{"location":"concepts/workflows/#workflow-composition","title":"Workflow Composition","text":"<p>Workflows are composable. One workflow can invoke another:</p> <pre><code>const outerWorkflow = workflow({\n  name: \"outer\",\n  initialState: { result: null },\n  start: (input, draft) =&gt; { /* ... */ },\n  phases: {\n    prepare: { run: prepareAgent, next: \"inner\" },\n    inner: {\n      run: async (state) =&gt; {\n        // Run another workflow\n        const innerResult = await run(innerWorkflow, {\n          input: state.preparedData,\n          mode: \"live\"\n        })\n        return innerResult.result().state\n      },\n      next: \"finalize\"\n    },\n    finalize: { run: finalizeAgent, next: \"done\" },\n    done: phase.terminal()\n  }\n})\n</code></pre>"},{"location":"concepts/workflows/#type-safety","title":"Type Safety","text":"<p>Workflows are fully typed. TypeScript infers:</p> <ul> <li>State shape from <code>initialState</code></li> <li>Input type from <code>start</code> function signature</li> <li>Output type from state</li> </ul> <pre><code>// Type is inferred from initialState\ntype MyState = {\n  goal: string\n  tasks: string[]\n  result: string | null\n}\n\n// Input type is explicit in start()\nstart: (input: { goal: string; priority: number }, draft) =&gt; {\n  // draft is typed as MyState\n  draft.goal = input.goal\n}\n\n// Result is typed\nconst result = await execution.result()\nresult.state.tasks  // string[] - fully typed\n</code></pre>"},{"location":"concepts/workflows/#example-research-workflow","title":"Example: Research Workflow","text":"<p>A complete example with all concepts:</p> <pre><code>import { workflow, phase, agent } from \"@open-harness/core\"\nimport { z } from \"zod\"\n\n// Agents\nconst researcher = agent({\n  name: \"researcher\",\n  model: \"claude-sonnet-4-5\",\n  output: z.object({\n    findings: z.array(z.string()),\n    confidence: z.number()\n  }),\n  prompt: (state) =&gt; `Research: ${state.topic}`,\n  update: (output, draft) =&gt; {\n    draft.findings.push(...output.findings)\n    draft.confidence = output.confidence\n  }\n})\n\nconst summarizer = agent({\n  name: \"summarizer\",\n  model: \"claude-sonnet-4-5\",\n  output: z.object({ summary: z.string() }),\n  prompt: (state) =&gt; `Summarize: ${state.findings.join(\"\\n\")}`,\n  update: (output, draft) =&gt; {\n    draft.summary = output.summary\n  }\n})\n\n// Workflow\nconst researchWorkflow = workflow({\n  name: \"research\",\n\n  initialState: {\n    topic: \"\",\n    findings: [] as string[],\n    confidence: 0,\n    summary: null as string | null,\n    iterations: 0\n  },\n\n  start: (input: string, draft) =&gt; {\n    draft.topic = input\n  },\n\n  phases: {\n    research: {\n      run: researcher,\n      next: (output, state) =&gt; {\n        if (output.confidence &gt; 0.8) return \"summarize\"\n        if (state.iterations &gt;= 3) return \"summarize\"\n        return \"research\"  // Loop for more findings\n      }\n    },\n    summarize: {\n      run: summarizer,\n      next: \"done\"\n    },\n    done: phase.terminal()\n  }\n})\n\n// Execute\nconst execution = await run(researchWorkflow, {\n  input: \"quantum computing applications\",\n  mode: \"live\"\n})\n\nconst result = await execution.result()\nconsole.log(result.state.summary)\n</code></pre>"},{"location":"concepts/workflows/#summary","title":"Summary","text":"Component Role <code>name</code> Identifies the workflow <code>initialState</code> Defines state shape and defaults <code>start</code> Transforms input to initial state <code>phases</code> Defines execution graph <code>run()</code> Executes the workflow <p>Key Insight</p> <p>The workflow is the single source of truth. Everything about your AI application\u2014state shape, agents, transitions\u2014is defined in one place.</p>"},{"location":"concepts/workflows/#next-steps","title":"Next Steps","text":"<ul> <li>Building Workflows \u2014 Practical guide to creating workflows</li> <li>React Integration \u2014 Connect workflows to React UIs</li> <li>API Reference \u2014 Complete API documentation</li> </ul>"},{"location":"guides/building-workflows/","title":"Building Workflows","text":"<p>Practical patterns for constructing real-world AI workflows.</p> <p>Once you understand the core concepts, it's time to build. This guide covers common patterns you'll use when constructing workflows\u2014from simple pipelines to complex multi-agent systems with loops, branches, and human intervention.</p>"},{"location":"guides/building-workflows/#starting-simple","title":"Starting Simple","text":"<p>Every workflow starts with the same structure. Here's the minimal template:</p> <pre><code>import { workflow, phase, agent, run } from \"@open-harness/core\"\nimport { z } from \"zod\"\n\nconst myWorkflow = workflow({\n  name: \"my-workflow\",\n  initialState: { /* your state shape */ },\n  start: (input, draft) =&gt; { /* transform input to state */ },\n  phases: { /* your execution graph */ }\n})\n</code></pre> <p>Let's build up from here with increasingly sophisticated patterns.</p>"},{"location":"guides/building-workflows/#pattern-1-linear-pipeline","title":"Pattern 1: Linear Pipeline","text":"<p>The simplest workflow is a sequence of agents, each processing the output of the previous:</p> <pre><code>import { workflow, phase, agent } from \"@open-harness/core\"\nimport { z } from \"zod\"\n\n// Agent 1: Extract key points\nconst extractor = agent({\n  name: \"extractor\",\n  model: \"claude-sonnet-4-5\",\n  output: z.object({\n    keyPoints: z.array(z.string()),\n    mainTheme: z.string()\n  }),\n  prompt: (state) =&gt; `Extract key points from: ${state.document}`,\n  update: (output, draft) =&gt; {\n    draft.keyPoints = output.keyPoints\n    draft.mainTheme = output.mainTheme\n  }\n})\n\n// Agent 2: Generate summary\nconst summarizer = agent({\n  name: \"summarizer\",\n  model: \"claude-sonnet-4-5\",\n  output: z.object({\n    summary: z.string()\n  }),\n  prompt: (state) =&gt; `\n    Summarize these key points about \"${state.mainTheme}\":\n    ${state.keyPoints.map((p, i) =&gt; `${i + 1}. ${p}`).join(\"\\n\")}\n  `,\n  update: (output, draft) =&gt; {\n    draft.summary = output.summary\n  }\n})\n\n// The workflow\nconst documentSummarizer = workflow({\n  name: \"document-summarizer\",\n\n  initialState: {\n    document: \"\",\n    keyPoints: [] as string[],\n    mainTheme: \"\",\n    summary: \"\"\n  },\n\n  start: (input: string, draft) =&gt; {\n    draft.document = input\n  },\n\n  phases: {\n    extract: { run: extractor, next: \"summarize\" },\n    summarize: { run: summarizer, next: \"done\" },\n    done: phase.terminal()\n  }\n})\n</code></pre> <p>When to use: Data transformation pipelines, content processing, analysis workflows.</p>"},{"location":"guides/building-workflows/#pattern-2-review-loop","title":"Pattern 2: Review Loop","text":"<p>A common pattern is iterating until quality meets a threshold:</p> <pre><code>const writer = agent({\n  name: \"writer\",\n  model: \"claude-sonnet-4-5\",\n  output: z.object({\n    content: z.string(),\n    wordCount: z.number()\n  }),\n  prompt: (state) =&gt; {\n    if (state.feedback) {\n      return `\n        Revise this content based on feedback:\n\n        Previous version:\n        ${state.content}\n\n        Feedback:\n        ${state.feedback}\n      `\n    }\n    return `Write an article about: ${state.topic}`\n  },\n  update: (output, draft) =&gt; {\n    draft.content = output.content\n    draft.iterations++\n  }\n})\n\nconst reviewer = agent({\n  name: \"reviewer\",\n  model: \"claude-sonnet-4-5\",\n  output: z.object({\n    approved: z.boolean(),\n    score: z.number().min(0).max(1),\n    feedback: z.string().optional()\n  }),\n  prompt: (state) =&gt; `\n    Review this article for quality. Score 0-1 and approve if &gt;= 0.8:\n\n    ${state.content}\n  `,\n  update: (output, draft) =&gt; {\n    draft.approved = output.approved\n    draft.score = output.score\n    draft.feedback = output.feedback ?? \"\"\n  }\n})\n\nconst contentWorkflow = workflow({\n  name: \"content-loop\",\n\n  initialState: {\n    topic: \"\",\n    content: \"\",\n    feedback: \"\",\n    score: 0,\n    approved: false,\n    iterations: 0\n  },\n\n  start: (input: string, draft) =&gt; {\n    draft.topic = input\n  },\n\n  phases: {\n    write: { run: writer, next: \"review\" },\n\n    review: {\n      run: reviewer,\n      next: (output, state) =&gt; {\n        // Exit conditions\n        if (output.approved) return \"done\"\n        if (state.iterations &gt;= 3) return \"done\"  // Max 3 attempts\n        return \"write\"  // Loop back\n      }\n    },\n\n    done: phase.terminal()\n  }\n})\n</code></pre> <p>Key points:</p> <ul> <li>Always include a maximum iteration limit</li> <li>The <code>next</code> function receives both agent output and current state</li> <li>Use state to track loop metadata (iterations, attempts, etc.)</li> </ul>"},{"location":"guides/building-workflows/#pattern-3-conditional-branching","title":"Pattern 3: Conditional Branching","text":"<p>Route to different agents based on input characteristics:</p> <pre><code>const classifier = agent({\n  name: \"classifier\",\n  model: \"claude-sonnet-4-5\",\n  output: z.object({\n    category: z.enum([\"technical\", \"creative\", \"analytical\"]),\n    confidence: z.number()\n  }),\n  prompt: (state) =&gt; `Classify this request: ${state.request}`,\n  update: (output, draft) =&gt; {\n    draft.category = output.category\n  }\n})\n\nconst technicalAgent = agent({\n  name: \"technical\",\n  model: \"claude-sonnet-4-5\",\n  output: z.object({ response: z.string() }),\n  prompt: (state) =&gt; `Provide technical guidance for: ${state.request}`,\n  update: (output, draft) =&gt; { draft.response = output.response }\n})\n\nconst creativeAgent = agent({\n  name: \"creative\",\n  model: \"claude-sonnet-4-5\",\n  output: z.object({ response: z.string() }),\n  prompt: (state) =&gt; `Generate creative content for: ${state.request}`,\n  update: (output, draft) =&gt; { draft.response = output.response }\n})\n\nconst analyticalAgent = agent({\n  name: \"analytical\",\n  model: \"claude-sonnet-4-5\",\n  output: z.object({ response: z.string() }),\n  prompt: (state) =&gt; `Analyze and provide insights for: ${state.request}`,\n  update: (output, draft) =&gt; { draft.response = output.response }\n})\n\nconst routerWorkflow = workflow({\n  name: \"smart-router\",\n\n  initialState: {\n    request: \"\",\n    category: \"\" as \"technical\" | \"creative\" | \"analytical\" | \"\",\n    response: \"\"\n  },\n\n  start: (input: string, draft) =&gt; {\n    draft.request = input\n  },\n\n  phases: {\n    classify: {\n      run: classifier,\n      next: (output) =&gt; {\n        switch (output.category) {\n          case \"technical\": return \"handleTechnical\"\n          case \"creative\": return \"handleCreative\"\n          case \"analytical\": return \"handleAnalytical\"\n        }\n      }\n    },\n    handleTechnical: { run: technicalAgent, next: \"done\" },\n    handleCreative: { run: creativeAgent, next: \"done\" },\n    handleAnalytical: { run: analyticalAgent, next: \"done\" },\n    done: phase.terminal()\n  }\n})\n</code></pre> <p>When to use: Multi-modal processing, request routing, specialized handling.</p>"},{"location":"guides/building-workflows/#pattern-4-multi-agent-collaboration","title":"Pattern 4: Multi-Agent Collaboration","text":"<p>Multiple agents working together on a complex task:</p> <pre><code>// Research agent gathers information\nconst researcher = agent({\n  name: \"researcher\",\n  model: \"claude-sonnet-4-5\",\n  output: z.object({\n    findings: z.array(z.object({\n      fact: z.string(),\n      source: z.string(),\n      relevance: z.number()\n    })),\n    needsMore: z.boolean()\n  }),\n  prompt: (state) =&gt; `\n    Research: ${state.topic}\n    ${state.findings.length &gt; 0 ? `\\nExisting findings:\\n${JSON.stringify(state.findings)}` : \"\"}\n    Find new information. Set needsMore=false when sufficient.\n  `,\n  update: (output, draft) =&gt; {\n    draft.findings.push(...output.findings)\n    draft.needsMore = output.needsMore\n  }\n})\n\n// Analyst agent evaluates findings\nconst analyst = agent({\n  name: \"analyst\",\n  model: \"claude-sonnet-4-5\",\n  output: z.object({\n    analysis: z.string(),\n    confidence: z.number(),\n    gaps: z.array(z.string())\n  }),\n  prompt: (state) =&gt; `\n    Analyze these research findings about \"${state.topic}\":\n    ${JSON.stringify(state.findings, null, 2)}\n  `,\n  update: (output, draft) =&gt; {\n    draft.analysis = output.analysis\n    draft.confidence = output.confidence\n    draft.gaps = output.gaps\n  }\n})\n\n// Writer synthesizes everything\nconst writer = agent({\n  name: \"writer\",\n  model: \"claude-sonnet-4-5\",\n  output: z.object({\n    report: z.string()\n  }),\n  prompt: (state) =&gt; `\n    Write a comprehensive report on \"${state.topic}\".\n\n    Analysis: ${state.analysis}\n\n    Key findings:\n    ${state.findings.map(f =&gt; `- ${f.fact}`).join(\"\\n\")}\n  `,\n  update: (output, draft) =&gt; {\n    draft.report = output.report\n  }\n})\n\nconst researchWorkflow = workflow({\n  name: \"research-team\",\n\n  initialState: {\n    topic: \"\",\n    findings: [] as Array&lt;{ fact: string; source: string; relevance: number }&gt;,\n    needsMore: true,\n    analysis: \"\",\n    confidence: 0,\n    gaps: [] as string[],\n    report: \"\",\n    researchRounds: 0\n  },\n\n  start: (input: string, draft) =&gt; {\n    draft.topic = input\n  },\n\n  phases: {\n    research: {\n      run: researcher,\n      next: (output, state) =&gt; {\n        if (!output.needsMore || state.researchRounds &gt;= 3) {\n          return \"analyze\"\n        }\n        return \"research\"  // Continue researching\n      }\n    },\n    analyze: {\n      run: analyst,\n      next: (output, state) =&gt; {\n        // If gaps found and confidence low, research more\n        if (output.gaps.length &gt; 0 &amp;&amp; output.confidence &lt; 0.7) {\n          return \"research\"\n        }\n        return \"write\"\n      }\n    },\n    write: { run: writer, next: \"done\" },\n    done: phase.terminal()\n  }\n})\n</code></pre> <p>Key insight: Agents can loop back and forth. The analyst finding gaps triggers more research.</p>"},{"location":"guides/building-workflows/#pattern-5-human-in-the-loop","title":"Pattern 5: Human-in-the-Loop","text":"<p>Pause for human input at critical decision points:</p> <pre><code>import { run } from \"@open-harness/core\"\n\nconst proposer = agent({\n  name: \"proposer\",\n  model: \"claude-sonnet-4-5\",\n  output: z.object({\n    proposal: z.string(),\n    options: z.array(z.object({\n      id: z.string(),\n      description: z.string(),\n      risk: z.enum([\"low\", \"medium\", \"high\"])\n    }))\n  }),\n  prompt: (state) =&gt; `\n    Generate a proposal for: ${state.request}\n    Provide 2-3 options with risk levels.\n  `,\n  update: (output, draft) =&gt; {\n    draft.proposal = output.proposal\n    draft.options = output.options\n  }\n})\n\nconst executor = agent({\n  name: \"executor\",\n  model: \"claude-sonnet-4-5\",\n  output: z.object({\n    result: z.string(),\n    success: z.boolean()\n  }),\n  prompt: (state) =&gt; `\n    Execute the approved option: ${state.approvedOption}\n    Original request: ${state.request}\n  `,\n  update: (output, draft) =&gt; {\n    draft.result = output.result\n    draft.success = output.success\n  }\n})\n\nconst approvalWorkflow = workflow({\n  name: \"approval-flow\",\n\n  initialState: {\n    request: \"\",\n    proposal: \"\",\n    options: [] as Array&lt;{ id: string; description: string; risk: string }&gt;,\n    approvedOption: \"\",\n    humanFeedback: \"\",\n    result: \"\",\n    success: false\n  },\n\n  start: (input: string, draft) =&gt; {\n    draft.request = input\n  },\n\n  phases: {\n    propose: {\n      run: proposer,\n      next: \"awaitApproval\"\n    },\n\n    awaitApproval: {\n      // This phase requests human input\n      run: async (state, context) =&gt; {\n        // Request input from human\n        const response = await context.requestInput({\n          prompt: `Review proposal:\\n${state.proposal}\\n\\nOptions:\\n${\n            state.options.map(o =&gt; `[${o.id}] ${o.description} (${o.risk} risk)`).join(\"\\n\")\n          }\\n\\nEnter option ID to approve or 'reject' to cancel:`,\n          type: \"text\"\n        })\n\n        return { approved: response !== \"reject\", selectedOption: response }\n      },\n      next: (output) =&gt; output.approved ? \"execute\" : \"done\"\n    },\n\n    execute: { run: executor, next: \"done\" },\n    done: phase.terminal()\n  }\n})\n\n// Running with human input handling\nconst execution = await run(approvalWorkflow, {\n  input: \"Deploy new feature to production\",\n  mode: \"live\"\n})\n\nexecution.subscribe({\n  // Handle human input requests\n  onInputRequested: async (request) =&gt; {\n    // In a real app, this would show a UI prompt\n    console.log(request.prompt)\n    const userInput = await getUserInputSomehow()\n    return userInput\n  },\n\n  onCompleted: ({ state }) =&gt; {\n    console.log(\"Workflow complete:\", state.result)\n  }\n})\n</code></pre> <p>Important: Human-in-the-loop pauses workflow execution until input is received. The <code>onInputRequested</code> callback is how you integrate with your UI.</p>"},{"location":"guides/building-workflows/#pattern-6-error-handling-and-recovery","title":"Pattern 6: Error Handling and Recovery","text":"<p>Build resilient workflows that handle failures gracefully:</p> <pre><code>const riskyAgent = agent({\n  name: \"risky-operation\",\n  model: \"claude-sonnet-4-5\",\n  output: z.object({\n    result: z.string(),\n    status: z.enum([\"success\", \"partial\", \"failed\"])\n  }),\n  prompt: (state) =&gt; `Attempt operation: ${state.operation}`,\n  update: (output, draft) =&gt; {\n    draft.result = output.result\n    draft.status = output.status\n    draft.attempts++\n  }\n})\n\nconst recoveryAgent = agent({\n  name: \"recovery\",\n  model: \"claude-sonnet-4-5\",\n  output: z.object({\n    suggestion: z.string(),\n    canRetry: z.boolean()\n  }),\n  prompt: (state) =&gt; `\n    The operation failed: ${state.result}\n    Attempts: ${state.attempts}\n    Suggest recovery steps.\n  `,\n  update: (output, draft) =&gt; {\n    draft.recoverySuggestion = output.suggestion\n    draft.canRetry = output.canRetry\n  }\n})\n\nconst resilientWorkflow = workflow({\n  name: \"resilient-operation\",\n\n  initialState: {\n    operation: \"\",\n    result: \"\",\n    status: \"\" as \"success\" | \"partial\" | \"failed\" | \"\",\n    attempts: 0,\n    recoverySuggestion: \"\",\n    canRetry: false,\n    finalOutcome: \"\"\n  },\n\n  start: (input: string, draft) =&gt; {\n    draft.operation = input\n  },\n\n  phases: {\n    attempt: {\n      run: riskyAgent,\n      next: (output, state) =&gt; {\n        if (output.status === \"success\") return \"success\"\n        if (state.attempts &gt;= 3) return \"failure\"\n        return \"recover\"\n      }\n    },\n\n    recover: {\n      run: recoveryAgent,\n      next: (output) =&gt; output.canRetry ? \"attempt\" : \"failure\"\n    },\n\n    success: {\n      run: async (state, context) =&gt; {\n        return { finalOutcome: `Success: ${state.result}` }\n      },\n      next: \"done\"\n    },\n\n    failure: {\n      run: async (state, context) =&gt; {\n        return {\n          finalOutcome: `Failed after ${state.attempts} attempts. ${state.recoverySuggestion}`\n        }\n      },\n      next: \"done\"\n    },\n\n    done: phase.terminal()\n  }\n})\n</code></pre> <p>Best practices:</p> <ul> <li>Always limit retry attempts</li> <li>Use dedicated recovery phases</li> <li>Track attempt counts in state</li> <li>Have clear success/failure terminal paths</li> </ul>"},{"location":"guides/building-workflows/#pattern-7-workflow-composition","title":"Pattern 7: Workflow Composition","text":"<p>Nest workflows inside workflows for complex orchestration:</p> <pre><code>import { run } from \"@open-harness/core\"\n\n// A reusable sub-workflow\nconst validationWorkflow = workflow({\n  name: \"validator\",\n  initialState: {\n    data: {} as Record&lt;string, unknown&gt;,\n    isValid: false,\n    errors: [] as string[]\n  },\n  start: (input: Record&lt;string, unknown&gt;, draft) =&gt; {\n    draft.data = input\n  },\n  phases: {\n    validate: {\n      run: validatorAgent,\n      next: \"done\"\n    },\n    done: phase.terminal()\n  }\n})\n\n// Parent workflow that uses the sub-workflow\nconst processingWorkflow = workflow({\n  name: \"data-processor\",\n\n  initialState: {\n    rawData: {} as Record&lt;string, unknown&gt;,\n    validatedData: {} as Record&lt;string, unknown&gt;,\n    processedResult: \"\",\n    validationPassed: false\n  },\n\n  start: (input: Record&lt;string, unknown&gt;, draft) =&gt; {\n    draft.rawData = input\n  },\n\n  phases: {\n    preprocess: {\n      run: preprocessAgent,\n      next: \"validate\"\n    },\n\n    // Run the validation sub-workflow\n    validate: {\n      run: async (state, context) =&gt; {\n        const subExecution = await run(validationWorkflow, {\n          input: state.rawData,\n          mode: \"live\"\n        })\n\n        const result = await subExecution.result()\n        return {\n          validatedData: result.state.data,\n          isValid: result.state.isValid,\n          errors: result.state.errors\n        }\n      },\n      next: (output) =&gt; output.isValid ? \"process\" : \"handleErrors\"\n    },\n\n    process: {\n      run: processorAgent,\n      next: \"done\"\n    },\n\n    handleErrors: {\n      run: errorHandlerAgent,\n      next: \"done\"\n    },\n\n    done: phase.terminal()\n  }\n})\n</code></pre> <p>When to use: Reusable validation logic, modular workflow components, complex orchestration.</p>"},{"location":"guides/building-workflows/#best-practices","title":"Best Practices","text":""},{"location":"guides/building-workflows/#state-design","title":"State Design","text":"<pre><code>initialState: {\n  // Inputs (set by start())\n  topic: \"\",\n  context: \"\",\n\n  // Working data (modified by agents)\n  findings: [] as Finding[],\n  drafts: [] as string[],\n\n  // Outputs (final results)\n  result: null as string | null,\n\n  // Metadata (for debugging/control)\n  iterations: 0,\n  startedAt: 0,\n  phase: \"\" // Optional: track current phase\n}\n</code></pre>"},{"location":"guides/building-workflows/#agent-design","title":"Agent Design","text":"<ul> <li>Single responsibility: One clear task per agent</li> <li>Explicit schemas: Detailed Zod schemas with <code>.describe()</code></li> <li>Focused prompts: Only include relevant state in prompts</li> <li>Atomic updates: Each agent updates a specific part of state</li> </ul>"},{"location":"guides/building-workflows/#phase-design","title":"Phase Design","text":"<ul> <li>Meaningful names: <code>analyze</code> not <code>phase2</code></li> <li>Clear transitions: Make the flow readable</li> <li>Bounded loops: Always have exit conditions</li> <li>Terminal states: Have explicit success/failure terminals</li> </ul>"},{"location":"guides/building-workflows/#debugging-tips","title":"Debugging Tips","text":""},{"location":"guides/building-workflows/#log-events","title":"Log Events","text":"<pre><code>execution.subscribe({\n  onPhaseChanged: (phase, from) =&gt; {\n    console.log(`Phase: ${from} \u2192 ${phase}`)\n  },\n  onAgentStarted: ({ agent }) =&gt; {\n    console.log(`Agent started: ${agent}`)\n  },\n  onAgentCompleted: ({ agent, output, durationMs }) =&gt; {\n    console.log(`Agent ${agent} completed in ${durationMs}ms:`, output)\n  },\n  onStateChanged: (state, patches) =&gt; {\n    console.log(\"State patches:\", patches)\n  }\n})\n</code></pre>"},{"location":"guides/building-workflows/#use-playback-mode","title":"Use Playback Mode","text":"<p>Record a session and replay it to debug:</p> <pre><code>// Record in development\nconst result = await run(workflow, { input: \"...\", mode: \"live\" })\n\n// Replay in debugging - same events, no API calls\nconst debug = await run(workflow, { input: \"...\", mode: \"playback\" })\n</code></pre>"},{"location":"guides/building-workflows/#fork-from-any-point","title":"Fork From Any Point","text":"<pre><code>// Fork from a specific event to try alternatives\nconst fork = await execution.forkFrom(eventIndex)\nawait fork.resume()\n</code></pre>"},{"location":"guides/building-workflows/#summary","title":"Summary","text":"Pattern Use Case Key Feature Linear Pipeline Sequential processing Simple, predictable Review Loop Quality iteration Bounded retries Conditional Branch Routing Dynamic next function Multi-Agent Complex tasks Agent collaboration Human-in-the-Loop Approvals, decisions Input requests Error Recovery Resilience Retry with recovery Composition Modularity Nested workflows <p>Next Steps</p> <p>Ready to add a UI? See React Integration for connecting workflows to React components.</p>"},{"location":"guides/building-workflows/#related","title":"Related","text":"<ul> <li>Concepts: Workflows \u2014 Deep dive on workflow structure</li> <li>Concepts: Phases \u2014 Phase patterns and transitions</li> <li>Concepts: Agents \u2014 Agent design and configuration</li> <li>API Reference \u2014 Complete API documentation</li> </ul>"},{"location":"guides/react-integration/","title":"React Integration","text":"<p>Build real-time AI interfaces with React hooks.</p> <p>The <code>@open-harness/client</code> package provides React hooks for connecting your UI to Open Harness workflows. Stream AI responses, display workflow state, and build interactive AI applications.</p>"},{"location":"guides/react-integration/#installation","title":"Installation","text":"<pre><code>bun add @open-harness/client\n</code></pre> <p>Peer dependencies: React 18+</p>"},{"location":"guides/react-integration/#quick-start","title":"Quick Start","text":"<p>Wrap your app with <code>WorkflowClientProvider</code> and use hooks to interact with workflows:</p> <pre><code>import {\n  WorkflowClientProvider,\n  useWorkflow\n} from \"@open-harness/client\"\n\nfunction App() {\n  return (\n    &lt;WorkflowClientProvider url=\"http://localhost:42069\"&gt;\n      &lt;ChatInterface /&gt;\n    &lt;/WorkflowClientProvider&gt;\n  )\n}\n\nfunction ChatInterface() {\n  const { state, status, textStream, actions } = useWorkflow()\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick={() =&gt; actions.start(\"Hello!\")}&gt;\n        Start\n      &lt;/button&gt;\n      {textStream &amp;&amp; &lt;p&gt;{textStream}&lt;/p&gt;}\n    &lt;/div&gt;\n  )\n}\n</code></pre>"},{"location":"guides/react-integration/#workflowclientprovider","title":"WorkflowClientProvider","text":"<p>The provider establishes a connection to your Open Harness server:</p> <pre><code>import { WorkflowClientProvider } from \"@open-harness/client\"\n\nfunction App() {\n  return (\n    &lt;WorkflowClientProvider\n      url=\"http://localhost:42069\"\n      options={{\n        // Reconnect on disconnect\n        reconnect: true,\n        reconnectInterval: 1000,\n\n        // Authentication\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      }}\n    &gt;\n      {children}\n    &lt;/WorkflowClientProvider&gt;\n  )\n}\n</code></pre>"},{"location":"guides/react-integration/#provider-options","title":"Provider Options","text":"Option Type Default Description <code>url</code> <code>string</code> required Server URL <code>reconnect</code> <code>boolean</code> <code>true</code> Auto-reconnect on disconnect <code>reconnectInterval</code> <code>number</code> <code>1000</code> Milliseconds between reconnection attempts <code>headers</code> <code>Record&lt;string, string&gt;</code> <code>{}</code> Custom headers (auth, etc.)"},{"location":"guides/react-integration/#core-hooks","title":"Core Hooks","text":""},{"location":"guides/react-integration/#useworkflow","title":"useWorkflow","text":"<p>The primary hook for interacting with workflows:</p> <pre><code>import { useWorkflow } from \"@open-harness/client\"\n\nfunction MyComponent() {\n  const {\n    // Current workflow state (typed)\n    state,\n\n    // Execution status\n    status,  // 'idle' | 'running' | 'completed' | 'error'\n\n    // Streaming content\n    textStream,     // Current streaming text\n    thinkingStream, // Extended thinking content (if enabled)\n\n    // Error information\n    error,\n\n    // Control actions\n    actions: {\n      start,   // Start workflow with input\n      pause,   // Pause execution\n      resume,  // Resume paused workflow\n      cancel,  // Cancel execution\n      fork     // Fork from current point\n    },\n\n    // Session info\n    sessionId,\n    currentPhase\n  } = useWorkflow&lt;MyStateType&gt;()\n\n  return (/* ... */)\n}\n</code></pre>"},{"location":"guides/react-integration/#useworkflowstate","title":"useWorkflowState","text":"<p>Read-only access to workflow state with optional selector:</p> <pre><code>import { useWorkflowState } from \"@open-harness/client\"\n\nfunction StatusDisplay() {\n  // Get entire state\n  const state = useWorkflowState&lt;MyState&gt;()\n\n  // Or use a selector for specific values (optimized re-renders)\n  const progress = useWorkflowState&lt;MyState, number&gt;(\n    (state) =&gt; state.progress\n  )\n\n  return &lt;div&gt;Progress: {progress}%&lt;/div&gt;\n}\n</code></pre>"},{"location":"guides/react-integration/#usecreatesession","title":"useCreateSession","text":"<p>Create new workflow sessions:</p> <pre><code>import { useCreateSession } from \"@open-harness/client\"\n\nfunction NewSessionButton() {\n  const { createSession, isCreating, error } = useCreateSession()\n\n  const handleClick = async () =&gt; {\n    const session = await createSession({\n      workflow: \"my-workflow\",\n      input: { topic: \"AI\" },\n      mode: \"live\"\n    })\n    console.log(\"Created session:\", session.id)\n  }\n\n  return (\n    &lt;button onClick={handleClick} disabled={isCreating}&gt;\n      {isCreating ? \"Creating...\" : \"New Session\"}\n    &lt;/button&gt;\n  )\n}\n</code></pre>"},{"location":"guides/react-integration/#usetextstream","title":"useTextStream","text":"<p>Real-time text streaming from AI:</p> <pre><code>import { useTextStream } from \"@open-harness/client\"\n\nfunction StreamingOutput() {\n  const {\n    text,        // Accumulated text\n    delta,       // Latest chunk\n    isStreaming, // Currently receiving\n    clear        // Reset accumulated text\n  } = useTextStream()\n\n  return (\n    &lt;div&gt;\n      {isStreaming &amp;&amp; &lt;span className=\"cursor\" /&gt;}\n      &lt;p&gt;{text}&lt;/p&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre>"},{"location":"guides/react-integration/#building-a-chat-interface","title":"Building a Chat Interface","text":"<p>Here's a complete example of a chat-style interface:</p> <pre><code>import React, { useState } from \"react\"\nimport {\n  WorkflowClientProvider,\n  useWorkflow,\n  useTextStream\n} from \"@open-harness/client\"\n\n// State type for our chat workflow\ninterface ChatState {\n  messages: Array&lt;{\n    role: \"user\" | \"assistant\"\n    content: string\n  }&gt;\n  currentResponse: string\n}\n\nfunction App() {\n  return (\n    &lt;WorkflowClientProvider url=\"http://localhost:42069\"&gt;\n      &lt;ChatApp /&gt;\n    &lt;/WorkflowClientProvider&gt;\n  )\n}\n\nfunction ChatApp() {\n  const [input, setInput] = useState(\"\")\n  const { state, status, actions } = useWorkflow&lt;ChatState&gt;()\n  const { text: streamingText, isStreaming } = useTextStream()\n\n  const handleSubmit = (e: React.FormEvent) =&gt; {\n    e.preventDefault()\n    if (input.trim() &amp;&amp; status !== \"running\") {\n      actions.start(input)\n      setInput(\"\")\n    }\n  }\n\n  return (\n    &lt;div className=\"chat-container\"&gt;\n      {/* Message history */}\n      &lt;div className=\"messages\"&gt;\n        {state?.messages.map((msg, i) =&gt; (\n          &lt;div key={i} className={`message ${msg.role}`}&gt;\n            {msg.content}\n          &lt;/div&gt;\n        ))}\n\n        {/* Streaming response */}\n        {isStreaming &amp;&amp; (\n          &lt;div className=\"message assistant streaming\"&gt;\n            {streamingText}\n            &lt;span className=\"cursor\"&gt;|&lt;/span&gt;\n          &lt;/div&gt;\n        )}\n      &lt;/div&gt;\n\n      {/* Input form */}\n      &lt;form onSubmit={handleSubmit}&gt;\n        &lt;input\n          value={input}\n          onChange={(e) =&gt; setInput(e.target.value)}\n          placeholder=\"Type a message...\"\n          disabled={status === \"running\"}\n        /&gt;\n        &lt;button type=\"submit\" disabled={status === \"running\"}&gt;\n          Send\n        &lt;/button&gt;\n      &lt;/form&gt;\n\n      {/* Status indicator */}\n      {status === \"running\" &amp;&amp; (\n        &lt;div className=\"status\"&gt;AI is thinking...&lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  )\n}\n</code></pre>"},{"location":"guides/react-integration/#real-time-updates","title":"Real-Time Updates","text":""},{"location":"guides/react-integration/#phase-tracking","title":"Phase Tracking","text":"<p>Monitor workflow phase transitions:</p> <pre><code>import { usePhase } from \"@open-harness/client\"\n\nfunction PhaseIndicator() {\n  const { currentPhase, previousPhase, phaseHistory } = usePhase()\n\n  return (\n    &lt;div className=\"phase-indicator\"&gt;\n      &lt;span className=\"current\"&gt;Current: {currentPhase}&lt;/span&gt;\n      {previousPhase &amp;&amp; (\n        &lt;span className=\"previous\"&gt;Previous: {previousPhase}&lt;/span&gt;\n      )}\n\n      {/* Show phase progression */}\n      &lt;div className=\"history\"&gt;\n        {phaseHistory.map((phase, i) =&gt; (\n          &lt;span key={i} className=\"phase-chip\"&gt;{phase}&lt;/span&gt;\n        ))}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre>"},{"location":"guides/react-integration/#event-subscription","title":"Event Subscription","text":"<p>Listen to all workflow events:</p> <pre><code>import { useWorkflowEvents } from \"@open-harness/client\"\n\nfunction EventLogger() {\n  const [events, setEvents] = useState&lt;WorkflowEvent[]&gt;([])\n\n  useWorkflowEvents({\n    onEvent: (event) =&gt; {\n      setEvents(prev =&gt; [...prev, event])\n    },\n    onPhaseChanged: (phase, from) =&gt; {\n      console.log(`Phase: ${from} \u2192 ${phase}`)\n    },\n    onAgentStarted: ({ agent }) =&gt; {\n      console.log(`Agent started: ${agent}`)\n    },\n    onAgentCompleted: ({ agent, durationMs }) =&gt; {\n      console.log(`Agent ${agent} done in ${durationMs}ms`)\n    }\n  })\n\n  return (\n    &lt;div className=\"event-log\"&gt;\n      {events.map((e, i) =&gt; (\n        &lt;div key={i} className=\"event\"&gt;\n          [{e.type}] {JSON.stringify(e.payload)}\n        &lt;/div&gt;\n      ))}\n    &lt;/div&gt;\n  )\n}\n</code></pre>"},{"location":"guides/react-integration/#human-in-the-loop-ui","title":"Human-in-the-Loop UI","text":"<p>Handle input requests from the workflow:</p> <pre><code>import { useInputRequest } from \"@open-harness/client\"\n\nfunction ApprovalDialog() {\n  const {\n    inputRequest,    // Current request (null if none)\n    respond,         // Send response\n    isWaiting        // Workflow is waiting for input\n  } = useInputRequest()\n\n  if (!inputRequest) return null\n\n  return (\n    &lt;div className=\"modal\"&gt;\n      &lt;h3&gt;Input Required&lt;/h3&gt;\n      &lt;p&gt;{inputRequest.prompt}&lt;/p&gt;\n\n      {/* For choice-based input */}\n      {inputRequest.options &amp;&amp; (\n        &lt;div className=\"options\"&gt;\n          {inputRequest.options.map(option =&gt; (\n            &lt;button\n              key={option.id}\n              onClick={() =&gt; respond(option.id)}\n            &gt;\n              {option.label}\n            &lt;/button&gt;\n          ))}\n        &lt;/div&gt;\n      )}\n\n      {/* For text input */}\n      {inputRequest.type === \"text\" &amp;&amp; (\n        &lt;form onSubmit={(e) =&gt; {\n          e.preventDefault()\n          const input = e.currentTarget.elements.namedItem(\"input\")\n          respond((input as HTMLInputElement).value)\n        }}&gt;\n          &lt;input name=\"input\" autoFocus /&gt;\n          &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n        &lt;/form&gt;\n      )}\n    &lt;/div&gt;\n  )\n}\n</code></pre>"},{"location":"guides/react-integration/#session-management","title":"Session Management","text":""},{"location":"guides/react-integration/#multiple-sessions","title":"Multiple Sessions","text":"<p>Manage multiple concurrent workflow sessions:</p> <pre><code>import {\n  useSession,\n  useSessionList,\n  useCreateSession\n} from \"@open-harness/client\"\n\nfunction SessionManager() {\n  const { sessions, activeSessionId, setActiveSession } = useSessionList()\n  const { createSession } = useCreateSession()\n\n  return (\n    &lt;div className=\"session-manager\"&gt;\n      &lt;button onClick={() =&gt; createSession({ workflow: \"chat\" })}&gt;\n        New Chat\n      &lt;/button&gt;\n\n      &lt;div className=\"session-list\"&gt;\n        {sessions.map(session =&gt; (\n          &lt;div\n            key={session.id}\n            className={session.id === activeSessionId ? \"active\" : \"\"}\n            onClick={() =&gt; setActiveSession(session.id)}\n          &gt;\n            {session.name || session.id.slice(0, 8)}\n            &lt;span className=\"status\"&gt;{session.status}&lt;/span&gt;\n          &lt;/div&gt;\n        ))}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre>"},{"location":"guides/react-integration/#session-persistence","title":"Session Persistence","text":"<p>Resume sessions across page reloads:</p> <pre><code>import { useResumeSession } from \"@open-harness/client\"\n\nfunction SessionRestorer() {\n  const { resumeSession, isResuming } = useResumeSession()\n\n  useEffect(() =&gt; {\n    const savedSessionId = localStorage.getItem(\"sessionId\")\n    if (savedSessionId) {\n      resumeSession(savedSessionId)\n    }\n  }, [])\n\n  if (isResuming) {\n    return &lt;div&gt;Restoring session...&lt;/div&gt;\n  }\n\n  return null\n}\n</code></pre>"},{"location":"guides/react-integration/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"guides/react-integration/#optimistic-updates","title":"Optimistic Updates","text":"<p>Show immediate feedback while waiting for AI:</p> <pre><code>function OptimisticChat() {\n  const { state, actions } = useWorkflow&lt;ChatState&gt;()\n  const [optimisticMessage, setOptimisticMessage] = useState&lt;string | null&gt;(null)\n\n  const sendMessage = async (text: string) =&gt; {\n    // Show message immediately\n    setOptimisticMessage(text)\n\n    // Start workflow\n    await actions.start(text)\n\n    // Clear optimistic state (real state will have it)\n    setOptimisticMessage(null)\n  }\n\n  return (\n    &lt;div&gt;\n      {state?.messages.map((m, i) =&gt; (\n        &lt;Message key={i} {...m} /&gt;\n      ))}\n      {optimisticMessage &amp;&amp; (\n        &lt;Message role=\"user\" content={optimisticMessage} pending /&gt;\n      )}\n    &lt;/div&gt;\n  )\n}\n</code></pre>"},{"location":"guides/react-integration/#forking-workflows","title":"Forking Workflows","text":"<p>Create branches for \"what if\" scenarios:</p> <pre><code>function ForkableChat() {\n  const { state, actions, sessionId } = useWorkflow&lt;ChatState&gt;()\n  const { createSession } = useCreateSession()\n\n  const forkFromHere = async () =&gt; {\n    // Create a new session forked from current point\n    const forked = await createSession({\n      workflow: \"chat\",\n      forkFrom: sessionId,\n      forkAtEvent: state.events.length - 1\n    })\n\n    // Navigate to forked session\n    window.open(`/chat/${forked.id}`, \"_blank\")\n  }\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick={forkFromHere}&gt;\n        Fork conversation\n      &lt;/button&gt;\n      {/* ... rest of UI */}\n    &lt;/div&gt;\n  )\n}\n</code></pre>"},{"location":"guides/react-integration/#error-boundaries","title":"Error Boundaries","text":"<p>Handle workflow errors gracefully:</p> <pre><code>import { useWorkflowError } from \"@open-harness/client\"\n\nfunction ErrorHandler() {\n  const { error, clearError, retry } = useWorkflowError()\n\n  if (!error) return null\n\n  return (\n    &lt;div className=\"error-banner\"&gt;\n      &lt;p&gt;Something went wrong: {error.message}&lt;/p&gt;\n      &lt;button onClick={retry}&gt;Retry&lt;/button&gt;\n      &lt;button onClick={clearError}&gt;Dismiss&lt;/button&gt;\n    &lt;/div&gt;\n  )\n}\n\n// Wrap your app\nfunction App() {\n  return (\n    &lt;WorkflowClientProvider url=\"...\"&gt;\n      &lt;ErrorHandler /&gt;\n      &lt;MainContent /&gt;\n    &lt;/WorkflowClientProvider&gt;\n  )\n}\n</code></pre>"},{"location":"guides/react-integration/#server-setup","title":"Server Setup","text":"<p>The React client needs a running Open Harness server. Here's a minimal setup:</p> <pre><code>// server.ts\nimport { createServer } from \"@open-harness/server\"\nimport { myWorkflow } from \"./workflows\"\n\nconst server = createServer({\n  port: 42069,\n  workflows: {\n    \"my-workflow\": myWorkflow\n  }\n})\n\nserver.start()\nconsole.log(\"Server running at http://localhost:42069\")\n</code></pre> <p>Run your server:</p> <pre><code>bun run server.ts\n</code></pre> <p>The server exposes:</p> <ul> <li>HTTP endpoints for session management</li> <li>SSE streams for real-time updates</li> <li>WebSocket (optional) for bidirectional communication</li> </ul>"},{"location":"guides/react-integration/#typescript-support","title":"TypeScript Support","text":"<p>All hooks are fully typed. Define your state types for autocomplete:</p> <pre><code>// types.ts\nexport interface MyWorkflowState {\n  topic: string\n  findings: Array&lt;{\n    fact: string\n    source: string\n  }&gt;\n  summary: string | null\n  status: \"researching\" | \"summarizing\" | \"complete\"\n}\n\n// Component.tsx\nimport { useWorkflow } from \"@open-harness/client\"\nimport { MyWorkflowState } from \"./types\"\n\nfunction ResearchPanel() {\n  const { state } = useWorkflow&lt;MyWorkflowState&gt;()\n\n  // state is fully typed!\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Researching: {state?.topic}&lt;/h2&gt;\n      &lt;ul&gt;\n        {state?.findings.map((f, i) =&gt; (\n          &lt;li key={i}&gt;{f.fact}&lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre>"},{"location":"guides/react-integration/#hook-reference","title":"Hook Reference","text":"Hook Purpose <code>useWorkflow</code> Primary hook - state, status, actions, streaming <code>useWorkflowState</code> Read-only state access with selectors <code>useCreateSession</code> Create new workflow sessions <code>useTextStream</code> Real-time text streaming <code>useThinkingStream</code> Extended thinking content (Claude models) <code>usePhase</code> Current phase and transitions <code>useWorkflowEvents</code> Subscribe to all events <code>useInputRequest</code> Human-in-the-loop input handling <code>useSession</code> Current session info <code>useSessionList</code> Multiple session management <code>useResumeSession</code> Resume existing sessions <code>useWorkflowError</code> Error handling <code>useFork</code> Fork workflow sessions"},{"location":"guides/react-integration/#summary","title":"Summary","text":"<ol> <li>Wrap with Provider \u2014 <code>WorkflowClientProvider</code> connects to your server</li> <li>Use Hooks \u2014 <code>useWorkflow</code> for full control, specialized hooks for specific needs</li> <li>Stream in Real-Time \u2014 <code>useTextStream</code> shows AI responses as they generate</li> <li>Handle Input \u2014 <code>useInputRequest</code> for human-in-the-loop flows</li> <li>Manage Sessions \u2014 Create, list, resume, and fork sessions</li> </ol> <p>Next Steps</p> <ul> <li>Building Workflows \u2014 Server-side workflow patterns</li> <li>API Reference \u2014 Complete hook documentation</li> </ul>"},{"location":"guides/react-integration/#related","title":"Related","text":"<ul> <li>Getting Started \u2014 Install and run your first workflow</li> <li>Concepts: Events \u2014 Understand the event system</li> <li>Building Workflows \u2014 Create the workflows your UI consumes</li> </ul>"}]}