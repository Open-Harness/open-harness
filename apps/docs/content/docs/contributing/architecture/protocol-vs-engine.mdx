---
title: Protocol vs Engine
description: Understanding the protocol/implementation split
---

# Protocol vs Engine

Open Harness separates interfaces (protocol) from implementations (engine). This pattern is fundamental to the codebase.

## The Split

### Protocol (src/protocol/)

Type definitions and interfaces:

```typescript
// src/protocol/hub.ts
export interface Hub {
  emit(event: BaseEvent): void;
  subscribe(filter: EventFilter, listener: EventListener): () => void;
  scoped<T>(context: Partial<EventContext>, fn: () => T): T;
  current(): EventContext;
  send(message: string): void;
  reply(promptId: string, response: UserResponse): void;
  abort(reason?: string): void;
}
```

Protocol files define **what** something does, not **how**.

### Engine (src/engine/)

Concrete implementations:

```typescript
// src/engine/hub.ts
export class HubImpl implements Hub {
  private readonly listeners: ListenerEntry[] = [];
  private readonly _context = new AsyncLocalStorage<EventContext>();

  emit(event: BaseEvent): void {
    const context = this.current();
    const enriched = createEnrichedEvent(event, context);
    for (const { filter, listener } of this.listeners) {
      if (matchesFilter(event.type, filter)) {
        listener(enriched);
      }
    }
  }
  // ...
}
```

Engine files define **how** things work.

### Flow (src/flow/)

The flow runtime is also implementation, but separated by concern:

```
src/flow/
├── parser.ts      # YAML parsing
├── compiler.ts    # Flow compilation
├── executor.ts    # Flow execution
├── registry.ts    # Node registry
├── bindings.ts    # Binding resolution
├── when.ts        # Condition evaluation
└── validator.ts   # Schema validation
```

## Why This Pattern?

### Clear Contracts

Protocol files are contracts. They tell you:
- What methods exist
- What parameters they take
- What they return

```typescript
// Reading this tells you what Hub does
// without knowing implementation details
interface Hub {
  emit(event: BaseEvent): void;
}
```

### Testability

Mock implementations become trivial:

```typescript
// Test with a mock hub
const mockHub: Hub = {
  emit: jest.fn(),
  subscribe: jest.fn(() => () => {}),
  // ...
};
```

### Swappable Implementations

Different implementations for different contexts:

```typescript
// Production
const hub = new HubImpl();

// Testing
const hub = new TestHubImpl();

// Different behavior, same interface
```

### Dependency Inversion

Depend on abstractions, not concretions:

```typescript
// Good: depends on interface
function process(hub: Hub) { ... }

// Not ideal: depends on implementation
function process(hub: HubImpl) { ... }
```

## Interface → Implementation Mapping

| Protocol | Implementation |
|----------|----------------|
| `protocol/hub.ts` → `Hub` | `engine/hub.ts` → `HubImpl` |
| `protocol/flow.ts` → `FlowYaml` | `flow/executor.ts` → `executeFlow` |
| `protocol/events.ts` → types | `engine/events.ts` → utilities |
| `protocol/agent.ts` → `AgentDefinition` | `providers/*.ts` → implementations |
| `protocol/channel.ts` → `ChannelDefinition` | External packages |
| `protocol/flow.ts` → types | `flow/*.ts` → runtime |

## Navigation

### Finding Interfaces

```typescript
// What can Hub do?
import type { Hub } from "../protocol/hub";

// What events exist?
import type { BaseEvent } from "../protocol/events";
```

### Finding Implementations

```typescript
// How does Hub work?
import { HubImpl, createHub } from "../engine/hub";

// How does flow execution work?
import { executeFlow } from "../flow/executor";
```

## Contributing to Protocol

### When to Modify Protocol

- Adding new capability to an interface
- Defining new types used by multiple files
- Changing the contract (breaking change)

### Backward Compatibility

Protocol changes can be breaking:

```typescript
// Breaking: removing method
interface Hub {
  emit(event: BaseEvent): void;
  // subscribe removed!
}

// Non-breaking: adding method
interface Hub {
  emit(event: BaseEvent): void;
  subscribe(...): void;
  newMethod(): void;  // added
}
```

### Process

1. Discuss in issue first
2. Update protocol files
3. Update all implementations
4. Update all tests
5. Document in changelog

## Examples

### Adding a Hub Method

1. **Protocol first**:

```typescript
// protocol/hub.ts
interface Hub {
  // existing methods...

  // New method
  broadcast(event: BaseEvent): void;
}
```

2. **Then implementation**:

```typescript
// engine/hub.ts
class HubImpl implements Hub {
  // existing methods...

  broadcast(event: BaseEvent): void {
    // implementation
  }
}
```

3. **Then tests**:

```typescript
test("broadcast sends to all listeners", () => {
  const hub = createHub();
  // test implementation
});
```

### Adding a New Interface

1. **Create protocol file**:

```typescript
// protocol/new-thing.ts
export interface NewThing {
  doStuff(): void;
}
```

2. **Export from protocol index** (if needed):

```typescript
// protocol/index.ts
export * from "./new-thing";
```

3. **Create implementation**:

```typescript
// engine/new-thing.ts
import type { NewThing } from "../protocol/new-thing";

export class NewThingImpl implements NewThing {
  doStuff(): void { ... }
}
```

## Next Steps

- [Reading Specs](/docs/contributing/specifications/reading-specs) - Internal specifications
- [Directory Layout](/docs/contributing/architecture/directory-layout) - Full structure
- [Development Workflow](/docs/contributing/development/workflow) - Making changes
