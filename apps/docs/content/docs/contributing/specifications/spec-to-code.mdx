---
title: Spec to Code
description: Implementing features from specifications
---

# Spec to Code

This guide covers the process of implementing features based on specifications.

## Spec-First Development

### The Process

1. **Read spec** - Understand the requirement
2. **Write test spec** - Document test cases
3. **Write tests** - Implement test cases
4. **Implement** - Write the code
5. **Verify** - Ensure tests pass

### Why Spec-First?

- Requirements are clear before coding
- Tests exist before implementation
- Less back-and-forth
- Better coverage

## Step 1: Read the Spec

### Extract Requirements

From spec:

```markdown
### 4.2 Binding Resolution

The resolver MUST support the following path syntax:
- `flow.input.field` - Flow input field
- `nodeId.output.field` - Node output field
- `nodeId.output.array.0` - Array index access

The resolver MUST throw for missing required paths.
The resolver MUST return empty string for optional paths (`?`).
The resolver MUST return default for paths with `| default:value`.
```

Extract as checklist:
- [ ] Support flow.input.field
- [ ] Support nodeId.output.field
- [ ] Support array index access
- [ ] Throw for missing required paths
- [ ] Return empty for optional paths
- [ ] Return default for default paths

### Identify Edge Cases

Think about boundaries:
- What if path is empty?
- What if array index is out of bounds?
- What about nested arrays?
- What about null values?

## Step 2: Write Test Spec

### Create Test Spec File

```markdown
<!-- tests/spec/bindings.test-spec.md -->

# Binding Resolution Test Specification

## From: docs/spec/flow.md Section 4.2

### BIND-001: Path Syntax

**Requirement**: Resolver MUST support path syntax.

**Test Cases**:
1. Resolves flow.input.field
2. Resolves nodeId.output.field
3. Resolves array indices
4. Resolves nested paths

### BIND-002: Missing Path Handling

**Requirement**: Resolver MUST throw for missing required paths.

**Test Cases**:
1. Throws for missing path
2. Error includes path name
3. Throws for null intermediate

### BIND-003: Optional Paths

**Requirement**: Resolver MUST return empty for optional paths.

**Test Cases**:
1. Returns empty string for missing optional
2. Returns value if optional exists
```

## Step 3: Write Tests

### Implement Test Cases

```typescript
// tests/unit/bindings.test.ts

import { test, expect, describe } from "bun:test";
import { resolveBindings } from "../../src/flow/bindings";

// BIND-001: Path Syntax
describe("BIND-001: Path Syntax", () => {
  const context = {
    flow: { input: { name: "Alice", items: ["a", "b"] } },
    step1: { output: { value: 42 } }
  };

  test("resolves flow.input.field", () => {
    expect(resolveBindings("{{flow.input.name}}", context))
      .toBe("Alice");
  });

  test("resolves nodeId.output.field", () => {
    expect(resolveBindings("{{step1.output.value}}", context))
      .toBe(42);
  });

  test("resolves array indices", () => {
    expect(resolveBindings("{{flow.input.items.0}}", context))
      .toBe("a");
  });
});

// BIND-002: Missing Path Handling
describe("BIND-002: Missing Path Handling", () => {
  const context = { flow: { input: {} } };

  test("throws for missing path", () => {
    expect(() => resolveBindings("{{flow.input.missing}}", context))
      .toThrow();
  });

  test("error includes path name", () => {
    expect(() => resolveBindings("{{flow.input.missing}}", context))
      .toThrow(/flow\.input\.missing/);
  });
});

// BIND-003: Optional Paths
describe("BIND-003: Optional Paths", () => {
  test("returns empty for missing optional", () => {
    const context = { flow: { input: {} } };
    expect(resolveBindings("{{?flow.input.missing}}", context))
      .toBe("");
  });

  test("returns value if optional exists", () => {
    const context = { flow: { input: { name: "Bob" } } };
    expect(resolveBindings("{{?flow.input.name}}", context))
      .toBe("Bob");
  });
});
```

### Run Tests (Should Fail)

```bash
bun test tests/unit/bindings.test.ts
# Expected: tests fail (not implemented yet)
```

## Step 4: Implement

### Write Implementation

```typescript
// src/flow/bindings.ts

export function resolveBindings(
  template: string,
  context: BindingContext
): unknown {
  return template.replace(BINDING_PATTERN, (_, path) => {
    const isOptional = path.startsWith("?");
    const actualPath = isOptional ? path.slice(1) : path;

    const [defaultValue, pathWithoutDefault] = extractDefault(actualPath);

    try {
      return resolvePath(pathWithoutDefault, context);
    } catch (error) {
      if (isOptional) return "";
      if (defaultValue !== undefined) return defaultValue;
      throw error;
    }
  });
}

function resolvePath(path: string, context: BindingContext): unknown {
  const parts = path.split(".");
  let current: unknown = context;

  for (const part of parts) {
    if (current === null || current === undefined) {
      throw new Error(`Missing binding path: ${path}`);
    }
    current = (current as Record<string, unknown>)[part];
  }

  if (current === undefined) {
    throw new Error(`Missing binding path: ${path}`);
  }

  return current;
}
```

## Step 5: Verify

### Run Tests

```bash
bun test tests/unit/bindings.test.ts
# Expected: all tests pass
```

### Check Coverage

```bash
bun test --coverage tests/unit/bindings.test.ts
```

### Review Traceability

Ensure each spec requirement has a test:

| Spec Requirement | Test Spec | Test File |
|------------------|-----------|-----------|
| Path syntax | BIND-001 | ✓ |
| Missing paths | BIND-002 | ✓ |
| Optional paths | BIND-003 | ✓ |

## Handling Gaps

### When Spec is Unclear

1. Check existing implementation for behavior
2. Check tests for expected behavior
3. Ask in issue/discussion
4. Document assumption and proceed

### When Implementation Differs

If existing code differs from spec:

1. Determine which is correct
2. If spec is correct: fix implementation
3. If code is correct: update spec
4. Document decision

### When Adding to Spec

If implementing something not in spec:

1. Consider if spec should be updated
2. If yes, update spec first
3. Then implement with tests

## Documentation Links

### In Tests

```typescript
// Implements: docs/spec/flow.md Section 4.2
// Test Spec: tests/spec/bindings.test-spec.md BIND-001
describe("BIND-001: Path Syntax", () => {
```

### In Implementation

```typescript
// src/flow/bindings.ts

/**
 * Resolves binding expressions in a template string.
 *
 * @see docs/spec/flow.md Section 4.2
 */
export function resolveBindings(
```

## Next Steps

- [Traceability](/contributing/specifications/traceability) - Tracking
- [Reading Specs](/contributing/specifications/reading-specs) - Understanding
- [Conformance Testing](/contributing/development/conformance) - Testing
