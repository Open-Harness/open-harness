---
title: Your First Agent
description: Build a multi-node flow with conditions and state
---

# Your First Agent

Build a task triage agent that routes work based on priority.

## What You'll Build

A flow that:
- Classifies incoming tasks as `urgent` or `normal`
- Branches based on that classification
- Tracks how many runs have executed

```
┌──────────────┐
│  task.triage │
└──────┬───────┘
       │
  ┌────┴─────┐
  │          │
┌─▼──────┐ ┌─▼──────┐
│ urgent │ │ normal │
└────────┘ └────────┘
```

## Step 01: Define the Flow

Create `flow.yaml`:

```yaml title="flow.yaml"
name: task-triage
state:
  initial:
    runs: 0
nodes:
  - id: triage
    type: task.triage
    input:
      text: "{{ flow.input.text }}"

  - id: urgent
    type: echo
    input:
      text: "URGENT: {{ triage.summary }} (run {{ state.runs }})"

  - id: normal
    type: echo
    input:
      text: "Next up: {{ triage.summary }} (run {{ state.runs }})"

edges:
  - from: triage
    to: urgent
    when: "triage.priority = 'urgent'"

  - from: triage
    to: normal
    when: "triage.priority = 'normal'"
```

## Step 02: Create the Agent Node

Create `run.ts`:

```typescript title="run.ts"
import { createHarness, parseFlowYaml, echoNode } from "@open-harness/server";
import { readFileSync } from "node:fs";

type TriageInput = { text: string };
type TriageOutput = { priority: "urgent" | "normal"; summary: string };

const triageNode = {
  type: "task.triage" as const,
  run: async (ctx, input: TriageInput): Promise<TriageOutput> => {
    const normalized = input.text.toLowerCase();
    const priority =
      normalized.includes("urgent") || normalized.includes("asap")
        ? "urgent"
        : "normal";

    // Track run count in state
    const runs = Number(ctx.state.get("runs") ?? 0) + 1;
    ctx.state.set("runs", runs);

    return {
      priority,
      summary: input.text.slice(0, 80),
    };
  },
};

const flow = parseFlowYaml(readFileSync("flow.yaml", "utf-8"));

const harness = createHarness({
  flow,
  registry: {
    [triageNode.type]: triageNode,
    [echoNode.type]: echoNode,
  },
  onEvent: (event) => {
    if (event.type === "node:complete") {
      console.log(`[${event.nodeId}]`, event.output);
    }
  },
});

const snapshot = await harness.run({
  text: "ASAP: reset production password for the admin user",
});

console.log("Final outputs:", snapshot.outputs);
```

Run it:

```bash
bun run run.ts
```

Expected output:

```
[triage] { priority: "urgent", summary: "ASAP: reset production password..." }
[urgent] { text: "URGENT: ASAP: reset production password... (run 1)" }
Final outputs: { triage: { ... }, urgent: { ... } }
```

## How the Flow Works

- **Conditional logic**: `when` on edges routes to `urgent` or `normal`
- **State management**: `ctx.state` tracks the total run count
- **Multi-node orchestration**: one node makes a decision, another responds

<Callout type="stuck" title="Are you stuck?">
**Error: Node type 'task.triage' not found**
Make sure you pass the `triageNode` in the `registry` option.

**Both urgent and normal run**
Check your `when` conditions - they should be mutually exclusive.
</Callout>

## When to Use Agents vs Simple Nodes

- Use **agents** (LLM-backed nodes like `claude.agent`) when you need reasoning,
  natural language, or complex analysis
- Use **simple nodes** for deterministic transforms, validation, or routing

## Next Steps

- [Multi-Agent Flow](/docs/learn/multi-agent-flow) — Chain multiple Claude agents
- [Data Bindings](/docs/guides/expressions/bindings) — Pass data between nodes
- [Conditional Expressions](/docs/guides/expressions/conditionals) — Branch flows

