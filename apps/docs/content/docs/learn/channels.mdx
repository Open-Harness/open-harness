---
title: Channels
description: Build I/O adapters for interactive flows
---

# Channels

Channels bridge Open Harness with the outside world - terminals, web sockets, APIs. In this tutorial, we'll build a console channel for interactive AI workflows.

## What You'll Build

A console channel that:
- Displays agent output in the terminal
- Reads user input from stdin
- Creates an interactive conversation loop

## Understanding Channels

A channel is an adapter that:
- **Observes events** from the Hub
- **Injects commands** back to the workflow
- **Manages I/O** with external systems

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│    Workflow     │────▶│      Hub        │────▶│    Channel      │
│   (events out)  │     │                 │     │  (to terminal)  │
│                 │◀────│                 │◀────│  (from stdin)   │
│   (commands in) │     │                 │     │                 │
└─────────────────┘     └─────────────────┘     └─────────────────┘
```

## Step 1: Create a Simple Channel

Create `channels/console.ts`:

```typescript
import type { ChannelDefinition } from "@open-harness/kernel";

export const consoleChannel: ChannelDefinition = {
  name: "console",

  // Handle specific event types
  on: {
    "agent:text": (ctx) => {
      process.stdout.write(ctx.event.event.content);
    },

    "narrative": (ctx) => {
      console.log(`\n[${ctx.event.event.text}]\n`);
    },

    "session:complete": () => {
      console.log("\n--- Session Complete ---\n");
    }
  }
};
```

This channel:
- Subscribes to specific events via `on` handlers
- Writes agent text directly to stdout
- Formats narrative events with brackets

## Step 2: Use the Channel

```typescript
import { defineHarness } from "@open-harness/kernel";
import { consoleChannel } from "./channels/console";

const harness = defineHarness({
  channels: [consoleChannel],
  agents: [myAgent]
});

const instance = harness.create();
await instance.run({ prompt: "Hello!" });
```

## Step 3: Handle Output Events

Enhance the channel to format output nicely:

```typescript
export const prettyConsoleChannel: ChannelDefinition = {
  name: "console",

  on: {
    "agent:text": (ctx) => {
      process.stdout.write(ctx.event.event.content);
    },

    "narrative": (ctx) => {
      console.log(`\n[${ctx.event.event.text}]`);
    },

    "task:start": (ctx) => {
      console.log(`\n▶ Starting: ${ctx.event.event.taskId}`);
    },

    "task:complete": (ctx) => {
      console.log(`✓ Complete: ${ctx.event.event.taskId}`);
    },

    "task:failed": (ctx) => {
      console.log(`✗ Failed: ${ctx.event.event.taskId}`);
    }
  }
};
```

## Step 4: Inject User Input

Channels can send commands back to the workflow:

```typescript
import * as readline from "readline";

interface ConsoleState {
  rl: readline.Interface;
}

export const interactiveChannel: ChannelDefinition<ConsoleState> = {
  name: "interactive-console",

  state: () => ({
    rl: null!
  }),

  onStart: (ctx) => {
    ctx.state.rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });

    ctx.state.rl.on("line", (input) => {
      ctx.hub.send(input);
    });

    console.log("Interactive mode. Type messages to send to the agent.\n");
  },

  onComplete: (ctx) => {
    ctx.state.rl.close();
  },

  on: {
    "agent:text": (ctx) => {
      process.stdout.write(ctx.event.event.content);
    },

    "session:prompt": (ctx) => {
      const { question, choices } = ctx.event.event;
      console.log(`\n? ${question}`);
      if (choices) {
        choices.forEach((c, i) => console.log(`  ${i + 1}. ${c}`));
      }
      ctx.state.rl.prompt();
    }
  }
};
```

## Step 5: Full Interactive Loop

Create a complete interactive channel:

```typescript
import * as readline from "readline";

interface InteractiveState {
  rl: readline.Interface;
  pendingPrompts: Map<string, any>;
}

export const fullInteractiveChannel: ChannelDefinition<InteractiveState> = {
  name: "full-interactive",

  state: () => ({
    rl: null!,
    pendingPrompts: new Map()
  }),

  onStart: (ctx) => {
    ctx.state.rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });

    ctx.state.rl.on("line", (input) => {
      if (ctx.state.pendingPrompts.size > 0) {
        const [[promptId]] = ctx.state.pendingPrompts.entries();
        ctx.hub.reply(promptId, { content: input });
        ctx.state.pendingPrompts.delete(promptId);
      } else {
        ctx.hub.send(input);
      }
    });

    ctx.state.rl.on("SIGINT", () => {
      ctx.hub.abort("User interrupted");
      ctx.state.rl.close();
    });
  },

  onComplete: (ctx) => {
    ctx.state.rl.close();
  },

  on: {
    "agent:text": (ctx) => {
      process.stdout.write(ctx.event.event.content);
    },

    "narrative": (ctx) => {
      console.log(`\n[${ctx.event.event.text}]`);
    },

    "session:prompt": (ctx) => {
      const { promptId, question, choices } = ctx.event.event;
      ctx.state.pendingPrompts.set(promptId, ctx.event.event);

      console.log(`\n? ${question}`);
      if (choices) {
        choices.forEach((c, i) => console.log(`  ${i + 1}. ${c}`));
      }
      process.stdout.write("> ");
    },

    "session:complete": () => {
      console.log("\n[Session ended]");
    }
  }
};
```

## Understanding Bidirectional I/O

### Events Out (Hub → Channel)

Events flow from the workflow through the Hub to channels:

```typescript
on: {
  "agent:text": (ctx) => {
    // Handle output
  }
}
```

### Commands In (Channel → Hub)

Channels send commands back:

```typescript
ctx.hub.send("User's message");
ctx.hub.reply(promptId, { content: "yes" });
ctx.hub.abort("User cancelled");
```

## When to Use Channels

| Use Case | Solution |
|----------|----------|
| Terminal CLI | Console channel |
| Web UI | WebSocket channel |
| REST API | HTTP channel |
| Testing | Mock channel |

## Next Steps

- **[Testing](/learn/testing)** - Test your flows
- **[Channel Adapter Pattern](/concepts/channels/adapter-pattern)** - Concepts
- **[Bidirectional Channels](/concepts/channels/bidirectional)** - Full-duplex I/O
