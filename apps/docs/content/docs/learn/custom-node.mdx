---
title: Custom Nodes
description: Build your own node types for flows
---

# Custom Nodes

Every interesting flow needs custom logic. In this tutorial, we'll build custom node types that you can use in any flow.

## What You'll Build

A custom node that:
- Takes text input
- Transforms it (uppercase, reverse, etc.)
- Validates input and output with schemas
- Handles errors gracefully

## Understanding Node Types

A `NodeTypeDefinition` has four parts:

```typescript
{
  type: string;              // Unique identifier
  inputSchema: ZodSchema;    // Input validation
  outputSchema: ZodSchema;   // Output validation
  run: (ctx, input) => Promise<output>;  // The actual work
}
```

```
┌─────────────────────────────────────────────────────┐
│                   NodeTypeDefinition                 │
├─────────────────────────────────────────────────────┤
│                                                      │
│  type: "uppercase"                                  │
│                                                      │
│  ┌───────────────┐         ┌────────────────┐      │
│  │ inputSchema   │         │ outputSchema   │      │
│  │ { text: str } │         │ { result: str }│      │
│  └───────────────┘         └────────────────┘      │
│           │                        ▲                │
│           ▼                        │                │
│  ┌─────────────────────────────────────────┐       │
│  │              run(ctx, input)             │       │
│  │  return { result: input.text.toUpper() } │       │
│  └─────────────────────────────────────────┘       │
│                                                      │
└─────────────────────────────────────────────────────┘
```

## Step 1: Define the Node Type

Create `nodes/uppercase.ts`:

```typescript
import { z } from "zod";
import type { NodeTypeDefinition } from "@open-harness/kernel";

const InputSchema = z.object({
  text: z.string()
});

const OutputSchema = z.object({
  result: z.string(),
  originalLength: z.number()
});

type Input = z.infer<typeof InputSchema>;
type Output = z.infer<typeof OutputSchema>;

export const uppercaseNode: NodeTypeDefinition<Input, Output> = {
  type: "uppercase",
  inputSchema: InputSchema,
  outputSchema: OutputSchema,

  async run(ctx, input) {
    // Emit progress
    ctx.hub.emit({
      type: "narrative",
      text: `Uppercasing ${input.text.length} characters`
    });

    return {
      result: input.text.toUpperCase(),
      originalLength: input.text.length
    };
  }
};
```

## Step 2: Register the Node

Create `run.ts`:

```typescript
import { parseFlowYaml, executeFlow, NodeRegistry, createHub } from "@open-harness/kernel";
import { uppercaseNode } from "./nodes/uppercase";
import { readFileSync } from "fs";

// Create registry and register our node
const registry = new NodeRegistry();
registry.register(uppercaseNode);

// Load and execute flow
const yaml = readFileSync("flow.yaml", "utf-8");
const flow = parseFlowYaml(yaml);

const hub = createHub();
hub.subscribe("narrative", (e) => console.log(`[INFO] ${e.event.text}`));

const result = await executeFlow(flow, {
  input: { message: "hello world" },
  registry,
  hub
});

console.log("Output:", result.outputs);
```

## Step 3: Use in a Flow

Create `flow.yaml`:

```yaml
flow:
  name: transform-text
  version: "1.0"
  input:
    message:
      type: string

nodes:
  - id: transform
    type: uppercase
    input:
      text: "{{flow.input.message}}"

edges: []
```

Run it:

```bash
bun run run.ts
```

Output:
```
[INFO] Uppercasing 11 characters
Output: { transform: { result: 'HELLO WORLD', originalLength: 11 } }
```

## Step 4: Add Input Validation

Schemas catch bad input before execution:

```typescript
const InputSchema = z.object({
  text: z.string().min(1).max(10000)
});
```

## Step 5: Handle Errors

Add proper error handling:

```typescript
export const robustUppercaseNode: NodeTypeDefinition<Input, Output> = {
  type: "uppercase",
  inputSchema: InputSchema,
  outputSchema: OutputSchema,

  async run(ctx, input) {
    try {
      if (!input.text.trim()) {
        throw new Error("Text cannot be empty or whitespace only");
      }

      ctx.hub.emit({
        type: "narrative",
        text: `Processing: "${input.text.substring(0, 20)}..."`
      });

      return {
        result: input.text.toUpperCase(),
        originalLength: input.text.length
      };
    } catch (error) {
      ctx.hub.emit({
        type: "narrative",
        text: `Error: ${error.message}`
      });
      throw error;
    }
  }
};
```

## Step 6: Async Operations

Make a node that fetches data:

```typescript
import { z } from "zod";
import type { NodeTypeDefinition } from "@open-harness/kernel";

const FetchInputSchema = z.object({
  url: z.string().url()
});

const FetchOutputSchema = z.object({
  data: z.unknown(),
  status: z.number()
});

export const fetchNode: NodeTypeDefinition = {
  type: "fetch",
  inputSchema: FetchInputSchema,
  outputSchema: FetchOutputSchema,

  async run(ctx, input) {
    ctx.hub.emit({
      type: "narrative",
      text: `Fetching: ${input.url}`
    });

    const response = await fetch(input.url);
    const data = await response.json();

    return {
      data,
      status: response.status
    };
  }
};
```

## Best Practices

### Keep Nodes Focused

```typescript
// Good: Single responsibility
const uppercaseNode = { type: "uppercase", ... };
const lowercaseNode = { type: "lowercase", ... };

// Not ideal: Too many responsibilities
const textTransformNode = { type: "text-transform", ... };
```

### Clear Schemas

```typescript
// Good: Descriptive schema
const InputSchema = z.object({
  text: z.string().describe("Text to transform"),
  preserveSpaces: z.boolean().optional().describe("Keep multiple spaces")
});
```

### Emit Progress Events

```typescript
async run(ctx, input) {
  ctx.hub.emit({ type: "narrative", text: "Starting..." });
  // Long operation
  ctx.hub.emit({ type: "narrative", text: "Done" });
  return result;
}
```

## Next Steps

- **[Hub Events](/docs/learn/hub-events)** - Understand the event system
- **[Testing](/docs/learn/testing)** - Write tests for your nodes
- **[Node Type Definition](/docs/reference/types/node-type-definition)** - Full reference
