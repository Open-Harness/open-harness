---
title: Quickstart
description: Run your first Open Harness flow in 5 minutes
---

# Quickstart

Build your first multi-agent workflow. In five minutes, you'll see how Open Harness orchestrates agents through flows.

## What You'll Build

A flow with two nodes connected by an edge:

```
┌──────────────┐        ┌──────────────┐
│   template   │───────▶│    agent     │
│   (format)   │  edge  │   (Claude)   │
└──────────────┘        └──────────────┘
```

## Step 1: Create Project

```bash
mkdir my-first-flow && cd my-first-flow
bun init -y
bun add @open-harness/kernel
```

## Step 2: Create Your Flow

Create `flow.yaml`:

```yaml
flow:
  name: greeting-flow
  version: "1.0"
  input:
    name:
      type: string
    style:
      type: string
      default: "friendly"

nodes:
  - id: template
    type: template
    input:
      template: |
        Write a {{ flow.input.style }} greeting for {{ flow.input.name }}.
        Keep it brief (1-2 sentences).

  - id: greet
    type: agent
    input:
      prompt: "{{ template.output }}"

edges:
  - from: template
    to: greet
```

This flow:
- Declares two inputs: `name` (required) and `style` (defaults to "friendly")
- Has a **template node** that constructs the prompt
- Has an **agent node** that calls Claude
- Uses an **edge** to ensure template runs before agent
- Uses `{{ template.output }}` to pass data between nodes

## Step 3: Run It

Create `run.ts`:

```typescript
import {
  HubImpl,
  NodeRegistry,
  executeFlow,
  parseFlowYaml,
  createClaudeAgent,
} from "@open-harness/kernel";
import { readFileSync } from "fs";
import { z } from "zod";

// Load and parse the flow
const yaml = readFileSync("flow.yaml", "utf-8");
const flow = parseFlowYaml(yaml);

// Create hub for events
const hub = new HubImpl("quickstart-session");

// Subscribe to agent text events
hub.subscribe("agent:*", (event) => {
  if (event.event.type === "agent:text") {
    process.stdout.write(event.event.content);
  }
});

// Create registry with node types
const registry = new NodeRegistry();

// Template node: simple string interpolation
registry.register({
  type: "template",
  inputSchema: z.object({ template: z.string() }),
  outputSchema: z.object({ output: z.string() }),
  run: async (_ctx, input) => ({ output: input.template }),
});

// Agent node: uses Claude via SDK
const claudeAgent = createClaudeAgent();
registry.register({
  type: "agent",
  inputSchema: z.object({ prompt: z.string() }),
  outputSchema: z.object({ text: z.string() }),
  run: async (ctx, input) => {
    const result = await claudeAgent.execute({ prompt: input.prompt }, {
      hub: ctx.hub,
      runId: ctx.runId,
    });
    return { text: result.text };
  },
});

// Create execution context
const ctx = {
  hub,
  phase: async <T>(_name: string, fn: () => Promise<T>) => fn(),
  task: async <T>(_id: string, fn: () => Promise<T>) => fn(),
};

// Execute the flow
const result = await executeFlow(flow, registry, ctx, {
  name: "World",
  style: "enthusiastic",
});

console.log("\n\nFlow complete!");
console.log("Output:", result.outputs);
```

Run it:

```bash
bun run run.ts
```

## What Just Happened?

1. **Defined a multi-node flow** with template → agent orchestration
2. **Used edges** to control execution order
3. **Used JSONata bindings** (`{{ template.output }}`) to pass data
4. **Observed events** through the Hub as the flow ran

## Next Steps

- [Your First Agent](/docs/learn/your-first-agent) — Build a custom agent
- [Architecture](/docs/concepts/architecture) — Understand Hub, Flow, Channels
- [JSONata Bindings](/docs/guides/expressions/bindings) — Master expressions
