---
title: NodeTypeDefinition
description: Contract for implementing custom flow node types
---

# NodeTypeDefinition

Defines a custom node type that can be registered with NodeRegistry for flow execution.

## Definition

```typescript
interface NodeTypeDefinition<TIn, TOut> {
  type: string;
  inputSchema: ZodSchema<TIn>;
  outputSchema: ZodSchema<TOut>;
  capabilities?: NodeCapabilities;
  run(ctx: NodeRunContext, input: TIn): Promise<TOut>;
}
```

## Properties

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `type` | `string` | Yes | Unique type identifier |
| `inputSchema` | `ZodSchema<TIn>` | Yes | Zod schema for input validation |
| `outputSchema` | `ZodSchema<TOut>` | Yes | Zod schema for output validation |
| `capabilities` | `NodeCapabilities` | No | Optional capability flags |
| `run` | `function` | Yes | Execution function |

## NodeCapabilities

```typescript
interface NodeCapabilities {
  isStreaming?: boolean;
  supportsMultiTurn?: boolean;
  isLongLived?: boolean;
  isContainer?: boolean;
  createsSession?: boolean;
}
```

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `isStreaming` | `boolean` | `false` | Emits incremental output events |
| `supportsMultiTurn` | `boolean` | `false` | Can receive messages via Hub session pattern |
| `isLongLived` | `boolean` | `false` | May run indefinitely |
| `isContainer` | `boolean` | `false` | Can execute child nodes (e.g., foreach loops) |
| `createsSession` | `boolean` | `false` | Creates a fresh session scope for each iteration |

## NodeRunContext

```typescript
interface NodeRunContext {
  hub: Hub;
  runId: string;
}
```

| Property | Type | Description |
|----------|------|-------------|
| `hub` | `Hub` | Event hub for emitting events and subscribing |
| `runId` | `string` | Unique identifier for this execution |

For multi-turn nodes, subscribe to `session:message` events filtered by `runId`.

## ContainerNodeContext

Extended context for container nodes that can execute children:

```typescript
interface ContainerNodeContext extends NodeRunContext {
  executeChild: (
    nodeId: NodeId,
    input: Record<string, unknown>,
  ) => Promise<Record<string, unknown>>;
}
```

## Example: Simple Node

```typescript
import { z } from "zod";
import type { NodeTypeDefinition } from "@open-harness/kernel";

const uppercaseNode: NodeTypeDefinition<
  { text: string },
  { result: string }
> = {
  type: "uppercase",
  inputSchema: z.object({ text: z.string() }),
  outputSchema: z.object({ result: z.string() }),
  run: async (ctx, input) => {
    return { result: input.text.toUpperCase() };
  },
};
```

## Example: Streaming Node

```typescript
import { z } from "zod";
import type { NodeTypeDefinition } from "@open-harness/kernel";

const streamingNode: NodeTypeDefinition<
  { count: number },
  { items: number[] }
> = {
  type: "counter",
  inputSchema: z.object({ count: z.number() }),
  outputSchema: z.object({ items: z.array(z.number()) }),
  capabilities: {
    isStreaming: true,
  },
  run: async (ctx, input) => {
    const items: number[] = [];

    for (let i = 0; i < input.count; i++) {
      items.push(i);

      // Emit progress
      ctx.hub.emit({
        type: "narrative",
        text: `Processing item ${i + 1}/${input.count}`,
        importance: "low",
      });
    }

    return { items };
  },
};
```

## Example: Multi-Turn Node

```typescript
import { z } from "zod";
import type { NodeTypeDefinition } from "@open-harness/kernel";

const interactiveNode: NodeTypeDefinition<
  { prompt: string },
  { response: string }
> = {
  type: "interactive",
  inputSchema: z.object({ prompt: z.string() }),
  outputSchema: z.object({ response: z.string() }),
  capabilities: {
    supportsMultiTurn: true,
    isLongLived: true,
  },
  run: async (ctx, input) => {
    // Emit prompt request
    ctx.hub.emit({
      type: "session:prompt",
      promptId: ctx.runId,
      prompt: input.prompt,
      allowText: true,
    });

    // Wait for response via Hub subscription
    return new Promise((resolve) => {
      const unsubscribe = ctx.hub.subscribe("session:reply", (event) => {
        if (event.event.promptId === ctx.runId) {
          unsubscribe();
          resolve({ response: event.event.content });
        }
      });
    });
  },
};
```

## Example: Container Node

```typescript
import { z } from "zod";
import type { NodeTypeDefinition, ContainerNodeContext } from "@open-harness/kernel";

const foreachNode: NodeTypeDefinition<
  { items: unknown[]; as: string; body: string[] },
  { iterations: Array<{ item: unknown; outputs: Record<string, unknown> }> }
> = {
  type: "control.foreach",
  inputSchema: z.object({
    items: z.array(z.unknown()),
    as: z.string(),
    body: z.array(z.string()),
  }),
  outputSchema: z.object({
    iterations: z.array(z.object({
      item: z.unknown(),
      outputs: z.record(z.unknown()),
    })),
  }),
  capabilities: {
    isContainer: true,
    createsSession: true,
  },
  run: async (ctx: ContainerNodeContext, input) => {
    const iterations = [];

    for (const item of input.items) {
      const outputs: Record<string, unknown> = {};

      for (const nodeId of input.body) {
        const result = await ctx.executeChild(nodeId, { [input.as]: item });
        outputs[nodeId] = result;
      }

      iterations.push({ item, outputs });
    }

    return { iterations };
  },
};
```

## Registration

```typescript
import { NodeRegistry } from "@open-harness/kernel";

const registry = new NodeRegistry();

registry.register(uppercaseNode);
registry.register(streamingNode);
registry.register(interactiveNode);

// Use with executeFlow
const result = await executeFlow(flow, registry, ctx);
```

## Schema Validation

Input and output are validated at runtime:

```typescript
const strictNode: NodeTypeDefinition<
  { email: string; age: number },
  { valid: boolean }
> = {
  type: "validate-user",
  inputSchema: z.object({
    email: z.string().email(),
    age: z.number().min(0).max(150),
  }),
  outputSchema: z.object({
    valid: z.boolean(),
  }),
  run: async (ctx, input) => {
    // Input is guaranteed to match schema
    return { valid: input.age >= 18 };
  },
};
```

## See Also

- [NodeRegistry](/docs/reference/api/node-registry) - Register node types
- [NodeSpec](/docs/reference/types/node-spec) - Node specification in flows
- [executeFlow](/docs/reference/api/execute-flow) - Execute flows with nodes
