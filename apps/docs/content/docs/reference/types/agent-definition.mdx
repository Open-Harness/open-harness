---
title: AgentDefinition
description: Contract for implementing executable agents in flows
---

# AgentDefinition

Defines an agent that can be registered as a node type and executed within flows.

## Definition

```typescript
interface AgentDefinition<TIn = unknown, TOut = unknown> {
  name: string;
  emitsStartComplete?: boolean;
  execute(input: TIn, ctx: AgentExecuteContext): Promise<TOut>;
}
```

## Properties

| Property | Type | Required | Default | Description |
|----------|------|----------|---------|-------------|
| `name` | `string` | Yes | - | Unique agent identifier |
| `emitsStartComplete` | `boolean` | No | `false` | Agent handles its own lifecycle events |
| `execute` | `function` | Yes | - | Execution function |

## AgentExecuteContext

```typescript
interface AgentExecuteContext {
  hub: Hub;
  runId: string;
}
```

| Property | Type | Description |
|----------|------|-------------|
| `hub` | `Hub` | Event hub for emitting events and subscribing to messages |
| `runId` | `string` | Unique identifier for this execution run |

Multi-turn agents use the V2 SDK session pattern: subscribe to `session:message` events filtered by `runId`, then use `hub.send()` for each turn.

## Example: Simple Agent

```typescript
import type { AgentDefinition } from "@open-harness/kernel";

const greeterAgent: AgentDefinition<
  { name: string },
  { greeting: string }
> = {
  name: "greeter",
  execute: async (input, ctx) => {
    return { greeting: `Hello, ${input.name}!` };
  },
};
```

## Example: Agent with Events

```typescript
import type { AgentDefinition } from "@open-harness/kernel";

const processorAgent: AgentDefinition<
  { data: string[] },
  { processed: number }
> = {
  name: "processor",
  execute: async (input, ctx) => {
    let processed = 0;

    for (const item of input.data) {
      // Emit progress
      ctx.hub.emit({
        type: "narrative",
        text: `Processing: ${item}`,
        importance: "low",
      });

      processed++;
    }

    return { processed };
  },
};
```

## Example: Multi-Turn Agent

Multi-turn interaction uses the Hub session pattern:

```typescript
import type { AgentDefinition } from "@open-harness/kernel";

const chatAgent: AgentDefinition<
  { systemPrompt: string },
  { messages: string[] }
> = {
  name: "chat",
  execute: async (input, ctx) => {
    const messages: string[] = [];

    // Subscribe to incoming session messages for this run
    const unsubscribe = ctx.hub.subscribe("session:message", (event) => {
      if (event.context.runId === ctx.runId) {
        messages.push(event.event.content);

        // Respond to the message
        ctx.hub.emit({
          type: "agent:text",
          content: `Received: ${event.event.content}`,
        });
      }
    });

    // Wait for conversation to end (hub status changes)
    await waitForHubComplete(ctx.hub);
    unsubscribe();

    return { messages };
  },
};
```

## Example: Custom Lifecycle Events

When `emitsStartComplete: true`, the agent handles its own lifecycle:

```typescript
const customAgent: AgentDefinition<
  { task: string },
  { result: string }
> = {
  name: "custom",
  emitsStartComplete: true, // Handle own events
  execute: async (input, ctx) => {
    // Emit custom start
    ctx.hub.emit({
      type: "agent:start",
      agentName: "custom",
    });

    try {
      const result = await doWork(input.task);

      // Emit custom complete
      ctx.hub.emit({
        type: "agent:complete",
        agentName: "custom",
        success: true,
      });

      return { result };
    } catch (error) {
      ctx.hub.emit({
        type: "agent:complete",
        agentName: "custom",
        success: false,
      });
      throw error;
    }
  },
};
```

## Usage as Flow Node

Register agent as a node type for use in flows:

```typescript
import { NodeRegistry, executeFlow, parseFlowYaml, createHub } from "@open-harness/kernel";

const registry = new NodeRegistry();

// Register agent as node type
registry.register({
  type: "greeter",
  ...greeterAgent,
  inputSchema: z.object({ name: z.string() }),
  outputSchema: z.object({ greeting: z.string() }),
});

// Use in flow
const flow = parseFlowYaml(`
name: greeting-flow
nodes:
  - id: greet
    type: greeter
    input:
      name: "{{flow.input.userName}}"
`);

const hub = createHub();
const result = await executeFlow(flow, registry, { hub }, { userName: "Alice" });
console.log(result.outputs.greet.greeting); // "Hello, Alice!"
```

## ExecutableAgent

Within execution context, agents are wrapped as `ExecutableAgent`:

```typescript
interface ExecutableAgent<TIn = unknown, TOut = unknown> {
  name: string;
  execute(input: TIn): Promise<TOut>;
}
```

The wrapper handles:
- Lifecycle events (`agent:start`, `agent:complete`, `agent:failed`)
- Run ID generation
- Context injection

## See Also

- [createClaudeAgent](/docs/reference/api/anthropic-agent) - Claude agent provider
- [NodeTypeDefinition](/docs/reference/types/node-type-definition) - Node type contract
- [Agent Spec](/docs/reference/kernel-spec/spec/agent) - Specification
