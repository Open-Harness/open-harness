---
title: "Hub Protocol"
description: "The Hub is the **unified, bidirectional bus** that ties everything together."
---

The Hub is the **unified, bidirectional bus** that ties everything together.

## Interface

```typescript
interface Hub extends AsyncIterable&#60;EnrichedEvent&#62; &#123;
  // Events out
  subscribe(listener: EventListener): Unsubscribe;
  subscribe(filter: EventFilter, listener: EventListener): Unsubscribe;
  emit(event: BaseEvent, override?: Partial&#60;EventContext&#62;): void;
  scoped&#60;T&#62;(context: Partial&#60;EventContext&#62;, fn: () =&#62; T | Promise&#60;T&#62;): T | Promise&#60;T&#62;;
  current(): EventContext;

  // Commands in (bidirectional)
  send(message: string): void;
  sendTo(agent: string, message: string): void;
  sendToRun(runId: string, message: string): void;
  reply(promptId: string, response: UserResponse): void;
  abort(options?: PauseOptions): void;

  // Pause/Resume operations
  getAbortSignal(): AbortSignal;
  resume(sessionId: string, message: string): Promise&#60;void&#62;;
  getPausedSession(sessionId: string): SessionState | undefined;

  // Status
  readonly status: HubStatus;
  readonly sessionActive: boolean;
&#125;
```

## Events out

### `subscribe(listener)` / `subscribe(filter, listener)`

Subscribe to events. Returns an `Unsubscribe` function.

- `filter` can be `"*"`, a string pattern (e.g., `"agent:*"`), or an array of patterns
- `listener` receives `EnrichedEvent` objects

### Async iteration

The hub is async-iterable:

```typescript
for await (const event of hub) &#123;
  // process event
&#125;
```

### `emit(event, override?)`

Emit an event. The event is automatically enriched with context from the current `scoped` block.

- `override` allows overriding context fields for this specific emission

### `scoped(context, fn)`

Run a function with automatic context propagation (AsyncLocalStorage):

```typescript
await hub.scoped(&#123; phase: &#123; name: "Planning" &#125; &#125;, async () =&#62; &#123;
  // Any hub.emit(...) here inherits phase context
&#125;);
```

### `current()`

Read the inherited context from the current `scoped` block.

## Commands in (bidirectional)

### `send(message)`

Send a general message into the session. Emits `session:message`.

### `sendTo(agentName, message)`

Convenience injection targeting an agent by name. **Only safe if exactly one run of that agent is active**. Emits `session:message` with `agentName`.

### `sendToRun(runId, message)`

Run-scoped message injection. Emits a `session:message` event with the `runId`.
Agents subscribe to this event type to receive injected messages.

**Correct** way to inject when multiple agent runs may be active. The `runId` is provided by `agent:start` / `agent:complete` events.

```typescript
// Implementation
sendToRun(runId: string, message: string): void &#123;
  this.emit(&#123; type: "session:message", content: message, runId &#125;);
&#125;
```

### `reply(promptId, response)`

Answer a prompt. Used when the Flow runtime is in session mode and has emitted `session:prompt`.

### `abort(options?)`

Abort or pause the session/run.

```typescript
interface PauseOptions &#123;
  resumable?: boolean;  // If true, flow pauses instead of terminating
  reason?: string;      // Optional reason for the abort/pause
&#125;
```

- **`abort()`** or **`abort({ resumable: false })`** - Terminal abort. Status becomes `"aborted"`, emits `session:abort`.
- **`abort({ resumable: true })`** - Pausable abort. Status becomes `"paused"`, emits `flow:paused`, stores session state for later resumption.

## Pause/Resume Operations

### `getAbortSignal()`

Returns the current session's `AbortSignal` for cooperative cancellation. Executor and agent nodes check this signal between operations to support pause/resume.

```typescript
// In a node implementation:
if (ctx.hub.getAbortSignal().aborted) &#123;
  // Stop work, allow for potential resume
  return currentResult;
&#125;
```

### `resume(sessionId, message)`

Resume a paused session with an injected message.

- **Throws `SessionNotFoundError`** if sessionId doesn't exist in paused sessions
- **Throws `SessionAlreadyRunningError`** if session is already running
- **Throws `Error`** if message is empty (message is required)

```typescript
// Resume a paused flow with additional context
await hub.resume("session-123", "User approved: continue with plan B");
```

On resume:
1. Status changes to `"running"`
2. Injected message is emitted via `session:message`
3. `flow:resumed` event is emitted
4. Fresh abort signal is created for the resumed execution

### `getPausedSession(sessionId)`

Get the state of a paused session for inspection. Returns `undefined` if session doesn't exist.

```typescript
const state = hub.getPausedSession("session-123");
if (state) &#123;
  console.log(`Paused at node: $&#123;state.currentNodeId&#125;`);
  console.log(`Outputs so far: $&#123;Object.keys(state.outputs)&#125;`);
&#125;
```

## Status

- `status`: `"idle" | "running" | "paused" | "complete" | "aborted"`
- `sessionActive`: `boolean` - true if `startSession()` was called

## Key invariants

1. **One canonical bus** - everything talks to the hub
2. **Commands are always available**, but may be no-ops unless session mode is enabled
3. **Context propagation is automatic** via AsyncLocalStorage
