---
title: "Agent Protocol"
description: "Agents are executable units that emit events and return results."
---

Agents are executable units that emit events and return results.

## AgentDefinition contract

```typescript
interface AgentDefinition&#60;TIn = unknown, TOut = unknown&#62; &#123;
  name: string;
  emitsStartComplete?: boolean;
  execute(input: TIn, ctx: AgentExecuteContext): Promise&#60;TOut&#62;;
&#125;
```

### `emitsStartComplete`

If `true`, the agent implementation is responsible for emitting:
- `agent:start` (with `runId`)
- `agent:complete` (with `runId`)

This is useful for provider adapters (e.g., streaming SDKs) that want tighter control over run lifecycle events.

If `false` or omitted, the runtime emits these events automatically.

## Execute context

```typescript
interface AgentExecuteContext &#123;
  hub: Hub;
  runId: string;
&#125;
```

### `hub`

The hub for emitting events and subscribing to messages. Agents should:
- Emit `agent:*` events via `hub.emit(...)`
- Subscribe to `session:message` events for multi-turn

### `runId`

Unique ID for this particular agent execution. Used for:
- Emitting agent events with proper context
- Subscribing to `session:message` events targeted at this run

**Important**: When multiple runs of the same agent can be active concurrently, channels should:
1. Listen for `agent:start` events to get the `runId`
2. Call `hub.sendToRun(runId, message)` (not `hub.sendTo(agentName, message)`)

## Multi-turn pattern (V2 SDK)

Multi-turn agents use the V2 SDK session-based send/receive pattern:

```typescript
import &#123; Claude &#125; from "@anthropic-ai/claude-agent-sdk";

async function execute(input: AgentInput, ctx: AgentExecuteContext): Promise&#60;AgentOutput&#62; &#123;
  const client = new Claude(&#123; model: input.model &#125;);

  // Create session with maxTurns: 1 for single turn
  const session = client.session(&#123; maxTurns: 1 &#125;);

  try &#123;
    // Send initial prompt
    for await (const event of session.send(input.prompt)) &#123;
      if (event.type === "text") &#123;
        ctx.hub.emit(&#123; type: "agent:text", content: event.text, runId: ctx.runId &#125;);
      &#125;
    &#125;

    // For multi-turn, subscribe to injected messages
    const unsub = ctx.hub.subscribe("session:message", async (hubEvent) =&#62; &#123;
      if (hubEvent.event.runId === ctx.runId) &#123;
        for await (const event of session.send(hubEvent.event.content)) &#123;
          if (event.type === "text") &#123;
            ctx.hub.emit(&#123; type: "agent:text", content: event.text, runId: ctx.runId &#125;);
          &#125;
        &#125;
      &#125;
    &#125;);

    // Wait for completion signal
    await waitForDone();
    unsub();

    return result;
  &#125; finally &#123;
    // Session cleanup handled by SDK
  &#125;
&#125;
```

### Key patterns

- **session.send()**: Send a user message, returns async iterable of responses
- **hub.subscribe()**: Listen for injected messages by runId
- **maxTurns: 1**: For single-turn interactions (most common)

## Message injection

External code (channels, tests) injects messages via Hub:

```typescript
hub.sendToRun(runId, "user message");
```

This emits a `session:message` event. The agent's subscription receives it.

## ExecutableAgent (runtime view)

At runtime, workflow code sees:

```typescript
interface ExecutableAgent&#60;TIn = unknown, TOut = unknown&#62; &#123;
  name: string;
  execute(input: TIn): Promise&#60;TOut&#62;;
&#125;
```

The runtime wraps `AgentDefinition` to provide this simpler interface (no context args).

## Key invariants

1. **Agents emit events via hub** - they don't "print directly"
2. **Messages arrive via hub events** - agents subscribe to `session:message` filtered by `runId`
3. **runId is the routing key** - for run-scoped message injection
4. **Sessions are V2 SDK sessions** - with send/receive pattern
