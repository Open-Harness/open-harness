---
title: "Node Registry Protocol"
description: "The Node Registry maps `node.type` (NodeTypeId) to `NodeTypeDefinition` (TypeScript implementation)."
---

The Node Registry maps `node.type` (NodeTypeId) to `NodeTypeDefinition` (TypeScript implementation).

## NodeTypeDefinition

```typescript
interface NodeTypeDefinition&#60;TIn, TOut&#62; &#123;
  type: string;  // NodeTypeId
  inputSchema: ZodSchema&#60;TIn&#62;;
  outputSchema: ZodSchema&#60;TOut&#62;;
  capabilities?: NodeCapabilities;
  run(ctx: NodeRunContext, input: TIn): Promise&#60;TOut&#62;;
&#125;
```

### Schemas

- `inputSchema`: Zod schema for validating `node.input` (after binding resolution)
- `outputSchema`: Zod schema for validating node output

### Capabilities

```typescript
interface NodeCapabilities &#123;
  /** Emits streaming `agent:text` during run */
  isStreaming?: boolean;
  /** Supports receiving run-scoped injected messages */
  supportsInbox?: boolean;
  /** Long-lived session semantics (voice websocket, etc.) */
  isLongLived?: boolean;
  /** Agent-backed node */
  isAgent?: boolean;
}
```

Rules:
- All `agent.*` and `claude.agent` nodes set `isAgent: true`.
- Agent nodes should set `supportsInbox: true`.

### Run context

```typescript
interface NodeRunContext &#123;
  hub: Hub;
  runId: string;
  inbox?: AgentInbox;  // present if supportsInbox is true
&#125;
```

## NodeRegistry

```typescript
class NodeRegistry &#123;
  register&#60;TIn, TOut&#62;(def: NodeTypeDefinition&#60;TIn, TOut&#62;): void;
  get(type: NodeTypeId): NodeTypeDefinition&#60;any, any&#62;;
&#125;
```

### Registration

```typescript
registry.register(&#123;
  type: "claude.agent",
  inputSchema: z.object(&#123; prompt: z.string() &#125;),
  outputSchema: z.string(),
  capabilities: &#123; isStreaming: true, supportsInbox: true, isAgent: true &#125;,
  run: async (ctx, input) =&#62; &#123;
    // implementation
  &#125;,
&#125;);
```

## Node Packs (CLI registry UX)

Node packs are named bundles of node definitions used by the CLI to build the
registry from an explicit allowlist.

```ts
interface NodePack &#123;
  register(registry: NodeRegistry): void;
&#125;
```

**YAML** declares required packs:

```yaml
flow:
  name: my-flow
  nodePacks: [core, claude]
```

**oh.config.ts** allowlists implementations:

```ts
import &#123; corePack, claudePack &#125; from "@open-harness/kernel";

export const nodePacks = &#123;
  core: corePack,
  claude: claudePack,
&#125;;
```

If a flow requests a pack not present in `oh.config.ts`, the CLI fails fast with
a clear error.

## Library vs user responsibilities

### Library provides

- Engine + compiler + binding resolver
- Registry interfaces + base types
- Built-in control/utility nodes (e.g., `condition.equals`)
- Reference provider nodes (e.g., `claude.agent`)
- Transport adapters (console + websocket skeleton)

### User provides

- Domain nodes (their business logic)
- Provider presets (models/options)
- External tool servers (MCP or otherwise)
- Optional state reducers (later)

## NodeType naming

Recommended pattern: `namespace.kind`

Examples:
- `claude.agent`
- `condition.equals`
- `mcp.geo.country_info`

## Key invariants

1. **NodeType is TypeScript** - implementations are in TypeScript, not YAML
2. **Schemas are Zod** - for validation and type safety
3. **Registry is in-memory** (MVP) - later: plugin loading, namespacing, capability queries
