---
title: Signals
description: Signal types and structure reference
---

# Signals

All communication in Open Harness flows through typed signals.

## Signal Structure

```typescript
interface Signal {
  id: string;           // Unique identifier ("sig_abc123")
  name: string;         // Signal name ("analysis:complete")
  payload: unknown;     // Signal-specific data
  timestamp: string;    // ISO timestamp
  source?: {
    agent?: string;     // Emitting agent
    parent?: string;    // Parent signal ID (causality)
  };
}
```

## Workflow Signals

### workflow:start

Emitted when workflow begins:

```typescript
{
  name: "workflow:start",
  payload: {
    state: { /* initial state */ },
    agents: ["analyzer", "reviewer"],
  }
}
```

### workflow:end

Emitted when workflow completes:

```typescript
{
  name: "workflow:end",
  payload: {
    state: { /* final state */ },
    metrics: {
      durationMs: 1234,
      activations: 3,
    },
    terminatedEarly: false,
  }
}
```

## Agent Signals

### agent:activated

Emitted when an agent activates:

```typescript
{
  name: "agent:activated",
  payload: {
    agent: "analyzer",
    triggeredBy: "workflow:start",
  }
}
```

### agent:skipped

Emitted when an agent's `when` guard returns false:

```typescript
{
  name: "agent:skipped",
  payload: {
    agent: "reviewer",
    reason: "when guard returned false",
  }
}
```

### agent:completed

Emitted when an agent finishes:

```typescript
{
  name: "agent:completed",
  payload: {
    agent: "analyzer",
    output: "Analysis result...",
  }
}
```

## Harness Signals

### harness:start

Emitted when harness begins execution:

```typescript
{
  name: "harness:start",
  payload: {
    model: "claude-sonnet-4-20250514",
  }
}
```

### harness:end

Emitted when harness completes:

```typescript
{
  name: "harness:end",
  payload: {
    usage: {
      inputTokens: 150,
      outputTokens: 89,
    },
    cost: 0.0012,
    sessionId: "session_abc123",
  }
}
```

### harness:error

Emitted on harness failure:

```typescript
{
  name: "harness:error",
  payload: {
    error: "Rate limit exceeded",
    retryAfter: 30,
  }
}
```

## Text Signals

### text:delta

Streaming text chunk:

```typescript
{
  name: "text:delta",
  payload: {
    content: "The ",
  }
}
```

### text:complete

Full text after streaming:

```typescript
{
  name: "text:complete",
  payload: {
    content: "The analysis shows three key findings...",
  }
}
```

## Thinking Signals

### thinking:delta

Streaming thinking chunk (extended thinking):

```typescript
{
  name: "thinking:delta",
  payload: {
    content: "Let me consider the implications...",
  }
}
```

### thinking:complete

Full thinking content:

```typescript
{
  name: "thinking:complete",
  payload: {
    content: "...",
  }
}
```

## Tool Signals

### tool:call

Tool invocation:

```typescript
{
  name: "tool:call",
  payload: {
    id: "call_abc123",
    name: "Read",
    input: {
      path: "/src/index.ts",
    },
  }
}
```

### tool:result

Tool result:

```typescript
{
  name: "tool:result",
  payload: {
    id: "call_abc123",
    name: "Read",
    output: "file contents...",
    error: null,
  }
}
```

## State Signals

### state:\{key\}:changed

Emitted when state changes:

```typescript
{
  name: "state:analysis:changed",
  payload: {
    value: "New analysis result",
    previousValue: null,
  }
}
```

## Custom Signals

Agents emit custom signals via `emits`:

```typescript
const analyzer = agent({
  prompt: "Analyze the input",
  activateOn: ["workflow:start"],
  emits: ["analysis:complete"],
});
```

Emitted as:

```typescript
{
  name: "analysis:complete",
  payload: { /* agent output */ },
  source: { agent: "analyzer" },
}
```

## Signal Patterns

Use patterns to match signals:

| Pattern | Matches |
|---------|---------|
| `"workflow:start"` | Exact match |
| `"agent:*"` | `agent:activated`, `agent:completed`, etc. |
| `"harness:**"` | All harness signals |
| `"*:complete"` | `text:complete`, `analysis:complete`, etc. |

## Working with Signals

### Filter by Name

```typescript
const agentSignals = result.signals.filter(s => s.name.startsWith("agent:"));
```

### Extract Usage

```typescript
const harnessEnds = result.signals.filter(s => s.name === "harness:end");
const totalTokens = harnessEnds.reduce((sum, s) => {
  const usage = s.payload.usage || { inputTokens: 0, outputTokens: 0 };
  return sum + usage.inputTokens + usage.outputTokens;
}, 0);
```

### Build Causality Chain

```typescript
import { getCausalityChain } from "@open-harness/core";

const chain = getCausalityChain(result.signals, targetSignalId);
// Returns array of signals leading to target
```

## See Also

<Cards>
  <Card title="Signal System" href="/docs/concepts/event-system">
    Conceptual overview
  </Card>
  <Card title="runReactive" href="/docs/reference/api/runtime">
    Execution API
  </Card>
  <Card title="Signal Type" href="/docs/reference/types/runtime-event">
    TypeScript type definition
  </Card>
</Cards>
