---
title: Agent Execution Model
description: How agents execute within workflows
---

# Agent Execution Model

Agents are the executors in Open Harness. They do the actual work - calling LLMs, processing data, making decisions. This page explains how agents fit into the execution model.

## What is an Agent?

An agent is a named, executable unit:

```typescript
interface AgentDefinition<TIn, TOut> {
  name: string;
  execute(input: TIn, ctx: AgentExecuteContext): Promise<TOut>;
}
```

Agents:
- Take input, produce output
- Emit events during execution
- Can receive messages via inbox
- Are orchestrated by harnesses or flows

## Execution Context

When an agent executes, it receives context:

```typescript
interface AgentExecuteContext {
  hub: Hub;        // Event bus for emitting events
  inbox: AgentInbox;  // Incoming messages
  runId: string;   // Unique execution identifier
}
```

### Hub Access

Emit events during execution:

```typescript
async execute(input, ctx) {
  ctx.hub.emit({ type: "narrative", text: "Starting analysis..." });

  const result = await analyze(input);

  ctx.hub.emit({ type: "agent:text", content: result.summary });

  return result;
}
```

### Inbox Access

Receive injected messages:

```typescript
async execute(input, ctx) {
  // Check for user feedback
  const messages = ctx.inbox.drain();
  if (messages.length > 0) {
    // Incorporate feedback
  }

  // Or wait for next message
  const next = await ctx.inbox.pop();
}
```

### Run ID

Track this specific execution:

```typescript
async execute(input, ctx) {
  console.log(`Executing run: ${ctx.runId}`);
  // Use for logging, metrics, tracing
}
```

## Agent Types

### LLM Agents

Wrap language model calls:

```typescript
const chatAgent: AgentDefinition<ChatInput, ChatOutput> = {
  name: "chat",
  async execute(input, ctx) {
    ctx.hub.emit({ type: "narrative", text: "Thinking..." });

    const response = await anthropic.messages.create({
      model: "claude-sonnet-4-20250514",
      messages: input.messages
    });

    ctx.hub.emit({
      type: "agent:text",
      content: response.content[0].text
    });

    return { response: response.content[0].text };
  }
};
```

### Tool Agents

Execute tools or functions:

```typescript
const searchAgent: AgentDefinition<SearchInput, SearchOutput> = {
  name: "search",
  async execute(input, ctx) {
    ctx.hub.emit({ type: "narrative", text: `Searching for: ${input.query}` });

    const results = await searchEngine.query(input.query);

    return { results };
  }
};
```

### Composite Agents

Orchestrate other agents:

```typescript
const researchAgent: AgentDefinition<Topic, Report> = {
  name: "researcher",
  async execute(input, ctx) {
    // Phase 1: Search
    ctx.hub.emit({ type: "phase:start", name: "Search" });
    const searchResults = await searchAgent.execute({ query: input.topic }, ctx);

    // Phase 2: Analyze
    ctx.hub.emit({ type: "phase:start", name: "Analysis" });
    const analysis = await analyzeAgent.execute({ data: searchResults }, ctx);

    // Phase 3: Synthesize
    ctx.hub.emit({ type: "phase:start", name: "Synthesis" });
    const report = await synthesizeAgent.execute({ analysis }, ctx);

    return report;
  }
};
```

## Lifecycle Events

Agents can emit lifecycle events:

```typescript
const trackedAgent: AgentDefinition = {
  name: "tracked",
  emitsStartComplete: true,  // Indicates lifecycle tracking

  async execute(input, ctx) {
    // Framework emits task:start

    try {
      const result = await doWork(input);
      // Framework emits task:complete
      return result;
    } catch (error) {
      // Framework emits task:failed
      throw error;
    }
  }
};
```

The `emitsStartComplete` flag tells the harness to wrap execution with lifecycle events.

## Error Handling

### Agent Errors

Thrown errors become `task:failed` events:

```typescript
async execute(input, ctx) {
  if (!input.required) {
    throw new Error("Missing required input");
    // â†’ task:failed event emitted
  }
}
```

### Graceful Degradation

Return partial results instead of throwing:

```typescript
async execute(input, ctx) {
  try {
    return await primaryMethod(input);
  } catch (error) {
    ctx.hub.emit({
      type: "narrative",
      text: "Primary method failed, using fallback"
    });
    return await fallbackMethod(input);
  }
}
```

### Retry Logic

Implement retries within the agent:

```typescript
async execute(input, ctx) {
  for (let attempt = 1; attempt <= 3; attempt++) {
    try {
      return await unstableOperation(input);
    } catch (error) {
      ctx.hub.emit({
        type: "narrative",
        text: `Attempt ${attempt} failed, retrying...`
      });
      await delay(1000 * attempt);
    }
  }
  throw new Error("All attempts failed");
}
```

## Design Principles

### Single Responsibility

Each agent should do one thing well:

```typescript
// Good: focused agents
const fetchAgent = { name: "fetch", ... };
const parseAgent = { name: "parse", ... };
const validateAgent = { name: "validate", ... };

// Not ideal: monolithic agent
const doEverythingAgent = { name: "do-everything", ... };
```

### Stateless Execution

Agents shouldn't maintain state between calls:

```typescript
// Good: stateless
async execute(input, ctx) {
  return await process(input);
}

// Not ideal: stateful
let counter = 0;
async execute(input, ctx) {
  counter++;  // State leaks between calls
}
```

### Event-Driven Output

Emit events for observability:

```typescript
async execute(input, ctx) {
  ctx.hub.emit({ type: "narrative", text: "Starting..." });
  // Work
  ctx.hub.emit({ type: "agent:text", content: partial });
  // More work
  return result;
}
```

## Next Steps

- [Inbox Pattern](/docs/concepts/agents/inbox-pattern) - Receiving messages
- [Agent Definition](/docs/reference/types/agent-definition) - Type reference
- [Anthropic Agent](/docs/reference/api/anthropic-agent) - Built-in LLM agent
