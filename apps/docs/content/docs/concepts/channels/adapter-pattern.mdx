---
title: Channel Adapter Pattern
description: How channels bridge workflows with the outside world
---

# Channel Adapter Pattern

Channels are adapters that bridge Open Harness workflows with external systems - terminals, web sockets, REST APIs, message queues. They translate between the event-driven internal world and diverse external interfaces.

## The Problem

AI workflows need to communicate with many systems:
- Terminal for CLI tools
- WebSocket for real-time UIs
- HTTP for REST clients
- Files for logging

Each has different:
- Protocols (text streams, JSON, binary)
- Timing (sync, async, streaming)
- Conventions (request/response, pub/sub)

Without channels, workflows would be coupled to specific I/O mechanisms.

## The Solution

Channels provide a consistent adapter pattern:

```typescript
const terminalChannel: ChannelDefinition = {
  name: "terminal",
  on: {
    "agent:text": (ctx) => {
      process.stdout.write(ctx.event.event.content);
    },
    "narrative": (ctx) => {
      console.log(`[INFO] ${ctx.event.event.text}`);
    }
  }
};
```

The workflow emits events. Channels translate to external systems.

## Channel Anatomy

### Definition Structure

```typescript
interface ChannelDefinition<TState> {
  name: string;
  state?: () => TState;
  onStart?: (ctx) => void | Promise<void>;
  onComplete?: (ctx) => void | Promise<void>;
  on: Record<string, ChannelHandler<TState>>;
}
```

### Event Handlers

Each handler receives a context:

```typescript
interface ChannelContext<TState> {
  hub: Hub;
  state: TState;
  event: EnrichedEvent;
  emit: (event: BaseEvent) => void;
}
```

Handlers can:
- Read the event
- Access channel state
- Emit new events
- Call external systems

## Common Patterns

### Output Adapter

Forward events to an output system:

```typescript
const logChannel: ChannelDefinition = {
  name: "file-logger",
  state: () => ({ file: fs.openSync("log.txt", "a") }),
  on: {
    "*": (ctx) => {
      const line = JSON.stringify(ctx.event) + "\n";
      fs.writeSync(ctx.state.file, line);
    }
  },
  onComplete: (ctx) => {
    fs.closeSync(ctx.state.file);
  }
};
```

### Input Adapter

Convert external input to events:

```typescript
const webhookChannel: ChannelDefinition = {
  name: "webhook",
  onStart: (ctx) => {
    server.on("request", (req) => {
      ctx.emit({
        type: "external:webhook",
        payload: req.body
      });
    });
  }
};
```

### Bidirectional Adapter

Handle both input and output:

```typescript
const wsChannel: ChannelDefinition = {
  name: "websocket",
  state: () => ({ clients: new Set<WebSocket>() }),
  onStart: (ctx) => {
    wss.on("connection", (ws) => {
      ctx.state.clients.add(ws);
      ws.on("message", (msg) => {
        ctx.hub.send(msg.toString());
      });
    });
  },
  on: {
    "agent:text": (ctx) => {
      for (const client of ctx.state.clients) {
        client.send(JSON.stringify(ctx.event.event));
      }
    }
  }
};
```

## State Management

Channels maintain isolated state:

```typescript
const metricChannel: ChannelDefinition<{ count: number }> = {
  name: "metrics",
  state: () => ({ count: 0 }),
  on: {
    "*": (ctx) => {
      ctx.state.count++;
    }
  },
  onComplete: (ctx) => {
    console.log(`Total events: ${ctx.state.count}`);
  }
};
```

State is:
- Initialized per harness run
- Isolated between channels
- Available in all handlers
- Cleaned up on completion

## Lifecycle Hooks

### onStart

Called before workflow execution:

```typescript
onStart: (ctx) => {
  ctx.state.connection = await database.connect();
}
```

Use for:
- Opening connections
- Starting listeners
- Initializing resources

### onComplete

Called after workflow completes:

```typescript
onComplete: (ctx) => {
  await ctx.state.connection.close();
}
```

Use for:
- Closing connections
- Flushing buffers
- Cleanup

## Why Channels?

### Separation of Concerns

Workflows focus on logic. Channels focus on I/O.

```typescript
// Workflow doesn't know about terminals
hub.emit({ type: "agent:text", content: "Result" });

// Terminal channel handles the details
on: {
  "agent:text": (ctx) => {
    chalk.green(ctx.event.event.content);
  }
}
```

### Reusability

Same channel works with any workflow:

```typescript
const myChannel = terminalChannel; // Reuse for any harness
```

### Testability

Replace channels for testing:

```typescript
const testChannel: ChannelDefinition = {
  name: "test",
  state: () => ({ events: [] }),
  on: {
    "*": (ctx) => ctx.state.events.push(ctx.event)
  }
};
```

### Multiple Outputs

One workflow, many destinations:

```typescript
defineHarness({
  channels: [
    terminalChannel,
    logChannel,
    metricsChannel
  ]
});
```

## Design Rationale

### Why Not Middleware?

Middleware chains are order-dependent. Channels are parallel subscribers.

### Why State Factory?

`state: () => ({})` creates fresh state per run, avoiding shared mutable state between executions.

### Why Event Patterns?

Pattern matching (`"agent:*"`) allows handling event families without listing each type.

## Next Steps

- [Bidirectional Channels](/docs/concepts/channels/bidirectional) - Full-duplex patterns
- [Channel Definition](/docs/reference/types/channel-definition) - Type reference
- [Attach a Channel](/docs/guides/channels/attach-channel) - Practical guide
