---
title: Event System
description: Event-driven communication in Open Harness
---

# Event System

Everything in Open Harness communicates through events.

## Core Principle

> Events are the single source of truth for system state.

Instead of direct method calls, components emit and subscribe to events. This provides:

- **Observability**: See exactly what happened
- **Replay**: Reconstruct state from events
- **Decoupling**: Components don't know about each other

## Event Structure

All events share a common structure:

```typescript
interface RuntimeEvent {
  type: string;        // Category:action format
  timestamp?: Date;    // When it occurred
  runId?: string;      // Associated flow run
  nodeId?: string;     // Associated node
  [key: string]: any;  // Event-specific data
}
```

## Event Categories

### Flow Events

Track flow lifecycle:

```typescript
{ type: "flow:start", flowId, input }
{ type: "flow:complete", flowId, output }
{ type: "flow:error", flowId, error }
```

### Node Events

Track node execution:

```typescript
{ type: "node:start", nodeId }
{ type: "node:complete", nodeId, output }
```

### Agent Events

Track LLM interactions:

```typescript
{ type: "agent:start", agentName }
{ type: "agent:text", text }          // Streaming
{ type: "agent:tool_use", name, input }
{ type: "agent:complete", output }
```

## Subscribing to Events

Use `runtime.onEvent()` to subscribe:

```typescript
import { createRuntime, parseFlowYaml } from "@open-harness/server";

const runtime = createRuntime({
  flow: parseFlowYaml(yaml),
});

// Subscribe to all events
const unsubscribe = runtime.onEvent((event) => {
  console.log(event.type, event);
});

// Run the flow
await runtime.run({ question: "Hello" });

// Cleanup
unsubscribe();
```

### Filtering Events

Filter by event type:

```typescript
runtime.onEvent((event) => {
  if (event.type === "agent:text") {
    process.stdout.write(event.text);
  }
});
```

### With createHarness

Use the `onEvent` option:

```typescript
import { createHarness, parseFlowYaml } from "@open-harness/server";

const harness = createHarness({
  flow: parseFlowYaml(yaml),
  onEvent: (event) => {
    if (event.type === "agent:text") {
      process.stdout.write(event.text);
    }
  },
});
```

## Emitting Events

Nodes emit events via the context:

```typescript
const myNode = {
  type: "my.node" as const,
  run: async (ctx, input) => {
    ctx.emit({ type: "agent:text", text: "Processing..." });
    // ... do work
    return { result: "done" };
  },
};
```

## Event Persistence

Events are persisted to the RunStore:

```typescript
// Load events for a run
const events = await store.loadEvents(runId);

// Replay events
for (const event of events) {
  await processor.handle(event);
}
```

## Benefits

### Debugging

See exactly what happened:

```typescript
runtime.onEvent((e) => console.log(JSON.stringify(e)));
```

### Testing

Assert on event sequences:

```typescript
const events: RuntimeEvent[] = [];
runtime.onEvent((e) => events.push(e));

await runtime.run({ input: "test" });

expect(events).toContainEqual({
  type: "agent:complete",
  output: expect.any(Object),
});
```

### Integration

React to events for external integrations:

```typescript
runtime.onEvent(async (event) => {
  if (event.type === "agent:complete") {
    await notifySlack(event.output);
  }
});
```

## Next Steps

- [Events API](/docs/reference/api/events) — Event type reference
- [RuntimeEvent](/docs/reference/types/runtime-event) — Type definition

