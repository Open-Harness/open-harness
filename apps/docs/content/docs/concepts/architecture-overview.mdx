---
title: Architecture Overview
description: High-level system architecture of Open Harness
---

# Architecture Overview

Open Harness is a **flow-based AI system** built on two distinct layers: the **Kernel** (runtime substrate) and the **Flow** (declarative orchestration). Understanding this separation is key to using the system effectively.

## Mental Model

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              Open Harness                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   FLOW LAYER (Declarative)                                                  │
│   ┌──────────────────────────────────────────────────────────────────────┐ │
│   │  FlowSpec (YAML)  →  Compiler  →  Executor  →  Results               │ │
│   │                                                                       │ │
│   │  ┌─────────┐      ┌─────────┐      ┌─────────┐                       │ │
│   │  │  Node   │─────▶│  Node   │─────▶│  Node   │                       │ │
│   │  └─────────┘      └─────────┘      └─────────┘                       │ │
│   │       │                │                │                             │ │
│   │       ▼                ▼                ▼                             │ │
│   │   Registry          Bindings          When                            │ │
│   └──────────────────────────────────────────────────────────────────────┘ │
│                                    │                                        │
│                                    │ Events                                 │
│                                    ▼                                        │
│   KERNEL LAYER (Runtime)                                                    │
│   ┌──────────────────────────────────────────────────────────────────────┐ │
│   │                            Hub                                        │ │
│   │              ┌──────────────┴──────────────┐                         │ │
│   │              ▼                              ▼                         │ │
│   │         ┌─────────┐                   ┌──────────┐                   │ │
│   │         │ Agents  │                   │ Channels │                   │ │
│   │         └─────────┘                   └──────────┘                   │ │
│   │              │                              │                         │ │
│   │              ▼                              ▼                         │ │
│   │         Providers                    External I/O                     │ │
│   │         (Claude, GPT)                (WebSocket, Console)             │ │
│   └──────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Layer Separation

### Why Two Layers?

| Concern | Kernel | Flow |
|---------|--------|------|
| **Abstraction** | Runtime infrastructure | Workflow definition |
| **Language** | TypeScript | YAML + TypeScript |
| **Stability** | Stable core | Evolving features |
| **Responsibility** | Execute, observe, connect | Define, compile, orchestrate |

This separation means:
- **Swap flows without touching kernel code**
- **Extend kernel without breaking existing flows**
- **Test layers independently**

---

## Kernel Layer

The kernel is the **runtime substrate** — it knows how to execute things, but doesn't know what to execute.

### Hub

The Hub is the **central event bus**. All communication flows through it:

```typescript
import { HubImpl } from "@open-harness/kernel";

const hub = new HubImpl("session-123");

// Everything subscribes to the hub
hub.subscribe("agent:*", (event) => {
  console.log("Agent event:", event.event);
});

// Everything emits to the hub
hub.emit({ type: "agent:text", content: "Hello!" });
```

**Key Properties:**
- Single event envelope for all events
- Automatic context propagation (session, phase, task, agent)
- Wildcard subscriptions (`*`, `agent:*`)
- No direct printing — everything goes through hub

### Agents

Agents are **execution units** that wrap LLM providers:

```typescript
import { createClaudeAgent } from "@open-harness/kernel";

const claude = createClaudeAgent();

const result = await claude.execute(
  { prompt: "Hello!" },
  { hub, runId: "run-1" }
);
// result.text = "Hi there!"
```

**Agent Contract:**
```typescript
interface AgentDefinition<TIn, TOut> {
  name: string;
  execute(input: TIn, ctx: AgentExecuteContext): Promise<TOut>;
}
```

**Provider-Agnostic:** The kernel doesn't care if you use Claude, GPT, or a local model. Agents are adapters.

### Channels

Channels are **bidirectional I/O adapters**:

```typescript
import { defineChannel } from "@open-harness/kernel";

const consoleChannel = defineChannel({
  name: "ConsoleChannel",
  on: {
    "agent:text": ({ event }) => {
      process.stdout.write(event.content);
    },
  },
});

// Attach to hub
consoleChannel(hub);
```

**Channel Examples:**
- Console: Write agent output to terminal
- WebSocket: Stream events to browser
- Voice: Convert text to speech

**Key Invariant:** Channels attach, subscribe, and optionally return cleanup. They never "print directly" — they observe hub events.

---

## Flow Layer

The flow layer defines **what to execute** as a declarative YAML spec.

### FlowSpec

A FlowSpec is a YAML document defining:
- **Flow metadata**: Name, version, input schema
- **Nodes**: Processing steps
- **Edges**: Data dependencies

```yaml
flow:
  name: greeting-flow
  version: "1.0"
  input:
    name: { type: string }

nodes:
  - id: greet
    type: agent
    input:
      prompt: "Say hello to {{flow.input.name}}"

edges: []
```

### Node Registry

Nodes are TypeScript implementations registered at runtime:

```typescript
import { NodeRegistry } from "@open-harness/kernel";
import { z } from "zod";

const registry = new NodeRegistry();

registry.register({
  type: "agent",
  inputSchema: z.object({ prompt: z.string() }),
  outputSchema: z.object({ text: z.string() }),
  run: async (ctx, input) => {
    const result = await claude.execute({ prompt: input.prompt }, {
      hub: ctx.hub,
      runId: ctx.runId,
    });
    return { text: result.text };
  },
});
```

### Compiler

The compiler transforms FlowSpec → executable plan:

```typescript
import { compileFlow } from "@open-harness/kernel";

const compiled = compileFlow(flowYaml);
// compiled.order = [node1, node2, ...] // Topological order
// compiled.edges = [...] // Edge definitions
```

**Compiler Responsibilities:**
- Validate FlowSpec structure
- Build DAG from nodes + edges
- Determine topological execution order
- Detect cycles (not yet supported)

### Executor

The executor runs the compiled flow:

```typescript
import { executeFlow } from "@open-harness/kernel";

const result = await executeFlow(flow, registry, {
  hub,
  phase: async (name, fn) => fn(),
  task: async (id, fn) => fn(),
}, { name: "World" });

// result.outputs = { greet: { text: "Hello, World!" } }
```

**Execution Phases:**
1. Parse input overrides
2. For each node (in order):
   - Check `when` condition
   - Resolve bindings
   - Validate input schema
   - Run node
   - Emit events
   - Store output
3. Return all outputs

### Bindings

Bindings resolve data references at runtime:

```yaml
input:
  message: "{{flow.input.name}}"      # Flow input
  previous: "{{nodeA.result}}"        # Previous node output
  nested: "{{nodeB.data.field}}"      # Nested field access
```

**Resolution Order:**
1. `flow.input.*` — always available
2. `{nodeId}.*` — available after node executes

### When Conditions

Conditional node execution:

```yaml
- id: urgent-handler
  type: agent
  when: "{{classifier.priority}} == 'urgent'"
```

**Operators:** `==`, `!=`, `>`, `<`, `>=`, `<=`, `&&`, `||`, `!`

---

## Event Flow

All events follow a single path:

```
┌───────────┐     emit()     ┌─────┐     subscribe()     ┌──────────┐
│   Node    │───────────────▶│ Hub │────────────────────▶│ Channel  │
│ (emitter) │                └─────┘                     │ (observer)│
└───────────┘                   │                        └──────────┘
                                │
                                ▼
                         ┌──────────────┐
                         │ Event Log    │
                         │ (debugging)  │
                         └──────────────┘
```

### Event Envelope

All events use the same envelope:

```typescript
interface EnrichedEvent<T> {
  id: string;           // Unique event ID
  timestamp: Date;      // When it occurred
  context: {            // Hierarchical context
    sessionId: string;
    phase?: { name: string };
    task?: { id: string };
    agent?: { name: string };
  };
  event: T;             // The actual event payload
}
```

### Event Types

| Category | Events |
|----------|--------|
| **Flow** | `harness:start`, `harness:complete` |
| **Phase** | `phase:start`, `phase:complete`, `phase:failed` |
| **Node** | `node:start`, `node:complete`, `node:error`, `node:skipped` |
| **Agent** | `agent:start`, `agent:complete`, `agent:text`, `agent:thinking` |
| **Session** | `session:prompt`, `session:reply`, `session:abort` |

---

## Data Flow Example

Let's trace a simple flow:

```yaml
flow:
  name: example
  input:
    query: { type: string }

nodes:
  - id: search
    type: agent
    input:
      prompt: "Search for: {{flow.input.query}}"

  - id: summarize
    type: agent
    input:
      prompt: "Summarize: {{search.text}}"

edges:
  - from: search
    to: summarize
```

**Execution Trace:**

1. `executeFlow` called with `{ query: "cats" }`
2. Compiler produces order: `[search, summarize]`
3. **Node: search**
   - Binding: `{{flow.input.query}}` → `"cats"`
   - Run: Agent executes prompt
   - Output: `{ text: "Cats are..." }`
   - Events: `node:start`, `agent:text`, `node:complete`
4. **Edge: search → summarize fires**
5. **Node: summarize**
   - Binding: `{{search.text}}` → `"Cats are..."`
   - Run: Agent summarizes
   - Output: `{ text: "Summary: cats are furry..." }`
   - Events: `node:start`, `agent:text`, `node:complete`
6. Return: `{ outputs: { search: {...}, summarize: {...} } }`

---

## Package Structure

```
@open-harness/kernel
├── protocol/          # Type definitions (interfaces)
│   ├── events.ts      # Event types
│   ├── hub.ts         # Hub interface
│   ├── agent.ts       # Agent interface
│   └── flow.ts        # Flow types
├── engine/            # Kernel implementations
│   ├── hub.ts         # HubImpl
│   └── events.ts      # Event helpers
├── flow/              # Flow layer
│   ├── executor.ts    # executeFlow()
│   ├── compiler.ts    # compileFlow()
│   ├── bindings.ts    # resolveBindings()
│   ├── when.ts        # evaluateWhen()
│   └── registry.ts    # NodeRegistry
├── providers/         # Agent adapters
│   └── claude.ts      # createClaudeAgent()
└── channels/          # Channel implementations
    └── index.ts       # defineChannel()
```

---

## Summary

| Component | Layer | Responsibility |
|-----------|-------|----------------|
| Hub | Kernel | Event routing |
| Agent | Kernel | LLM execution |
| Channel | Kernel | External I/O |
| FlowSpec | Flow | Workflow definition |
| Registry | Flow | Node implementations |
| Compiler | Flow | FlowSpec → execution plan |
| Executor | Flow | Run the plan |
| Bindings | Flow | Data resolution |
| When | Flow | Conditional execution |

---

## Learn More

- [Kernel vs Flow](/docs/concepts/kernel-vs-flow) — Layer separation in depth
- [Event Model](/docs/concepts/event-model) — Event types and context
- [Kernel Spec](/docs/reference/kernel-spec) — Complete specification
- [Custom Nodes](/docs/learn/custom-node) — Build your own nodes
