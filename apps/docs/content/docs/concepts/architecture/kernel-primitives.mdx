---
title: Kernel Primitives
description: Understanding Hub, Agent, Channel, and Flow - the core building blocks
---

# Kernel Primitives

Open Harness is built on four composable primitives. Understanding these unlocks the entire system.

## The Four Primitives

```
┌──────────────────────────────────────────────────────────────┐
│                           Hub                                │
│              Central event bus + context                     │
│                                                              │
│    ┌─────────┐      ┌─────────┐      ┌─────────┐            │
│    │  Agent  │      │  Agent  │      │  Agent  │            │
│    │(executor)│      │(executor)│      │(executor)│            │
│    └─────────┘      └─────────┘      └─────────┘            │
│                                                              │
│    ┌─────────┐      ┌─────────┐                             │
│    │ Channel │      │ Channel │                             │
│    │  (I/O)  │      │  (I/O)  │                             │
│    └─────────┘      └─────────┘                             │
└──────────────────────────────────────────────────────────────┘
                            ↓
                     ┌──────────┐
                     │   Flow   │
                     │(orchestr)│
                     └──────────┘
```

## Hub: The Central Nervous System

The Hub is a bidirectional event bus that connects all components. Every event in the system flows through the Hub.

### What It Does

- **Events Out**: Publishes events to subscribers
- **Commands In**: Receives commands from channels
- **Context Propagation**: Maintains hierarchical context via AsyncLocalStorage

### Why It Exists

Without a central bus, components would need direct references to each other. This creates coupling and makes testing harder. The Hub provides:

- **Decoupling**: Components don't know about each other
- **Observability**: One place to see everything
- **Testing**: Record and replay event streams

### Comparison to Alternatives

| Approach | Trade-off |
|----------|-----------|
| Direct calls | Tight coupling, hard to test |
| Message queue | Overkill for in-process |
| EventEmitter | No context propagation |
| **Hub** | Right balance for AI workflows |

## Agent: The Executor

Agents are the units of work. They take input, do something (call an LLM, process data), and return output.

### What It Does

- Receives typed input
- Has access to Hub (for events) and Inbox (for messages)
- Returns typed output
- Emits events during execution

### Why This Abstraction

Agents abstract over "things that do work." Whether it's an Anthropic LLM call, a web search, or a data transformation, the interface is the same:

```typescript
interface AgentDefinition<TIn, TOut> {
  name: string;
  execute(input: TIn, ctx: AgentExecuteContext): Promise<TOut>;
}
```

This uniformity enables:
- **Composition**: Chain agents in flows
- **Testing**: Mock any agent
- **Swappability**: Replace implementations

### Comparison to Other Frameworks

| Framework | Concept |
|-----------|---------|
| LangChain | Chain/Tool |
| AutoGPT | Action |
| **Open Harness** | Agent |

Our Agent is simpler: just input→output with event hooks.

## Channel: The Adapter

Channels are I/O adapters that bridge the Hub to external systems.

### What It Does

- **Observes events**: Subscribes to Hub events
- **Injects commands**: Sends commands into Hub
- **Manages lifecycle**: Cleanup on completion

### Why Channels vs Direct I/O

Without channels, workflow code would be tangled with I/O logic:

```typescript
// Without channels (bad)
const result = await agent.execute(input);
console.log(result);  // I/O mixed with logic
sendWebSocket(result);  // More I/O
```

With channels, I/O is separated:

```typescript
// With channels (good)
hub.emit({ type: "agent:text", content: result });
// Channels handle the rest
```

### Bidirectional Pattern

Channels aren't just observers. They inject commands:

```typescript
const channel: ChannelDefinition = {
  name: "console",
  on: {
    "session:prompt": (ctx) => {
      const input = readLine(ctx.event.event.prompt);
      ctx.hub.reply(ctx.event.event.promptId, { content: input });
    }
  }
};
```

## Flow: The Orchestrator

Flow defines what happens and in what order. It's a declarative DAG (Directed Acyclic Graph) of nodes.

### What It Does

- Parses YAML flow definitions
- Validates the DAG structure
- Executes nodes in topological order
- Resolves data bindings between nodes

### Why Declarative YAML

Imperative code is flexible but:
- Hard to visualize
- Difficult to modify without breaking
- Mixes logic with orchestration

Declarative YAML:
- Clear structure at a glance
- Easy to modify
- Enables visual editing tools
- Separates "what" from "how"

### Comparison to Code-First

| Approach | Best For |
|----------|----------|
| Code-first (Harness) | Complex programmatic logic |
| YAML-first (Flow) | Standard workflows, visual editing |

Most workflows use Flow. Harness is available for edge cases.

## How They Interact

Here's a typical execution flow:

1. **Flow** parses YAML and determines node order
2. For each node:
   - **Flow** resolves input bindings
   - **Flow** invokes the registered **Agent**
   - **Agent** emits events to **Hub**
   - **Channels** observe and react
3. **Hub** propagates context through everything
4. **Flow** collects outputs and proceeds to next node

```
User Input → Channel → Hub → Flow → Agent → Hub → Channel → User Output
```

## Key Insight

The primitives are deliberately minimal:
- Hub: Event routing
- Agent: Work execution
- Channel: I/O bridging
- Flow: Orchestration

Complex behavior emerges from composition, not complex primitives.

## Next Steps

- [Event-Driven Design](/docs/concepts/architecture/event-driven) - Why events everywhere
- [Hub API](/docs/reference/api/hub) - Complete Hub reference
- [Flow Execution](/docs/guides/flows/execute-flow) - Running flows
