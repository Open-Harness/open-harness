---
title: Architecture Overview
description: High-level architecture and design philosophy of Open Harness
---

# Architecture Overview

Open Harness is an AI workflow orchestration framework built for declarative, event-driven workflows. This page explains the big picture and why the architecture exists.

## What is Open Harness?

Open Harness provides a structured way to build AI-powered applications. Rather than writing imperative code that directly calls LLM APIs and manages state, you define workflows declaratively and let the framework handle execution, event routing, and I/O.

The framework is designed for:
- **AI agents** that reason and act
- **Multi-step workflows** that chain operations
- **Interactive sessions** with human-in-the-loop
- **Multiple I/O channels** (console, GitHub, voice)

## The Big Picture

At the center of everything is the **Hub** - a bidirectional event bus that connects all components:

```
┌─────────────────────────────────────────────────────────────┐
│                         Hub                                 │
│         (events out ← → commands in)                        │
└─────────────────────────────────────────────────────────────┘
       ↑              ↑              ↑              ↑
       │              │              │              │
   ┌───┴───┐    ┌─────┴─────┐   ┌────┴────┐   ┌─────┴─────┐
   │ Flow  │    │  Agents   │   │ Channels │   │ Observers │
   │ (DAG) │    │(executors)│   │  (I/O)  │   │(logging)  │
   └───────┘    └───────────┘   └─────────┘   └───────────┘
```

**FlowRuntime** orchestrates the workflow, owning lifecycle events and session management. **Agents** do the actual work (calling LLMs, processing data). **Channels** handle external I/O (console, GitHub, voice). Everything communicates through the Hub.

## Design Philosophy

### Event-Driven Over Imperative

Rather than direct function calls, components communicate through events. When an agent produces output, it emits an event. When a user sends input, it becomes an event. This creates:

- **Observability**: Every action is visible
- **Testability**: Events can be recorded and replayed
- **Extensibility**: New components subscribe without changes

### Declarative Over Procedural

Workflows are defined as YAML DAGs (Directed Acyclic Graphs):

```yaml
flow:
  name: research-and-summarize
nodes:
  - id: research
    type: agent.claude
    input:
      prompt: "Research: {{flow.input.topic}}"
  - id: summarize
    type: agent.claude
    input:
      prompt: "Summarize: {{research.output}}"
edges:
  - from: research
    to: summarize
```

This declarative approach enables:
- **Visual editing** via n8n-style interfaces
- **Easy modification** without code changes
- **Clear data flow** between nodes

### Composable Primitives

The system is built from four composable primitives:
- **Hub**: Event routing and context propagation
- **Agent**: Executable work unit (LLM or custom)
- **Channel**: Bidirectional I/O adapter
- **Flow**: DAG-based workflow orchestration

These primitives combine in predictable ways. Understanding them unlocks the full system.

## Why This Architecture?

### Testability

AI responses are non-deterministic and API calls are slow. By routing everything through events:
- Record event streams during execution
- Replay recordings for deterministic tests
- No network calls during test runs

### Observability

With a central event bus:
- Every action is logged
- Easy debugging with full event history
- Metrics and monitoring built-in

### Extensibility

New capabilities plug in cleanly:
- Custom nodes for specific tasks
- New channels for different I/O
- Subscribers for logging, analytics, dashboards

## The Runtime

**FlowRuntime** is the orchestration layer that:

- Executes FlowSpec DAGs in topological order
- Manages lifecycle events (`harness:start/complete`, `phase:*`, `task:*`)
- Routes session messages to running agents
- Coordinates channel attachments

```typescript
import { executeFlow, createHub, createChannelAttachment } from "@open-harness/kernel";

const hub = createHub();
hub.attach(createChannelAttachment(consoleChannel));

const ctx = { hub, phase: async (n, fn) => fn(), task: async (id, fn) => fn() };
await executeFlow(flow, registry, ctx, input);
```

## Next Steps

- [Kernel Primitives](/docs/concepts/architecture/kernel-primitives) - Deep dive into Hub, Agent, Channel, Flow
- [Execution Models](/docs/concepts/execution) - Sequential and parallel execution
- [Event-Driven Design](/docs/concepts/architecture/event-driven) - Why events matter
