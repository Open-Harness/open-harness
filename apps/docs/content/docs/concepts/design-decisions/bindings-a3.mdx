---
title: A3 Binding Syntax
description: The design of the A3 binding expression language
---

# A3 Binding Syntax

Open Harness uses A3 bindings for data flow between nodes. This page explains the syntax design and why we chose it.

## The Syntax

A3 bindings use double curly braces with dot notation:

```yaml
input:
  name: "{{flow.input.userName}}"
  result: "{{step1.output.data}}"
  message: "Hello, {{flow.input.name}}!"
```

## Design Goals

### 1. Explicit Data Flow

Every data reference is visible:

```yaml
# Clear: this uses userName from flow input
name: "{{flow.input.userName}}"

# vs. implicit (what is name?)
name: userName
```

### 2. Serializable

Pure YAML, no code:

```yaml
# This is valid YAML
input:
  data: "{{step1.output}}"
```

The flow can be:
- Stored in files
- Sent over network
- Edited by non-programmers
- Validated by tools

### 3. Traceable

Follow the path to find the source:

```yaml
# path: step1.output.items.0.name
# means: step1 → output → items → [0] → name
```

### 4. Familiar

Similar to Mustache/Handlebars but simpler:

```handlebars
{{variable}}           <!-- Mustache -->
{{path.to.value}}      <!-- A3 -->
```

## Syntax Details

### Basic Path

Reference nested values:

```yaml
{{flow.input}}                    # Entire flow input
{{flow.input.user}}               # Nested object
{{flow.input.user.profile.email}} # Deep nesting
```

### Array Access

Use numeric indices:

```yaml
{{step1.output.items.0}}      # First item
{{step1.output.items.0.name}} # First item's name
```

### String Interpolation

Combine with text:

```yaml
message: "Hello, {{flow.input.name}}! Your ID is {{flow.input.id}}."
```

### Whole Value

Use binding as entire value (preserves type):

```yaml
# If flow.input.count is 42 (number), count is 42 (number)
count: "{{flow.input.count}}"
```

### Optional Binding

Use `?` prefix for optional values:

```yaml
# Empty string if missing
name: "{{?flow.input.optionalName}}"
```

### Default Value

Use `| default:` for fallbacks:

```yaml
count: "{{flow.input.count | default:0}}"
name: "{{flow.input.name | default:Anonymous}}"
```

## Why Not...

### Mustache/Handlebars

```handlebars
{{#if condition}}...{{/if}}
{{#each items}}...{{/each}}
```

Too powerful. A3 intentionally has no:
- Conditionals (use `when` expressions)
- Loops (flows handle iteration)
- Helpers (keep it simple)

### JSONPath

```
$.step1.output.items[0].name
```

More expressive but:
- Less familiar
- Overkill for our needs
- Different from template syntax

### Template Literals

```javascript
`Hello, ${flow.input.name}`
```

JavaScript-specific, not YAML-safe without escaping.

### Variables

```yaml
$step1.output
```

Single character prefix is:
- Easy to miss
- Conflicts with YAML references
- Less distinctive

## What A3 Can't Do

By design, A3 is limited:

### No Arithmetic

```yaml
# Not supported
total: "{{step1.output.a + step1.output.b}}"

# Use a node instead
- id: add
  type: calculate
  input:
    a: "{{step1.output.a}}"
    b: "{{step1.output.b}}"
```

### No Conditionals

```yaml
# Not supported
message: "{{#if premium}}Welcome!{{/if}}"

# Use when expressions
when:
  equals:
    var: flow.input.premium
    value: true
```

### No Functions

```yaml
# Not supported
formatted: "{{format(step1.output.date)}}"

# Use a node instead
- id: format
  type: formatter
  input:
    date: "{{step1.output.date}}"
```

### No Loops

```yaml
# Not supported
items: "{{#each step1.output.items}}..."

# Use a node or flow structure
```

## Design Rationale

### Keep Bindings Simple

Complex logic belongs in nodes, not bindings:

```yaml
# Binding: just data flow
input:
  data: "{{step1.output}}"

# Node: logic
- id: process
  type: processor
  input:
    data: "{{step1.output}}"
```

### Predictable Resolution

Bindings always resolve the same way:
1. Look up path in context
2. Return value or throw
3. No side effects

### Easy to Validate

Static analysis can verify:
- Path syntax is valid
- Referenced nodes exist
- Types align

### Easy to Explain

"Double braces with a dot path" - that's the whole story.

## Resolution Behavior

### When Bindings Resolve

Bindings resolve at execution time, just before each node runs:

1. Node is about to execute
2. Context is built (flow.input + previous outputs)
3. All bindings in node input are resolved
4. Resolved input passed to node

### Missing Paths

By default, missing paths throw:

```
Error: Missing binding path: flow.input.missing
```

Use optional syntax to handle gracefully:

```yaml
# Returns empty string if missing
name: "{{?flow.input.missing}}"

# Returns default if missing
count: "{{flow.input.missing | default:0}}"
```

### Type Coercion

In string interpolation, values become strings:

```yaml
# count = 42, becomes "Count: 42"
message: "Count: {{flow.input.count}}"
```

As whole value, types are preserved:

```yaml
# count = 42, remains number
count: "{{flow.input.count}}"
```

## Next Steps

- [Binding System](/docs/concepts/flows/binding-system) - Data flow concepts
- [A3 Syntax Reference](/docs/reference/bindings/a3-syntax) - Complete reference
- [Binding Errors](/docs/reference/bindings/binding-errors) - Error handling
