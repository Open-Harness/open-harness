---
title: WebSocket Transport
description: Stream events to browser clients via WebSocket
---

# WebSocket Transport

Connect browser clients to your flows via WebSocket for real-time streaming.

## Server Setup

Use `createHarness()` with the `transport.websocket` option:

```typescript title="server.ts"
import { createHarness, parseFlowYaml } from "@open-harness/server";
import { readFileSync } from "node:fs";

const flow = parseFlowYaml(readFileSync("flow.yaml", "utf-8"));

const harness = createHarness({
  flow,
  transport: {
    websocket: { port: 8080, path: "/ws" }
  }
});

// Start the harness (also starts WebSocket server)
await harness.run({ code: "function foo() {}" });
```

The WebSocket server listens on `ws://localhost:8080/ws`.

## Client Connection

Connect from a browser and listen for events:

```typescript title="client.ts"
const ws = new WebSocket("ws://localhost:8080/ws");

ws.onmessage = (event) => {
  const envelope = JSON.parse(event.data);

  if (envelope.type === "event") {
    const runtimeEvent = envelope.event;

    switch (runtimeEvent.type) {
      case "agent:text":
        // Streaming text from Claude
        process.stdout.write(runtimeEvent.text);
        break;
      case "node:complete":
        console.log(`Node ${runtimeEvent.nodeId} finished`);
        break;
      case "flow:complete":
        console.log("Flow completed");
        break;
    }
  }
};
```

## Sending Commands

Send commands to control execution:

```typescript title="client.ts"
// Pause execution
ws.send(JSON.stringify({
  type: "command",
  command: { type: "pause" }
}));

// Resume with a message
ws.send(JSON.stringify({
  type: "command",
  command: { type: "resume", message: "continue" }
}));

// Stop execution
ws.send(JSON.stringify({
  type: "command",
  command: { type: "stop" }
}));
```

## Event Message Format

All messages are wrapped in an envelope:

```typescript
// Events from server
type EventEnvelope = {
  type: "event";
  event: RuntimeEvent;
};

// Commands to server
type CommandEnvelope = {
  type: "command";
  command: RuntimeCommand;
};
```

## Common Runtime Events

| Event Type | Description |
|------------|-------------|
| `flow:start` | Flow execution started |
| `node:start` | Node execution started |
| `agent:text` | Streaming text from agent |
| `node:complete` | Node execution finished |
| `flow:complete` | Flow execution finished |

## Manual Transport Setup

For more control, create the transport directly:

```typescript title="manual.ts"
import { createRuntime, parseFlowYaml } from "@open-harness/server";
import { WebSocketTransport } from "@open-harness/server";

const runtime = createRuntime({
  flow: parseFlowYaml(yaml),
});

const transport = new WebSocketTransport(runtime, {
  port: 8080,
  path: "/ws"
});

// Start transport before running
await transport.start();

// Run the flow
await runtime.run({ code: "..." });

// Cleanup
await transport.stop();
```

<Callout type="stuck" title="Are you stuck?">
**Connection refused on port 8080**
Make sure the harness is started before connecting. The WebSocket server starts when you call `harness.run()`.

**Not receiving events**
Check that you're connecting to the correct path (default is `/ws`).
</Callout>

## Next Steps

- [Events API](/docs/reference/api/events) — Full event type reference
- [Runtime API](/docs/reference/api/flow-runtime) — Runtime control methods

