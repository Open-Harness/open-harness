---
title: How to Handle Bidirectional I/O
description: Implement full-duplex communication with inbox/outbox patterns
---

# How to Handle Bidirectional I/O

Create channels that both receive from and send to workflows.

## When to Use Bidirectional I/O

- Multi-turn conversations
- Streaming responses with user interrupts
- WebSocket connections
- Interactive sessions

## The Inbox Pattern

```
User Input   ─────▶   Channel   ─────▶   Hub.send()
                         │                   │
                         │                   ▼
                         │              Agent Inbox
                         │                   │
Hub.subscribe() ◀────────┘◀──────────────────┘
```

## Basic Bidirectional Channel

```typescript
import type { ChannelDefinition } from "@open-harness/kernel";

interface BiState {
  pendingInputs: Map<string, (response: string) => void>;
}

export const bidirectionalChannel: ChannelDefinition<BiState> = {
  name: "bidirectional",

  state: () => ({
    pendingInputs: new Map()
  }),

  on: {
    // Outgoing: agent produces output
    "agent:text": (ctx) => {
      sendToClient(ctx.event.event.content);
    },

    // Incoming: workflow needs input
    "session:prompt": (ctx) => {
      const { promptId, question } = ctx.event.event;

      // Store callback for this prompt
      ctx.state.pendingInputs.set(promptId, (response) => {
        ctx.hub.reply(promptId, { content: response });
      });

      // Request input from user
      requestInput(promptId, question);
    }
  }
};

// Called when user provides input
function onUserInput(promptId: string, response: string) {
  const callback = pendingInputs.get(promptId);
  if (callback) {
    callback(response);
    pendingInputs.delete(promptId);
  }
}
```

## WebSocket Channel

```typescript
import { WebSocketServer } from "ws";
import type { ChannelDefinition } from "@open-harness/kernel";

interface WSState {
  connections: Map<string, WebSocket>;
}

export const websocketChannel: ChannelDefinition<WSState> = {
  name: "websocket",

  state: () => ({
    connections: new Map()
  }),

  onStart: (ctx) => {
    const wss = new WebSocketServer({ port: 8080 });

    wss.on("connection", (ws, req) => {
      const sessionId = generateSessionId();
      ctx.state.connections.set(sessionId, ws);

      ws.on("message", (data) => {
        const message = JSON.parse(data.toString());
        ctx.hub.send(message.content);
      });

      ws.on("close", () => {
        ctx.state.connections.delete(sessionId);
      });
    });
  },

  on: {
    "agent:text": (ctx) => {
      const { sessionId } = ctx.event.context;
      const ws = ctx.state.connections.get(sessionId);

      if (ws) {
        ws.send(JSON.stringify({
          type: "text",
          content: ctx.event.event.content
        }));
      }
    }
  }
};
```

## Hub Commands

```typescript
// Send message to workflow
ctx.hub.send("User's message");

// Reply to specific prompt
ctx.hub.reply(promptId, { content: "User's response" });

// Abort workflow
ctx.hub.abort("User cancelled");
```

## Streaming with Interrupts

```typescript
on: {
  "agent:text": (ctx) => {
    // Check for interrupt flag
    if (ctx.state.interrupted) {
      ctx.hub.abort("User interrupted");
      return;
    }

    sendToClient(ctx.event.event.content);
  }
}

// External: user clicks stop
function onUserInterrupt(ctx: ChannelContext<State>) {
  ctx.state.interrupted = true;
}
```

## Session Management

```typescript
interface SessionState {
  sessions: Map<string, {
    startTime: Date;
    messageCount: number;
  }>;
}

on: {
  "session:start": (ctx) => {
    ctx.state.sessions.set(ctx.event.context.sessionId, {
      startTime: new Date(),
      messageCount: 0
    });
  },

  "agent:text": (ctx) => {
    const session = ctx.state.sessions.get(ctx.event.context.sessionId);
    if (session) {
      session.messageCount++;
    }
  },

  "session:complete": (ctx) => {
    ctx.state.sessions.delete(ctx.event.context.sessionId);
  }
}
```

## Related

- [Attach Channel](/docs/guides/channels/attach-channel) - Channel basics
- [Console Channel](/docs/guides/channels/console-channel) - Text I/O example
- [Bidirectional Concepts](/docs/concepts/channels/bidirectional) - Architecture
