---
title: How to Handle Flow Errors
description: Handle flow execution errors gracefully
---

# How to Handle Flow Errors

Catch and handle errors at parse, validation, and runtime stages.

## Error Types

| Type | When | Example |
|------|------|---------|
| Parse Error | Invalid YAML | Syntax errors, missing fields |
| Validation Error | Invalid flow structure | Missing edges, unknown types |
| Runtime Error | Execution failure | Node throws, timeout |

## Handle Parse Errors

```typescript
import { parseFlowYaml, FlowParseError } from "@open-harness/kernel";

try {
  const flow = parseFlowYaml(yamlContent);
} catch (error) {
  if (error instanceof FlowParseError) {
    console.error("YAML error:", error.message);
    console.error("Line:", error.line);
    process.exit(1);
  }
  throw error;
}
```

## Handle Validation Errors

```typescript
import { validateFlowYaml } from "@open-harness/kernel";

const validation = validateFlowYaml(flow);

if (!validation.valid) {
  for (const error of validation.errors) {
    console.error(`[${error.code}] ${error.message}`);
    console.error(`  Path: ${error.path}`);
  }
  process.exit(1);
}
```

## Handle Runtime Errors

```typescript
import { executeFlow, ExecutionError } from "@open-harness/kernel";

try {
  const result = await executeFlow(flow, { input, registry, hub });
} catch (error) {
  if (error instanceof ExecutionError) {
    console.error("Execution failed");
    console.error("Node:", error.nodeId);
    console.error("Error:", error.cause.message);
  }
}
```

## Subscribe to Error Events

```typescript
hub.subscribe("task:failed", (event) => {
  const { taskId, error } = event.event;
  console.error(`Node ${taskId} failed:`, error);
});

hub.subscribe("flow:error", (event) => {
  console.error("Flow error:", event.event.error);
});
```

## Node-Level Error Handling

In custom nodes:

```typescript
const myNode: NodeTypeDefinition = {
  type: "my-node",
  inputSchema,
  outputSchema,

  async run(ctx, input) {
    try {
      const result = await riskyOperation(input);
      return { result };
    } catch (error) {
      // Emit error event for observability
      ctx.hub.emit({
        type: "narrative",
        text: `Error in operation: ${error.message}`
      });

      // Re-throw to fail the node
      throw error;
    }
  }
};
```

## Graceful Degradation

Use conditional execution for fallbacks:

```yaml
nodes:
  - id: primary
    type: expensive-llm
    input: {}
    policy:
      continueOnError: true

  - id: fallback
    type: simple-llm
    input: {}
    when:
      equals:
        var: primary.output.skipped
        value: true

edges:
  - from: primary
    to: fallback
```

## Retry Pattern

```typescript
async function executeWithRetry(
  flow: FlowYaml,
  options: ExecuteOptions,
  maxRetries = 3
) {
  let lastError: Error;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await executeFlow(flow, options);
    } catch (error) {
      lastError = error;
      console.warn(`Attempt ${attempt} failed:`, error.message);

      if (attempt < maxRetries) {
        await sleep(1000 * attempt); // Exponential backoff
      }
    }
  }

  throw lastError;
}
```

## Related

- [Debug Flows](/docs/guides/debugging/debug-flows) - Diagnose issues
- [Common Errors](/docs/guides/debugging/common-errors) - Error reference
- [Conditional Execution](/docs/guides/flows/conditional-execution) - Fallbacks
