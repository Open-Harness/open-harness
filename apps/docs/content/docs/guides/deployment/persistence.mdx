---
title: Persistence Configuration
description: Configure signal stores for durable workflows
---

# Persistence Configuration

Open Harness can persist signal traces for recording and replay.

## In-Memory Store (Development)

Use `MemorySignalStore` for quick iteration:

```typescript
import { MemorySignalStore } from "@open-harness/core";

const store = new MemorySignalStore();
```

- Fast, no setup
- Data lost on restart
- Perfect for tests

## Recording a Workflow

Enable recording during execution:

```typescript
import { createHarness, ClaudeProvider, MemorySignalStore } from "@open-harness/core";

const store = new MemorySignalStore();

const result = await runReactive({
  agents: { analyzer },
  state: initialState,
  provider: new ClaudeProvider(),
  recording: {
    mode: "record",
    store,
    name: "my-workflow",
    tags: ["production", "analyzer"],
  },
});

console.log("Recording ID:", result.recordingId);
```

## Replaying a Workflow

Replay without provider calls:

```typescript
const result = await runReactive({
  agents: { analyzer },
  state: initialState,
  provider: new ClaudeProvider(), // Not called during replay
  recording: {
    mode: "replay",
    store,
    recordingId: "rec_abc123",
  },
});
```

## Custom Signal Store

Implement the `SignalStore` interface for other backends:

```typescript
import type { SignalStore, Recording, RecordingMetadata } from "@open-harness/core";

class PostgresSignalStore implements SignalStore {
  async saveRecording(recording: Recording): Promise<void> {
    await this.pool.query(
      "INSERT INTO recordings (id, data) VALUES ($1, $2)",
      [recording.id, JSON.stringify(recording)]
    );
  }

  async loadRecording(id: string): Promise<Recording | null> {
    const result = await this.pool.query(
      "SELECT data FROM recordings WHERE id = $1",
      [id]
    );
    return result.rows[0]?.data ?? null;
  }

  async listRecordings(options?: ListOptions): Promise<RecordingMetadata[]> {
    // Implement filtering and pagination
    return [];
  }

  async deleteRecording(id: string): Promise<void> {
    await this.pool.query("DELETE FROM recordings WHERE id = $1", [id]);
  }
}
```

## What Gets Persisted

- **Signal Trace**: Every signal emitted during execution
- **Metadata**: Recording name, tags, timestamps, metrics
- **Final State**: The state at workflow completion

## Trade-offs

| Store | Pros | Cons |
|-------|------|------|
| MemorySignalStore | Fast, zero setup | Lost on restart |
| Custom DB | Scalable, durable | More ops work |
| File-based (coming soon) | Simple persistence | Single-process |

## Migrating to Production

1. Start with `MemorySignalStore` locally
2. Use recording/replay for deterministic tests
3. Implement a custom store for production persistence

## Next Steps

<Cards>
  <Card title="Recording & Replay" href="/docs/learn/persistence">
    Testing patterns with signals
  </Card>
  <Card title="Production Deployment" href="/docs/guides/deployment/production">
    Deployment checklist
  </Card>
</Cards>
