#!/usr/bin/env bash
set -euo pipefail

usage() {
	cat <<'EOF'
Usage: scripts/new-worktree --epic <id> --feature "<name>" [--app opencode|claude] [--base origin/dev]

Creates a git worktree and branch, claims the epic in beads,
disables the beads daemon in the new tab, and launches the app.
If a worktree already exists for the branch, it is reused.

Bead code derivation:
- If the epic id ends with 3 alphanumeric chars, convert that suffix from base36
  and take mod 1000, zero-padded to three digits.
- Otherwise, hash the full epic id using cksum and take mod 1000, zero-padded.
EOF
}

die() {
	echo "Error: $*" >&2
	exit 1
}

require_cmd() {
	command -v "$1" >/dev/null 2>&1 || die "Missing required command: $1"
}

slugify() {
	local input="$1"
	local slug
	slug=$(printf "%s" "$input" | tr '[:upper:]' '[:lower:]' | tr -cs 'a-z0-9' '-')
	slug="${slug#-}"
	slug="${slug%-}"
	printf "%s" "$slug"
}

find_worktree_for_branch() {
	local repo_root="$1"
	local branch_name="$2"
	local current_worktree=""
	local found=""

	while IFS= read -r line; do
		if [[ "$line" == worktree\ * ]]; then
			current_worktree="${line#worktree }"
		elif [[ "$line" == branch\ * ]]; then
			local branch_ref="${line#branch }"
			if [[ "$branch_ref" == "refs/heads/${branch_name}" ]]; then
				found="$current_worktree"
				break
			fi
		fi
	done < <(git -C "$repo_root" worktree list --porcelain)

	printf "%s" "$found"
}

derive_bead_code() {
	local epic_id="$1"
	local suffix="${epic_id##*-}"

	if [[ "$suffix" =~ ^[A-Za-z0-9]{3}$ ]]; then
		local normalized
		normalized=$(printf "%s" "$suffix" | tr '[:lower:]' '[:upper:]')
		local value=$((36#${normalized}))
		printf "%03d" $((value % 1000))
		return 0
	fi

	local cksum_output
	cksum_output=$(printf "%s" "$epic_id" | cksum)
	set -- $cksum_output
	printf "%03d" $(( $1 % 1000 ))
}

pick_city() {
	local cities=(
		"Mecca"
		"Medina"
		"Jeddah"
		"Taif"
		"Yanbu"
		"Jerusalem"
		"Hebron"
		"Nablus"
		"Gaza"
		"Ramla"
		"Tiberias"
		"Acre"
		"Damascus"
		"Aleppo"
		"Homs"
		"Hama"
		"Latakia"
		"Beirut"
		"Sidon"
		"Tyre"
		"Tripoli"
		"Amman"
		"Karak"
		"Aqaba"
		"Baghdad"
		"Kufa"
		"Basra"
		"Najaf"
		"Karbala"
		"Mosul"
		"Tikrit"
		"Samarra"
		"Fallujah"
		"Wasit"
		"Cairo"
		"Fustat"
		"Alexandria"
		"Aswan"
		"Luxor"
		"Sanaa"
		"Aden"
		"Taiz"
		"Zabid"
		"Muscat"
		"Nizwa"
		"Tunis"
		"Kairouan"
		"Fez"
		"Marrakech"
		"Rabat"
	)

	local index=$((RANDOM % ${#cities[@]}))
	printf "%s" "${cities[$index]}"
}

launch_ghostty_tab() {
	local worktree_path="$1"
	local app_cmd="$2"
	local command_line
	local clipboard_file

	require_cmd osascript
	require_cmd pbcopy
	require_cmd pbpaste

	command_line="cd \"${worktree_path}\" && export BEADS_NO_DAEMON=1 && ${app_cmd}"
	clipboard_file=$(mktemp)
	pbpaste > "$clipboard_file" || true
	printf "%s" "$command_line" | pbcopy

	osascript \
		-e 'tell application "Ghostty" to activate' \
		-e 'delay 0.2' \
		-e 'tell application "System Events" to keystroke "t" using {command down}' \
		-e 'delay 0.4' \
		-e 'tell application "System Events" to keystroke "v" using {command down}' \
		-e 'delay 0.1' \
		-e 'tell application "System Events" to key code 36'

	pbcopy < "$clipboard_file" || true
	rm -f "$clipboard_file"
}

epic_id=""
feature_name=""
app="opencode"
base_branch="origin/dev"

while [[ $# -gt 0 ]]; do
	case "$1" in
		--epic)
			epic_id="${2:-}"
			shift 2
			;;
		--feature)
			feature_name="${2:-}"
			shift 2
			;;
		--app)
			app="${2:-}"
			shift 2
			;;
		--base)
			base_branch="${2:-}"
			shift 2
			;;
		-h|--help)
			usage
			exit 0
			;;
		*)
			die "Unknown argument: $1"
			;;
	esac
done

if [[ -z "$epic_id" || -z "$feature_name" ]]; then
	usage
	die "Both --epic and --feature are required."
fi

app=$(printf "%s" "$app" | tr '[:upper:]' '[:lower:]')
case "$app" in
	opencode|claude)
		;;
	*)
		die "Invalid --app value: $app (expected opencode or claude)"
		;;
esac

require_cmd git
require_cmd bd

issue_json=$(bd show "$epic_id" --json 2>/dev/null) || die "Epic not found: ${epic_id}"
issue_json_compact=$(printf "%s" "$issue_json" | tr -d '[:space:]')
if [[ "$issue_json_compact" != *"\"issue_type\":\"epic\""* ]]; then
	die "Issue is not an epic: ${epic_id}"
fi

repo_root=$(git rev-parse --show-toplevel 2>/dev/null) || die "Not inside a git repository."
worktrees_dir="${repo_root}/../worktrees"

if [[ ! -d "$worktrees_dir" ]]; then
	die "Worktrees directory not found: ${worktrees_dir}"
fi

feature_slug=$(slugify "$feature_name")
if [[ -z "$feature_slug" ]]; then
	die "Feature name produced an empty slug."
fi

branch_name="feat/${feature_slug}"

existing_worktree=$(find_worktree_for_branch "$repo_root" "$branch_name")
worktree_path=""
created_worktree="false"

if [[ -n "$existing_worktree" ]]; then
	worktree_path="$existing_worktree"
else
	bead_code=$(derive_bead_code "$epic_id")

	for _ in {1..20}; do
		city=$(pick_city)
		city_slug=$(slugify "$city")
		candidate="${worktrees_dir}/${bead_code}-${city_slug}"
		if [[ ! -e "$candidate" ]]; then
			worktree_path="$candidate"
			break
		fi
	done

	if [[ -z "$worktree_path" ]]; then
		die "Failed to find an unused worktree name."
	fi

	if git -C "$repo_root" show-ref --verify --quiet "refs/heads/${branch_name}"; then
		git -C "$repo_root" worktree add "$worktree_path" "$branch_name"
	else
		git -C "$repo_root" worktree add -b "$branch_name" "$worktree_path" "$base_branch"
	fi

	created_worktree="true"
fi

bd update "$epic_id" --status in_progress --json >/dev/null

launch_ghostty_tab "$worktree_path" "$app"

worktree_label="Worktree created"
if [[ "$created_worktree" != "true" ]]; then
	worktree_label="Worktree reused"
fi

cat <<EOF
${worktree_label}:	${worktree_path}
Branch:			${branch_name}
Epic claimed:		${epic_id}
App launched:		${app}
EOF
