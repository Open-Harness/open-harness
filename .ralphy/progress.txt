# Ralphy Progress Log

## 2026-01-21T16:56:13Z - Phase 1 Setup Task 1
**Task**: Create packages/core-v2/ directory structure
**Status**: COMPLETE
**Changes**:
- Created packages/core-v2/ directory
- Created src/ subdirectories: event, handler, agent, workflow, tape, store, renderer, provider, message, internal
- Created tests/integration/ directory
**Verification**: Directory structure matches specs/001-effect-refactor/plan.md exactly
**Lint**: PASS (no new code to lint)

## 2026-01-21T17:02:30Z - Phase 1 Setup Tasks 2-8
**Task**: Complete remaining Phase 1 setup (package.json, tsconfig, vitest config, stub files)
**Status**: COMPLETE
**Changes**:
- Created packages/core-v2/package.json with:
  - name: @open-harness/core-v2
  - dependencies: effect ^3.19.0, @effect/platform ^0.94.0, @anthropic-ai/claude-agent-sdk ^0.2.5, zod ^4.3.4
  - devDependencies: @effect/vitest ^0.27.0, typescript ^5.9.3, vitest ^3.1.4
  - NOTE: @effect/schema removed (merged into effect v3.x), zod-to-json-schema removed (using Zod 4 native toJSONSchema)
- Created packages/core-v2/tsconfig.json extending root config
- Created packages/core-v2/vitest.config.ts with @effect/vitest support
- Created packages/core-v2/src/index.ts (public API entry point, Effect-free)
- Created packages/core-v2/src/react.ts (React subpath export stub)
- Created packages/core-v2/src/internal/boundary.ts with exitToResult and ManagedRuntime
- Created packages/core-v2/src/internal/schema.ts with convertZodToJsonSchema using Zod 4 native toJSONSchema
- Created packages/core-v2/tests/setup.test.ts to verify package setup
**Verification**:
- bun install: PASS (48 packages installed)
- bun run test: PASS (5 tests)
- bun run typecheck: PASS
- bun run lint: PASS
**Notes**:
- Effect 3.x merged @effect/schema into the main effect package
- Zod 4 has native toJSONSchema, no need for zod-to-json-schema library
- TypeScript config extends monorepo root for consistency

## 2026-01-21T17:06:50Z - Phase 2 Event Primitives
**Task**: Implement Event Primitives (all 11 tasks in Event Primitives section)
**Status**: COMPLETE
**Changes**:
- Created packages/core-v2/src/event/Event.ts with:
  - EventId branded type using Schema.UUID.pipe(Schema.brand("EventId"))
  - Event interface (id, name, payload, timestamp, causedBy?)
  - EventSchema factory function for creating typed event schemas
  - createEvent factory function for creating events with auto-generated ID/timestamp
  - defineEvent factory for developer-friendly event definitions with create() and is() methods
  - All built-in event schemas and interfaces:
    - UserInputEvent (text, sessionId?)
    - TextDeltaEvent (delta, agentName?)
    - TextCompleteEvent (fullText, agentName?)
    - AgentStartedEvent (agentName, reason?)
    - AgentCompletedEvent (agentName, outcome: success|failure|interrupted)
    - ToolCalledEvent (toolName, toolId, input)
    - ToolResultEvent (toolId, output, isError)
    - ErrorOccurredEvent (code, message, recoverable, context?)
- Created packages/core-v2/src/event/index.ts re-exporting consumer-facing types (NO @effect/schema internals)
- Created packages/core-v2/src/event/EventLog.ts with append-only event log using Effect Ref
- Created packages/core-v2/tests/event.test.ts with 27 comprehensive tests
**Verification**:
- bun run test: PASS (32 tests total, 27 new event tests)
- bun run lint: PASS (no errors or warnings)
**Notes**:
- Effect 3.x has Schema merged into main package (import { Schema } from "effect")
- EventLog is internal-only, not exported in public API
- defineEvent provides clean DX without exposing Effect schemas to consumers

## 2026-01-21T17:10:00Z - Phase 2 Handler System
**Task**: Implement Handler System (2 tasks in Handler System section)
**Status**: COMPLETE
**Changes**:
- Created packages/core-v2/src/handler/Handler.ts with:
  - HandlerResult<S> interface: { state: S, events: readonly AnyEvent[] }
  - Handler<E, S> type: pure function (event, state) => HandlerResult<S>
  - HandlerDefinition<E, S> interface: { name, handles, handler }
  - DefineHandlerOptions<E, S> interface for factory options
  - defineHandler(eventDef, options) factory for type-safe handler creation
  - Utility functions: stateOnly(), emit(), emitEvent()
- Created packages/core-v2/src/handler/index.ts re-exporting consumer-facing types and factories
- Created packages/core-v2/tests/handler.test.ts with 22 comprehensive tests covering:
  - HandlerResult types and structures
  - Handler function type constraints (pure, deterministic)
  - HandlerDefinition interface
  - defineHandler factory with EventDefinition integration
  - Utility functions (stateOnly, emit, emitEvent)
  - Handler composition patterns (chaining, multiple events, conditional emission)
**Verification**:
- bun run test: PASS (54 tests total, 22 new handler tests)
- bun run typecheck: PASS
- bun run lint: PASS (no errors or warnings)
**Notes**:
- Handlers are synchronous-only per spec FR-009 to FR-011 for determinism
- No Effect types exposed in public API per spec FR-062
- Utility functions (stateOnly, emit, emitEvent) provide clean DX for handler authors

## 2026-01-21T17:16:00Z - Phase 2 Agent System
**Task**: Implement Agent System (2 tasks in Agent System section)
**Status**: COMPLETE
**Changes**:
- Created packages/core-v2/src/agent/Agent.ts with:
  - PromptPart and PromptTemplate types for flexible prompt generation
  - Agent<S, O> interface with all required properties:
    - name: string (unique identifier)
    - activatesOn: readonly string[] (event names that trigger agent)
    - emits: readonly string[] (event types agent can produce)
    - model?: string (optional LLM model override)
    - prompt: (state, event) => PromptTemplate
    - when?: (state) => boolean (optional guard condition)
    - outputSchema: unknown (REQUIRED - Zod schema for structured output)
    - onOutput: (output, event) => AnyEvent[] (transform output to events)
  - AgentOptions<S, O> interface for agent() factory
  - MissingOutputSchemaError class with clear error message
  - agent() factory function with outputSchema validation (throws if missing)
  - AgentRegistry<S> type (ReadonlyMap<string, Agent>)
  - Utility functions:
    - shouldActivate(agent, eventName, state) - checks if agent should activate
    - findMatchingAgents(registry, eventName, state) - finds all matching agents
    - createAgentRegistry(agents) - creates registry from array, validates uniqueness
- Created packages/core-v2/src/agent/index.ts re-exporting consumer-facing types
- Created packages/core-v2/tests/agent.test.ts with 29 comprehensive tests covering:
  - Agent interface with required and optional properties
  - PromptTemplate (string and array of parts)
  - agent() factory with validation and error handling
  - onOutput callback behavior and event emission
  - shouldActivate() with event matching and guard conditions
  - findMatchingAgents() with multiple agents and guards
  - createAgentRegistry() with duplicate name detection
  - Integration tests for complete agent workflow
**Verification**:
- bun run test: PASS (83 tests total, 29 new agent tests)
- bun run lint: PASS (no errors or warnings)
**Notes**:
- outputSchema is MANDATORY per spec FR-016 - factory throws MissingOutputSchemaError if missing
- Agents don't directly update state - they emit events that handlers process (event sourcing)
- Guard conditions (when) allow conditional agent activation based on state
- createAgentRegistry validates unique agent names, throws on duplicates

## 2026-01-21T17:22:19Z - Phase 2 Effect Service Tags: Store
**Task**: Create Store Context.Tag and StoreService interface
**Status**: COMPLETE
**Changes**:
- Created packages/core-v2/src/store/Store.ts with:
  - SessionIdSchema branded type using Schema.String.pipe(Schema.brand("SessionId"))
  - SessionId type and utility functions: makeSessionId(), generateSessionId()
  - SessionMetadata interface: id, createdAt, lastEventAt?, eventCount, workflowName?
  - StateSnapshot<S> interface: data, position, lastEventId?
  - StoreError class with typed codes: NOT_FOUND, WRITE_FAILED, READ_FAILED, CORRUPTED
  - StoreService interface with Effect-based methods:
    - append(sessionId, event) → Effect<void, StoreError>
    - events(sessionId) → Effect<readonly AnyEvent[], StoreError>
    - sessions() → Effect<readonly SessionMetadata[], StoreError>
    - clear(sessionId) → Effect<void, StoreError>
    - snapshot(sessionId, position) → Effect<StateSnapshot | undefined, StoreError>
  - Store Context.Tag("@core-v2/Store") for Effect dependency injection
  - PublicStore interface for Promise-based public API (Effect-free)
- Created packages/core-v2/src/store/index.ts re-exporting consumer-facing types (NO Effect internals)
- Created packages/core-v2/tests/store.test.ts with 23 comprehensive tests covering:
  - SessionId creation and UUID generation
  - StoreError class with all error codes
  - Store Context.Tag service identifier and dependency injection
  - SessionMetadata and StateSnapshot interfaces
  - StoreService interface contract (all methods)
  - Error propagation and recovery with Effect.catchAll
  - Service composition with Effect.gen
**Verification**:
- bun run test: PASS (106 tests total, 23 new store tests)
- bun run lint: PASS (no errors or warnings)
**Notes**:
- Store Context.Tag uses Effect Layer pattern for dependency injection
- StoreError.cause uses `override readonly` to properly extend Error in ES2022+
- PublicStore provides Effect-free interface for consumers
- Implementations (MemoryStore, SqliteStore) will be added in Phase 5

## 2026-01-21T17:26:30Z - Phase 2 Effect Service Tags: LLMProvider
**Task**: Create LLMProvider Context.Tag and LLMProviderService interface
**Status**: COMPLETE
**Changes**:
- Created packages/core-v2/src/provider/Provider.ts with:
  - ProviderErrorCode type: RATE_LIMITED, CONTEXT_LENGTH_EXCEEDED, INVALID_REQUEST, NETWORK_ERROR, AUTHENTICATION_FAILED, PROVIDER_ERROR
  - ProviderError class with typed codes, retryable flag, and optional retryAfter hint
  - ProviderMessage interface: role (user|assistant|system), content
  - QueryOptions interface with all SDK-compatible options:
    - messages (required), sessionId?, model?, abortController?, maxTurns?
    - persistSession?, includePartialMessages?, permissionMode?, outputFormat?
  - StreamChunk interface: type (text|tool_use|stop), text?, toolCall?, stopReason?
  - QueryResult interface: events, text?, output?, sessionId?, stopReason?
  - ClaudeProviderConfig interface for provider configuration
  - ProviderType type: "claude" | "custom"
  - ProviderInfo interface for metadata: type, name, model, connected
  - LLMProviderService interface with Effect-based methods:
    - query(options) → Effect<QueryResult, ProviderError>
    - stream(options) → Stream<StreamChunk, ProviderError>
    - info() → Effect<ProviderInfo, ProviderError>
  - LLMProvider Context.Tag("@core-v2/LLMProvider") for Effect dependency injection
  - PublicLLMProvider interface for Promise-based public API (Effect-free)
- Created packages/core-v2/src/provider/index.ts re-exporting consumer-facing types (NO Effect internals)
- Created packages/core-v2/tests/provider.test.ts with 34 comprehensive tests covering:
  - ProviderError class with all error codes and retryable/retryAfter handling
  - ProviderMessage interface for all roles
  - QueryOptions with required and optional fields
  - StreamChunk for text, tool_use, and stop types
  - QueryResult interface
  - ClaudeProviderConfig and ProviderInfo interfaces
  - LLMProvider Context.Tag service identifier and dependency injection
  - LLMProviderService interface contract (query, stream, info)
  - Error propagation and recovery for both query and stream
  - Service composition with Effect.gen
  - PublicLLMProvider Promise-based interface
**Verification**:
- bun run test: PASS (140 tests total, 34 new provider tests)
- bun run lint: PASS (no errors or warnings)
**Notes**:
- LLMProvider uses Effect Stream for streaming responses (Effect.Stream<StreamChunk, ProviderError>)
- PublicLLMProvider.stream returns AsyncIterable for consumer-friendly API
- Implementation (ClaudeProvider) will be added in Phase 9
- All types derived from specs/001-effect-refactor/contracts/provider.ts

## 2026-01-21T17:30:00Z - Phase 2 Effect Service Tags: EventBus
**Task**: Create EventBus Context.Tag and EventBusService interface
**Status**: COMPLETE
**Changes**:
- Created packages/core-v2/src/event/EventBus.ts with:
  - SubscriptionId branded type for unique subscription identification
  - Utility functions: makeSubscriptionId(), generateSubscriptionId()
  - EventFilter type for filtering events by criteria
  - SubscriberCallback type returning Effect<void> for async subscribers
  - Subscription interface: { id, filter?, callback }
  - EventBusError class with typed codes: SUBSCRIPTION_NOT_FOUND, EMIT_FAILED
  - EventBusService interface with Effect-based methods:
    - emit(event) → Effect<void> - publish event to all matching subscribers
    - subscribe(callback, filter?) → Effect<SubscriptionId> - register subscription
    - unsubscribe(subscriptionId) → Effect<void> - remove subscription
    - subscriptionCount() → Effect<number> - get current subscription count
  - EventBus Context.Tag("@core-v2/EventBus") for Effect dependency injection
  - makeEventBusService Effect factory using Ref for thread-safe subscriber storage
  - EventBusLive Layer using Layer.effect(EventBus, makeEventBusService)
  - PublicEventBus interface for Promise-based public API (Effect-free)
  - Pattern matching utilities:
    - createPatternFilter(pattern) - supports exact, wildcard suffix (error:*), wildcard prefix (*:completed), and catch-all (*)
    - createMultiPatternFilter(patterns) - matches if ANY pattern matches
- Updated packages/core-v2/src/event/index.ts to export EventBus types (consumer-facing only)
- Created packages/core-v2/tests/eventbus.test.ts with 33 comprehensive tests covering:
  - SubscriptionId creation and UUID generation
  - EventBusError class with all error codes
  - EventBus Context.Tag service identifier and dependency injection
  - Subscribe/unsubscribe operations
  - Event emission to multiple subscribers
  - Filter-based event delivery
  - Pattern matching (exact, wildcard prefix/suffix, catch-all)
  - createMultiPatternFilter for OR logic patterns
  - EventBusLive Layer integration
  - Rapid emit/unsubscribe cycles
**Verification**:
- bun run test: PASS (173 tests total, 33 new eventbus tests)
- bun run lint: PASS (no errors or warnings)
**Notes**:
- Uses Effect Ref for thread-safe subscriber management
- Subscriber callbacks are forked and joined (fire-and-complete semantics)
- Pattern filter supports spec FR-020 pattern matching for event names
- Layer.effect() is the correct Effect 3.x API (not Effect.toLayer)

## 2026-01-21T17:37:00Z - Phase 2 Effect Service Tags: HandlerRegistry
**Task**: Create HandlerRegistry Context.Tag and HandlerRegistryService interface
**Status**: COMPLETE
**Changes**:
- Created packages/core-v2/src/handler/HandlerRegistry.ts with:
  - HandlerRegistryErrorCode type: HANDLER_NOT_FOUND, DUPLICATE_HANDLER, REGISTRATION_FAILED
  - HandlerRegistryError class with typed codes and cause preservation
  - HandlerRegistryService<S> interface with Effect-based methods:
    - register(definition) → Effect<void, HandlerRegistryError> (enforces single handler per event)
    - get(eventName) → Effect<Handler | undefined>
    - has(eventName) → Effect<boolean>
    - getAll() → Effect<readonly HandlerDefinition[]> (for replay/debugging)
    - count() → Effect<number>
  - HandlerRegistry Context.Tag("@core-v2/HandlerRegistry") for Effect dependency injection
  - makeHandlerRegistryService<S>() Effect factory using Ref for thread-safe handler storage
  - HandlerRegistryLive Layer using Layer.effect(HandlerRegistry, makeHandlerRegistryService())
  - PublicHandlerRegistry<S> interface for Promise-based public API (Effect-free)
- Updated packages/core-v2/src/handler/index.ts to export consumer-facing types:
  - HandlerRegistryErrorCode, PublicHandlerRegistry (types)
  - HandlerRegistryError (class)
- Created packages/core-v2/tests/handler-registry.test.ts with 27 comprehensive tests covering:
  - HandlerRegistryError class with all error codes and cause preservation
  - HandlerRegistry Context.Tag service identifier and dependency injection
  - Register operation (success, multiple handlers, duplicate detection)
  - Get operation (found, not found, correct handler retrieval)
  - Has operation (registered, unregistered, empty registry)
  - GetAll operation (empty, all definitions, complete properties)
  - Count operation (empty, incremental)
  - HandlerRegistryLive Layer integration (fresh registry per run, composition)
  - Service composition with Effect.gen and error recovery
  - Retrieved handler execution (basic and with event emission)
**Verification**:
- bun run test: PASS (200 tests total, 27 new handler-registry tests)
- bun run lint: PASS (no errors or warnings)
**Notes**:
- Follows same Context.Tag + Layer.effect pattern as EventBus and Store
- Enforces one handler per event type (fails with DUPLICATE_HANDLER if already registered)
- Uses Map storage keyed by event name for O(1) lookup
- getAll() method added for replay scenarios where all handlers need to be applied

## 2026-01-21T17:47:00Z - Phase 2 Effect Service Tags: AgentRegistry
**Task**: Create AgentRegistry Context.Tag and AgentRegistryService interface
**Status**: COMPLETE
**Changes**:
- Created packages/core-v2/src/agent/AgentService.ts with:
  - AgentRegistryErrorCode type: AGENT_NOT_FOUND, DUPLICATE_AGENT, REGISTRATION_FAILED
  - AgentRegistryError class with typed codes and cause preservation
  - AgentRegistryService<S> interface with Effect-based methods:
    - register(agent) → Effect<void, AgentRegistryError> (enforces unique agent names)
    - get(name) → Effect<Agent | undefined>
    - findMatching(eventName, state) → Effect<readonly Agent[]> (checks activatesOn and when guard)
    - has(name) → Effect<boolean>
    - getAll() → Effect<readonly Agent[]>
    - count() → Effect<number>
  - AgentRegistry Context.Tag("@core-v2/AgentRegistry") for Effect dependency injection
  - makeAgentRegistryService<S>() Effect factory using Ref for thread-safe agent storage
  - AgentRegistryLive Layer using Layer.effect(AgentRegistry, makeAgentRegistryService())
  - PublicAgentRegistry<S> interface for Promise-based public API (Effect-free)
- Updated packages/core-v2/src/agent/index.ts to export consumer-facing types:
  - AgentRegistryErrorCode, PublicAgentRegistry (types)
  - AgentRegistryError (class)
- Updated packages/core-v2/src/agent/Agent.ts utility functions:
  - Changed shouldActivate, findMatchingAgents, createAgentRegistry to accept Agent<S, any>
  - This fixes TypeScript type variance issue with generic output types
- Created packages/core-v2/tests/agent-service.test.ts with 35 comprehensive tests covering:
  - AgentRegistryError class with all error codes and cause preservation
  - AgentRegistry Context.Tag service identifier and dependency injection
  - Register operation (success, multiple agents, duplicate detection)
  - Get operation (found, not found, correct agent retrieval)
  - FindMatching operation (event matching, multiple matching, guard conditions)
  - Has operation (registered, unregistered, empty registry)
  - GetAll operation (empty, all agents, complete properties)
  - Count operation (empty, incremental)
  - AgentRegistryLive Layer integration (fresh registry per run, composition)
  - Service composition with Effect.gen and error recovery
  - Retrieved agent prompt/onOutput behavior
  - Complex guard scenarios (currentAgent checks, AND conditions)
- Fixed TypeScript strict mode issues in existing tests:
  - Updated test helpers to use unknown types with proper assertions
  - Added optional chaining for array access in tests
**Verification**:
- bun run test: PASS (235 tests total, 35 new agent-service tests)
- bun run typecheck: PASS
- bun run lint: PASS (no errors)
**Notes**:
- Follows same Context.Tag + Layer.effect pattern as EventBus, Store, HandlerRegistry
- Uses existing shouldActivate() utility from Agent.ts for guard evaluation
- Enforces unique agent names (fails with DUPLICATE_AGENT if already registered)
- Uses Map storage keyed by agent name for O(1) lookup
- findMatching() combines activatesOn check with when guard evaluation

## 2026-01-21T17:54:00Z - Phase 3 Tape System (Complete Phase)
**Task**: Implement complete Tape time-travel debugging system (all 11 Phase 3 tasks)
**Status**: COMPLETE
**Changes**:
- Created packages/core-v2/src/tape/Tape.ts with:
  - TapeStatus type: "idle" | "playing" | "paused" | "recording"
  - TapeMetadata interface: sessionId, eventCount, duration?, status
  - Tape<S> interface with all properties:
    - position (current 0-based index)
    - length (total events)
    - current (event at position)
    - state (computed state via handler replay)
    - events (readonly event array)
    - isRecording, isReplaying (computed flags from status)
    - status (TapeStatus)
  - VCR Controls (immutable - return new Tape instances):
    - rewind() - returns to position 0, status idle
    - step() - advances 1, clamps at end (FR-029)
    - stepBack() - THE KEY FEATURE - goes back 1, clamps at 0 (FR-030)
    - stepTo(n) - jumps to any position, clamps [0, length-1] (FR-031)
    - play() - async play to end, sets status paused
    - playTo(n) - async play to position n
    - pause() - sets status to paused
  - Inspection Methods:
    - stateAt(n) - compute state at position WITHOUT changing current
    - eventAt(n) - get event at position WITHOUT changing current
  - TapeControls<S> interface (React hook subset with void returns)
  - TapeConfig<S> interface for factory configuration
  - computeState() utility - event sourcing core (FR-038):
    - Replays handlers from position 0 to derive state
    - Handles negative positions (returns initial state)
    - Skips events without registered handlers
    - Clamps to valid range
  - createTape() factory function
  - createTapeFromDefinitions() convenience factory
  - TapeImpl class with state caching for performance
- Created packages/core-v2/src/tape/index.ts re-exporting all types and factories
- Created packages/core-v2/tests/tape.test.ts with 84 comprehensive tests:
  - TapeStatus and TapeMetadata type tests
  - computeState utility tests (determinism, clamping, empty handling)
  - createTape and createTapeFromDefinitions factory tests
  - Position & length tests
  - Current event tests
  - State computation and caching tests
  - Events array tests
  - Status flags tests (isRecording, isReplaying)
  - VCR Controls: rewind (FR-028), step (FR-029), stepBack (FR-030), stepTo (FR-031)
  - play (FR-032) and playTo (FR-033) tests
  - pause (FR-034) tests
  - stateAt and eventAt inspection tests
  - TapeControls interface tests
  - Edge cases from spec (position 0 stepBack, past end step, clamping)
  - Deterministic replay (SC-004) - 100x same state
  - Immutability tests
  - Full time-travel debugging workflow tests
**Verification**:
- bun run test: PASS (319 tests total, 84 new tape tests)
- bun run typecheck: PASS
- bun run lint: PASS (1 expected warning for `any` type in createTapeFromDefinitions)
**Notes**:
- All VCR controls return NEW Tape instances (immutable pattern)
- State is computed via event sourcing - replay handlers to derive state
- Caching prevents recomputation for current position
- TapeControls subset for React returns void (state updates trigger re-render)
- stepBack() is THE key feature - enables debugging by reversing through history
- Deterministic replay verified: 100 runs produce identical state

## 2026-01-21T18:04:00Z - Phase 4 WorkflowRuntime Context.Tag
**Task**: Create WorkflowRuntime Context.Tag and WorkflowRuntimeService interface (first task of Phase 4)
**Status**: COMPLETE
**Changes**:
- Created packages/core-v2/src/workflow/WorkflowRuntime.ts with:
  - WorkflowRuntimeErrorCode type: HANDLER_NOT_FOUND, HANDLER_FAILED, AGENT_FAILED, STORE_UNAVAILABLE, EXECUTION_FAILED, TERMINATED, ABORTED
  - WorkflowRuntimeError class with typed codes and cause preservation
  - RuntimeCallbacks<S> interface: onEvent, onStateChange, onError
  - RuntimeRunOptions<S> interface: initialEvent, initialState, handlers, agents, until, record, sessionId, callbacks, abortSignal, model
  - RuntimeResult<S> interface: state, events, sessionId, terminated, aborted
  - WorkflowRuntimeService interface with Effect-based methods:
    - run(options) → Effect<RuntimeResult, WorkflowRuntimeError | StoreError | ProviderError>
    - processEvent(event, state, handlers) → Effect<{ state, events }, WorkflowRuntimeError>
  - WorkflowRuntime Context.Tag("@core-v2/WorkflowRuntime") for Effect dependency injection
  - makeWorkflowRuntimeService Effect factory that:
    - Depends on LLMProvider, Store, EventBus (via yield*)
    - Implements full event loop with Queue for event sequencing
    - Implements sequential event processing (FR-003)
    - Implements handler execution with error recovery (emits error:occurred events)
    - Implements agent activation with guard conditions (FR-015)
    - Implements termination condition checking (FR-040)
    - Implements recording to Store when record:true (FR-042)
    - Implements callbacks for event/state change notifications
  - WorkflowRuntimeLive Layer using Layer.effect(WorkflowRuntime, makeWorkflowRuntimeService)
  - PublicWorkflowRuntime interface for Promise-based public API (Effect-free)
- Created packages/core-v2/src/workflow/index.ts re-exporting consumer-facing types:
  - WorkflowRuntimeError, WorkflowRuntimeErrorCode (error handling)
  - RuntimeCallbacks, RuntimeRunOptions, RuntimeResult (configuration types)
  - PublicWorkflowRuntime (consumer-facing Promise-based interface)
- Created packages/core-v2/tests/workflow-runtime.test.ts with 30 comprehensive tests covering:
  - WorkflowRuntimeError class with all error codes and cause preservation
  - WorkflowRuntime Context.Tag service identifier and dependency injection
  - Event loop execution (initial event, chain of events, termination)
  - Sequential event processing (FR-003 compliance)
  - Handler processing (found, not found, throwing handlers)
  - Callback notifications (onEvent, onStateChange, onError)
  - Agent activation (event matching, guard conditions, onOutput events)
  - Recording integration (record:true persists events, record:false does not)
  - EventBus integration (events emitted to subscribers)
  - Layer integration and service composition
  - Edge cases (empty handlers, immediate termination, many events)
**Verification**:
- bun run test: PASS (349 tests total, 30 new workflow-runtime tests)
- bun run typecheck: PASS
- bun run lint: PASS (2 expected warnings for `any` types in Tape.ts and test file)
**Notes**:
- WorkflowRuntime is the heart of the event-sourcing system
- Implements the core loop: Event → Handler → (State + Events) → Next Event
- Uses Effect Queue for bounded event backpressure (1000 events max)
- Uses Effect Ref for thread-safe state management
- Depends on LLMProvider, Store, EventBus (injected via Effect Layer pattern)
- Handler errors are caught and converted to error:occurred events (graceful degradation)
- Agent execution includes structured output via Zod→JSON Schema conversion

