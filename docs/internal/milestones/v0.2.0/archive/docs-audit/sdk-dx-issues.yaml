# SDK DX Audit - Through Documentation Lens
# Generated: 2025-01-08
# Auditor: Claude Opus 4.5
#
# Premise: Bad docs often mean bad APIs. What's hard to explain is hard to use.

overall_assessment:
  stripe_grade: "C+"
  summary: |
    Open Harness has a reasonable API surface for its complexity, but suffers from
    inconsistent naming, multiple entry points at different abstraction levels,
    and significant documentation-vs-reality mismatches. The quickstart is clean
    (runFlow is genuinely simple), but users quickly need to understand Hub,
    Runtime, Registry, and Harness concepts to do anything non-trivial. The
    expression syntax has subtle inconsistencies between docs (when vs condition,
    node output paths vary). Error handling is underdocumented. Stripe would
    hide more internals and provide more sensible defaults.

scores:
  obviousness: 3
  defaults: 4
  error_messages: 2
  naming: 2
  escape_hatches: 4
  average: 3.0

api_pain_points:
  - api: "Entry point confusion: runFlow vs createHarness vs createRuntime"
    pain: "Three different entry points at three abstraction levels - users must understand when to use which"
    evidence: |
      Hub.mdx says "For most cases, use the simplified APIs" then shows both runFlow
      and createHarness. quickstart.mdx uses runFlow. your-first-agent.mdx uses
      createHarness. multi-agent-flow.mdx uses createRuntime. No clear guidance on
      when to graduate from one to another.
    suggestion: |
      Single entry point with progressive disclosure. Start with `run(flow, input)`.
      Options object unlocks more control. Runtime/Harness become internal details.
    priority: P0

  - api: "NodeRegistry vs plain object registry"
    pain: "Two different ways to provide nodes - confusing for users"
    evidence: |
      harness.d.ts shows `registry?: NodeRegistry | Record<string, NodeTypeDefinition>`.
      Quickstart uses inline object: `registry: { [helloAgent.type]: helloAgent }`.
      Your-first-agent uses `new DefaultNodeRegistry()` with explicit registration.
      User doesn't know which is "correct".
    suggestion: |
      Accept only objects or arrays. Provide createRegistry() if needed internally.
      Hide NodeRegistry class from public API.
    priority: P1

  - api: "Hub concept"
    pain: "Hub is mentioned in docs but not clearly needed for basic usage"
    evidence: |
      Architecture.mdx dedicates a section to Hub. Custom-agents.mdx shows
      `ctx.hub.emit()` and `ctx.hub.subscribe()`. But Hub doesn't appear in
      the public SDK exports (index.d.ts). User is confused: do I need Hub or not?
    suggestion: |
      Either make Hub a first-class export with clear docs, or remove Hub references
      entirely from user-facing docs. Currently leaking internal abstraction.
    priority: P1

  - api: "Output path inconsistency in expressions"
    pain: "Docs show multiple conflicting ways to access node outputs"
    evidence: |
      flow-yaml.mdx: `{{ nodes.fetch.output.body }}`
      bindings.mdx: `{{ source.value }}` (no .output, no nodes prefix)
      quickstart.mdx: `{{ flow.input.name }}` (correct)
      flow-yaml.mdx "Complete Example": `{{ nodes.analyze.output.text }}` vs
      `{{ researcher.text }}` in index.mdx
    suggestion: |
      Pick ONE canonical form and use it everywhere. Recommend: `{{ nodeId.field }}`
      without .output or nodes prefix. Update all docs to be consistent.
    priority: P0

  - api: "Edge condition field name inconsistency"
    pain: "Docs use 'when' and 'condition' interchangeably for edge conditions"
    evidence: |
      your-first-agent.mdx: `when: "triage.priority = 'urgent'"`
      edge-definition.mdx: `condition: "{{ nodes.classify.output.type = 'bug' }}"`
      conditionals.mdx: `when: "classify.priority = 'urgent'"` (no braces)
      flow-yaml.mdx: `condition: "{{ expr }}"`
    suggestion: |
      Pick one name. 'when' is more readable and matches other workflow systems
      (GitHub Actions, Temporal). Deprecate 'condition' if both work.
    priority: P0

  - api: "Expression wrapper inconsistency"
    pain: "Sometimes expressions need {{ }}, sometimes they don't"
    evidence: |
      conditionals.mdx edge conditions: `when: "classify.priority = 'urgent'"` (no braces)
      edge-definition.mdx: `condition: "{{ nodes.classify.output.type = 'bug' }}"` (with braces)
      bindings.mdx: Always shows `{{ }}` wrapper
    suggestion: |
      Be explicit: {{ }} for string interpolation, naked expression for when/condition.
      Document this clearly in one place and reference it.
    priority: P1

  - api: "NodeTypeDefinition vs AgentDefinition"
    pain: "Two different interfaces for defining nodes vs agents"
    evidence: |
      agent.mdx shows NodeTypeDefinition with `run(ctx, input)`.
      custom-agents.mdx shows AgentDefinition with `execute(input, ctx)`.
      Different method names, different parameter order, different interfaces.
    suggestion: |
      Unify to one interface. Prefer NodeTypeDefinition with `run`. If agent-specific
      capabilities needed, use options or capabilities field, not separate interface.
    priority: P1

  - api: "State access inconsistency"
    pain: "Two patterns shown for state access"
    evidence: |
      your-first-agent.mdx: `ctx.state.get("runs")` and `ctx.state.set("runs", runs)`
      expressions.mdx binding: `{{ state.runs }}`
      bindings.mdx: `{{ state.runs }}`
    suggestion: |
      Document that expressions use dot notation, code uses get/set. Make this explicit.
    priority: P2

naming_issues:
  - current: "harness"
    problem: "Overloaded term with unclear meaning. Test harness? Wiring harness? Open Harness?"
    suggestion: "executor, runner, or flowRunner. Reserve 'harness' for the project name only."

  - current: "DefaultNodeRegistry"
    problem: "What makes it 'default'? Implies there are other kinds but none documented."
    suggestion: "NodeRegistry or just use plain objects and hide the class entirely."

  - current: "Hub"
    problem: "Too generic. Hub of what? Network hub? Event hub? Message hub?"
    suggestion: "EventBus (what it actually is) or remove from public API entirely."

  - current: "runtime.dispatch()"
    problem: "Dispatch what? Suggests event dispatching but actually sends commands."
    suggestion: "runtime.send() or runtime.command() for sending commands."

  - current: "NodeTypeDefinition vs NodeDefinition"
    problem: "Confusing pair. One is the implementation, one is the flow config."
    suggestion: "NodeHandler (implementation) vs NodeConfig (flow definition)."

  - current: "RunSnapshot"
    problem: "Snapshot of what? Runtime state? Execution state?"
    suggestion: "ExecutionState or FlowState would be clearer."

  - current: "CommandInbox"
    problem: "Internal implementation detail leaking to users via ctx.inbox."
    suggestion: "Hide behind ctx.waitForMessage() or similar user-friendly API."

  - current: "echoNode vs claudeNode"
    problem: "Inconsistent: one has 'Node' suffix, could be echo vs claude.agent confusion."
    suggestion: "Consistent naming: either all have Node suffix or none do."

  - current: "flow.input vs flow.input"
    problem: "In YAML, accessing flow input requires flow.input.X, but node outputs are just nodeId.X"
    suggestion: "Consider allowing just `input.X` for flow input to match node pattern."

missing_conveniences:
  - feature: "Zero-config default registry"
    description: "Should be able to run flows with built-in nodes without creating a registry"
    current: |
      Must create registry and register nodes explicitly even for built-in types like echo.
      Quickstart shows: `registry: { [helloAgent.type]: helloAgent }` for custom nodes.
    stripe_would: |
      Built-in nodes just work. `runFlow({ flow, input })` would include echo, constant,
      claude.agent by default. Only need registry for custom nodes.

  - feature: "Type inference from YAML"
    description: "TypeScript users get no type safety from YAML flows"
    current: |
      Flow definitions from YAML are typed as FlowDefinition with unknown fields.
      Input/output types are lost.
    stripe_would: |
      Provide definedFlow<TInput, TOutput>() that infers types or generates them from YAML.
      Or provide CLI tool to generate types from YAML schema.

  - feature: "Error recovery patterns"
    description: "No documented way to handle node failures gracefully"
    current: |
      Events API shows node:error event but no guidance on retry, fallback, or recovery.
      No built-in retry node or error boundary pattern.
    stripe_would: |
      Built-in retry wrapper, error boundary nodes, or config option for retry policy.
      Clear documentation of failure modes and recovery patterns.

  - feature: "Debug mode / dry-run"
    description: "No way to validate a flow without running it"
    current: |
      Must run flow to discover binding errors, missing node types, invalid expressions.
    stripe_would: |
      validateFlow(flow) that checks all bindings resolve, all node types exist, all
      expressions parse. Run in debug mode to see what would happen without LLM calls.

  - feature: "Flow composition"
    description: "No way to compose flows from smaller flows"
    current: "Flows are monolithic YAML files. Can't reuse sub-flows."
    stripe_would: |
      Import sub-flows, define flow libraries, use flows as node types.
      `- type: subflow:code-review` referencing another flow.

leaky_abstractions:
  - abstraction: "Event system internals"
    leak: "User must understand RuntimeEvent structure to do basic debugging"
    evidence: |
      event-system.mdx explains all event types. But user just wants to see what's
      happening. Should be able to run with --verbose or debug mode without understanding
      event bus architecture.
    fix: |
      Provide built-in logging transport. `createHarness({ log: 'verbose' })` or similar.
      Hide event structure behind simpler callbacks like onNodeComplete, onAgentText.

  - abstraction: "Persistence layer"
    leak: "RunStore interface exposed to users who just want to save state"
    evidence: |
      persistence.mdx shows RunStore interface. User must understand events, snapshots,
      sequence numbers. Most users just want 'save my flow state to disk'.
    fix: |
      Provide simpler API: `createHarness({ persist: './data' })` that handles everything.
      Only expose RunStore for advanced users who need custom backends.

  - abstraction: "Transport architecture"
    leak: "WebSocket transport requires understanding of transport patterns"
    evidence: |
      channel.mdx explains transports, start/stop lifecycle. User just wants 'run my
      flow and expose it over websocket'.
    fix: |
      `createHarness({ serve: { port: 8080 } })` that auto-creates transport.
      Only expose Transport for custom protocols.

  - abstraction: "Agent sessions"
    leak: "ctx.getAgentSession/setAgentSession exposed in NodeRunContext"
    evidence: |
      agent.mdx shows getAgentSession in NodeRunContext. This is multi-turn conversation
      state - should be handled automatically by the framework.
    fix: |
      Hide session management. Provide declarative config like `multiTurn: true` on
      agent nodes. Framework manages session IDs internally.

documentation_inconsistencies:
  - location: "Flow YAML vs bindings docs"
    issue: "Different node output access patterns"
    details: |
      flow-yaml.mdx: `{{ nodes.security-check.output.text }}`
      bindings.mdx: `{{ triage.summary }}` (direct access)
      These cannot both be correct. Testing would reveal which actually works.

  - location: "persistence.mdx vs run-store.mdx"
    issue: "Different RunStore interface signatures"
    details: |
      persistence.mdx shows: `saveEvent(runId, event)`, `getEvents(runId)`, `getRun(runId)`
      run-store.mdx shows: `appendEvent(runId, event)`, `loadSnapshot(runId)`, `loadEvents(runId, afterSeq?)`
      Different method names, different semantics.

  - location: "index.mdx vs quickstart.mdx"
    issue: "Different YAML root structure"
    details: |
      index.mdx shows: `flow:\n  name: research-and-summarize\nnodes:`
      quickstart.mdx shows: `name: hello-world\nnodes:` (no flow: wrapper)
      Which is correct? Users will be confused.

  - location: "Built-in node list"
    issue: "Inconsistent lists of built-in nodes across docs"
    details: |
      node-registry.mdx: claude.agent, constant, echo
      node-definition.mdx: claude.agent, http.get, http.post, map, delay
      flow-yaml.mdx: claude.agent, http.get, http.post, map, delay
      Which nodes actually exist?

v030_backlog:
  - title: "Unify entry points to single run() function"
    description: |
      Replace runFlow/createHarness/createRuntime with single `run()` function.
      Options object enables progressive disclosure. Runtime access via return value.
    priority: P0
    rationale: |
      Three entry points at three abstraction levels creates confusion. Stripe has
      stripe.customers.create() - one way to do things. We should have one run().

  - title: "Fix expression binding path inconsistency"
    description: |
      Audit all docs and source. Pick ONE canonical form for node output access.
      Recommend: `{{ nodeId.field }}` without .output or nodes. prefix.
    priority: P0
    rationale: |
      This is actively confusing users. Docs contradict each other. Source of truth unclear.

  - title: "Standardize edge condition field name"
    description: |
      Pick 'when' or 'condition', deprecate the other. Update all docs.
    priority: P0
    rationale: |
      Using both interchangeably suggests sloppiness. Users don't know which is 'right'.

  - title: "Hide Hub from public API"
    description: |
      Hub is an internal coordination mechanism. Users should interact with Runtime or
      simple callbacks. Remove Hub references from user-facing docs.
    priority: P1
    rationale: |
      Hub is mentioned but not exported. Confusing internal leak.

  - title: "Provide built-in logging/debugging"
    description: |
      Add `debug: true` or `log: 'verbose'` option that provides human-readable output
      of flow execution without understanding event system.
    priority: P1
    rationale: |
      Currently users must understand RuntimeEvent structure to debug. Too low-level.

  - title: "Add flow validation function"
    description: |
      `validateFlow(flow)` that checks: all bindings resolve, all node types exist,
      all expressions parse, no cycles, etc.
    priority: P1
    rationale: |
      Currently must run flow to find errors. Stripe validates API requests immediately.

  - title: "Document error handling patterns"
    description: |
      Add guide for: retry patterns, error boundaries, fallback nodes, recovery flows.
      Consider built-in retry wrapper node.
    priority: P2
    rationale: |
      Production flows need error handling. Currently underdocumented.

  - title: "Simplify persistence API"
    description: |
      `createHarness({ persist: './data' })` instead of explicit RunStore creation.
      Hide implementation details.
    priority: P2
    rationale: |
      Most users just want 'save my state'. Don't need to understand events/snapshots.

  - title: "Consistent built-in node documentation"
    description: |
      Audit and list ALL built-in nodes in one place. Verify each exists and works.
      Remove references to nodes that don't exist.
    priority: P2
    rationale: |
      Different docs list different nodes. Confidence-destroying.

  - title: "Type inference from YAML flows"
    description: |
      Either generate TypeScript types from YAML or provide typed flow builders.
      Consider: Zod schemas in YAML that generate TS types.
    priority: P3
    rationale: |
      TypeScript users lose all type safety when using YAML flows.

conclusion: |
  Open Harness has good bones but needs significant DX polish. The core issues are:

  1. **Inconsistency**: Docs contradict each other (paths, field names, interfaces)
  2. **Leaky abstractions**: Internal concepts (Hub, RunStore, Events) exposed too early
  3. **Multiple entry points**: Three ways to run a flow without clear guidance
  4. **Naming**: Terms like 'harness', 'hub', 'dispatch' don't self-document

  The v0.2.0 philosophy doc mentions "DX-First" and "Zero external complexity" but
  the current API doesn't live up to that vision. The good news: these are fixable
  with focused refactoring. The API surface is already small - it just needs to be
  smaller and more consistent.

  Stripe test: Would Stripe ship this? Not yet. Stripe's APIs are famously consistent,
  well-documented, and have exactly one obvious way to do things. Open Harness has
  good ideas but needs another pass at API design and doc consistency.
